---
title: "taxa_DESeq2"
author: "Chiamh"
date: '2023-04-08'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


This is updated as of Jan 2024. The main difference between this iteration and "taxa_DESeq2_Oct2023.Rmd" is that we are performing the taxa DESeq2 analysis on the read count matrix with features thresholded at (rowMedians(mat) >= 10).

Also try performing GSEA (not just hypergeometric testing) for GO terms instead of only KEGG.


```{r}

library(tidyverse)
library(reshape2)


library(DESeq2)

library(RColorBrewer)

library(pheatmap)
library("ComplexHeatmap")
library(tximport)

#pheatmap() has been masked by ComplexHeatmap::pheatmap()
#Most of the arguments
#in the original pheatmap() are identically supported in the new function. You 
#can still use the original function by explicitly calling pheatmap::pheatmap().

library(EnhancedVolcano)
library(ggpubr)

library("clusterProfiler") #v4.4.4
library(scales)

library(metagenomeSeq)
library(ALDEx2) #v1.28.1
library(propr) #version 2.1.2

#https://stackoverflow.com/questions/45902376/printing-venn-diagram-after-calculating-overlap
library(VennDiagram)
library("GSEABase")
```


Load in metadata and supporting files.


```{r}

metadata <- read_tsv("../metadata/skin_mtx_metadata_fmt.txt", show_col_types = FALSE) 

mgx_stats <- read_tsv("../metadata/MGX_QC_stats.txt", show_col_types = FALSE) 

mtx_stats <- read_tsv("../metadata/MTX_QC_stats.txt", show_col_types = FALSE) 

mgx_stats <- merge(mgx_stats, metadata, by = "LIBID", all.x=TRUE)

mtx_stats <- merge(mtx_stats, metadata, by ="LIBID", all.x=TRUE)


mtx_to_pull <- read_tsv("../metadata/mtx_to_pull", col_names = FALSE, show_col_types = FALSE) %>% pull(X1)

mgx_to_pull <- read_tsv("../metadata/mgx_to_pull", col_names = FALSE, show_col_types = FALSE) %>% pull(X1)

mtx_stats_chosen <- mtx_stats %>% dplyr::filter(LIBID %in% mtx_to_pull)

mgx_stats_chosen <- mgx_stats %>% dplyr::filter(LIBID %in% mgx_to_pull)

mtx_mgx_stats_chosen <- read_tsv(file="../metadata/mtx_mgx_stats_chosen.tsv", show_col_types = FALSE)

##########
#MTX Library IDs per site

mtx_Sc_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Sc") %>% pull(mtx_LIBID)
mtx_Ch_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Ch") %>% pull(mtx_LIBID)
mtx_Ac_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Ac") %>% pull(mtx_LIBID)
mtx_Vf_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Vf") %>% pull(mtx_LIBID)
mtx_Tw_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Tw") %>% pull(mtx_LIBID)

#MGX Library IDs per site

mgx_Sc_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Sc") %>% pull(mgx_LIBID)
mgx_Ch_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Ch") %>% pull(mgx_LIBID)
mgx_Ac_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Ac") %>% pull(mgx_LIBID)
mgx_Vf_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Vf") %>% pull(mgx_LIBID)
mgx_Tw_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Tw") %>% pull(mgx_LIBID)

##########

COG_categories <- read_tsv("../metadata/eggnog_cat.txt") %>% dplyr::rename(COG=eggnog_cat, 
                                                                           COG_functional_cat=eggnog_functional_cat,
                                                                           COG_desc=cat_definition)

##########
#Last pubmed search date: 24th Nov 2022

#load disbiome and microphenoDB results for genera reported on skin, both for mgx and mtx data

disbiome_skin_res <- read_tsv("../metadata/mtx_contam_genera.tsv", show_col_types = FALSE)



genera_to_remove <- c(disbiome_skin_res %>% 
                        filter(reported_for_skin_disease_in_disbiome == FALSE & 
                                 reported_on_skin_in_microphenoDB ==FALSE &
                                 pubmed_skin_microbiome == FALSE) %>% 
                        pull(name), "Homo", "Listeria", "Plesiomonas", "Vibrio") #34 candidates to remove

genera_mask <- stringi::stri_paste("^",genera_to_remove, collapse="|")

#Derived from sparCC correlation analysis
#In some applications, should add Homo_sapiens and unclassified to this
species_to_remove <- read_tsv("../metadata/species_to_remove", col_names = FALSE, show_col_types = FALSE) %>% pull(X1) #111


################
##For GO analysis
################

## Load goslim_metagenome annotations

goslim_metagenome_term2name <- read_tsv("../metadata/goslim_metagenome.txt", 
                                    col_names = c("GO_slim","GO_desc"), show_col_types = FALSE) %>% 
  dplyr::rename(from=GO_slim, to=GO_desc)


# Load GO annotations
GO_annot_all <- read_tsv("../metadata/all_GO_annotations.tsv", show_col_types = FALSE)


#Select annotations associated with "Biological Process"
GO_BP_term2name <- GO_annot_all %>% 
  dplyr::filter(ontology=="BP") %>% 
  dplyr::select(GO_ID, GO_desc) %>%
  dplyr::rename(from=GO_ID, to=GO_desc)


#Select annotations associated with "Molecular Function"
GO_MF_term2name <- GO_annot_all %>% 
  dplyr::filter(ontology=="MF") %>% 
  dplyr::select(GO_ID, GO_desc) %>%
  dplyr::rename(from=GO_ID, to=GO_desc)


#Select annotations associated with "Cellular Component"
GO_CC_term2name <- GO_annot_all %>% 
  dplyr::filter(ontology=="CC") %>% 
  dplyr::select(GO_ID, GO_desc) %>%
  dplyr::rename(from=GO_ID, to=GO_desc)


#######

#download KO pathway annotations
#https://www.genome.jp/kegg/mapper/search.html
#https://www.genome.jp/kegg-bin/show_organism?menu_type=pathway_maps&org=ko

#ko.pathways <- download_KEGG(species="ko")
#term2name <- ko.pathways$KEGGPATHID2NAME
#write_tsv(term2name, file="../metadata/KEGG_term2name.tsv")

#Load in term2name so that we do not have to download_KEGG every time we re-run this chunk
KEGG_term2name <- read_tsv("../metadata/KEGG_term2name.tsv", show_col_types = FALSE)





###########
##Malassezia analysis files
##########

#See 04_mh_lab_book.Rmd 12/04/2023 for how the Malassezia files were generated

###Load Malassezia transcriptome eggNOG annotations. Also need to associate each query with a Malassezia locus tag
#This can be done with Malassezia_tx2gene

Malassezia_OG_annot <- read_tsv("../genomes/emapper_out/Malassezia_CDS.emapper.annotations",
                                                   comment="#", show_col_types = FALSE,
                                                   col_names = c("query",  
                                                                 "seed_ortholog",   
                                                              "evalue",
                                                              "score",
                                                              "eggNOG_OGs",
                                                              "max_annot_lvl",
                                                              "COG_category",
                                                              "Description",
                                                              "Preferred_name", 
                                                              "GOs", "EC", "KEGG_ko",
                                                              "KEGG_Pathway", "KEGG_Module",
                                                              "KEGG_Reaction",  "KEGG_rclass",
                                                              "BRITE", "KEGG_TC", 
                                                              "CAZy", "BiGG_Reaction", "PFAMs"))


###########
##M restricta
##########
#Malassezia restricta has good annotations from the gtf file. Transfer those labels here as well. See extract_annots.sh
#Unfortunately, M globosa does not have equally good annotations in the gtf file.
#Gene is actually "locus_tag"
M_res_gtf_annots <- read_tsv("../metadata/M_restricta_GCA_003691605.1_ASM369160v1_cds_from_genomic_annots.tsv", 
                             col_names = c("gene_tag","gene","proteinID"), show_col_types = FALSE)

M_res_gtf_annots$annot <- ifelse(is.na(M_res_gtf_annots$gene_tag) & is.na(M_res_gtf_annots$proteinID), 
                                 M_res_gtf_annots$gene, ifelse(is.na(M_res_gtf_annots$gene_tag)
                                                               & !is.na(M_res_gtf_annots$proteinID), 
                                                               M_res_gtf_annots$proteinID, M_res_gtf_annots$gene_tag)
                                 )
M_res_gtf_annots$annot <- paste0(M_res_gtf_annots$gene,"_",M_res_gtf_annots$annot)
#Shorten very long label
M_res_gtf_annots$annot <- gsub(pattern="putative CDP-alcohol phosphatidyltransferase class-I family protein C22A12.10", 
                               replacement="CDP-alcohol phosphatidyltransferase",
                               M_res_gtf_annots$annot)


###########
##M globosa
##########
#For salmon tximport
Malassezia_tx2gene <- read_tsv("../metadata/Malassezia_tx2gene.tsv", col_names = FALSE, show_col_types = FALSE) #21037 transcripts and 21025 genes

#Add Malassezia gene annotations to the eggnog annotation file
colnames(Malassezia_tx2gene) <- c("query","gene")
Malassezia_OG_annot <- merge(Malassezia_OG_annot, Malassezia_tx2gene, all.x=TRUE, by = "query")


MGL_OG_annot <- Malassezia_OG_annot %>% dplyr::filter(str_detect(string=Malassezia_OG_annot$gene, pattern="MGL"))
MGL_OG_annot$annot <- paste0(MGL_OG_annot$gene,"_",MGL_OG_annot$Description)

#Details of M globosa genes and the 13 secreted lipases
MGL_secretory_lipase <- MGL_OG_annot %>% dplyr::filter(str_detect(string=MGL_OG_annot$Description, pattern="Secretory lipase|^Lipase"))


###########
##Bacteria analysis files
##########

#####
#Load in annotations of microbial pangene clusters
S_epi_anno <- read_csv("../genomes/1282.Staphylococcus.epidermidis.pangenome.annotation.matrix.csv", show_col_types = FALSE) %>% dplyr::rename(propan_clusterID=Clusters)
S_epi_pangene_names <- read_tsv("../genomes/S_epi_derep_pangenome_names.txt", 
                                col_names = "pangene",
                                show_col_types = FALSE) #29159, derived from eight_skin_bact_pangenome_rep_names.txt

C_acnes_anno <- read_csv("../genomes/1747.Cutibacterium.acnes.pangenome.annotation.matrix.csv",
                         show_col_types = FALSE) %>% dplyr::rename(propan_clusterID=Clusters)
C_acnes_pangene_names <- read_tsv("../genomes/C_acnes_derep_pangenome_names.txt", 
                                  col_names = "pangene",
                                  show_col_types = FALSE) #9922

S_capitis_anno <- read_csv("../genomes/29388.Staphylococcus.capitis.pangenome.annotation.matrix.csv",
                           show_col_types = FALSE) %>% dplyr::rename(propan_clusterID=Clusters)

S_capitis_pangene_names <- read_tsv("../genomes/S_capitis_derep_pangenome_names.txt", 
                                    col_names = "pangene", show_col_types = FALSE)

S_epidermidis_anno <- read_csv("../genomes/1282.Staphylococcus.epidermidis.pangenome.annotation.matrix.csv",
                               show_col_types = FALSE) %>% dplyr::rename(propan_clusterID=Clusters)

S_epidermidis_pangene_names <- read_tsv("../genomes/S_epidermidis_derep_pangenome_names.txt", 
                                        col_names = "pangene",
                                        show_col_types = FALSE)

S_hominis_anno <- read_csv("../genomes/1290.Staphylococcus.hominis.pangenome.annotation.matrix.csv",
                           show_col_types = FALSE) %>% dplyr::rename(propan_clusterID=Clusters)

S_hominis_pangene_names <- read_tsv("../genomes/S_hominis_derep_pangenome_names.txt", 
                                    col_names = "pangene",
                                    show_col_types = FALSE)

#Load emapper annotations for the eight skin bacteria (for species specific analysis)
#See 04_mh_lab_book.Rmd, 04/12/2023 for how the eight skin bact results were generated

eight_skin_bact_proteins_emapper_annot <- read_tsv("../genomes/emapper_out/eight_skin_bact_proteins.emapper.annotations",
                                                   comment="#", show_col_types = FALSE,
                                                   col_names = c("query",  
                                                                 "seed_ortholog",   
                                                              "evalue",
                                                              "score",
                                                              "eggNOG_OGs",
                                                              "max_annot_lvl",
                                                              "COG_category",
                                                              "Description",
                                                              "Preferred_name", 
                                                              "GOs", "EC", "KEGG_ko",
                                                              "KEGG_Pathway", "KEGG_Module",
                                                              "KEGG_Reaction",  "KEGG_rclass",
                                                              "BRITE", "KEGG_TC", 
                                                              "CAZy", "BiGG_Reaction", "PFAMs"))



eight_skin_bact_proteins_emapper_annot$species <- word(eight_skin_bact_proteins_emapper_annot$query,1,2,sep="_")

eight_skin_bact_proteins_emapper_annot$propan_clusterID <- word(eight_skin_bact_proteins_emapper_annot$query,3,4,sep="_")


#Load signal P results


eight_skin_microbial_secretory <- read_tsv("../data/signalP_out/eight_skin_bact_pangenome_signalP6_prediction_results_secretory.txt",
                                           col_names = c("pangene","prediction",
                                                         "OTHER","SP","LIPO","TAT","TATLIPO", "PILIN", "CS_position"),
                                           show_col_types = FALSE)


#Malassezia signal P 6 results

malassezia_secretory <- read_tsv("../data/signalP_out/Malassezia_transcripts_translated_signalP6_prediction_results_secretory_fmt.tsv",
                                 col_names = c("ID", "prediction", 
                                               "OTHER","SP", "CS_position", "pangene",
                                               show_col_types=FALSE))



  
```

Define custom helper functions and wrappers.

```{r}
#colorblind friendly palette
c24 <- c(
  "dodgerblue2", "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
  "black", "gold1",
  "skyblue2",
  "palegreen2",
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
  "gray70", "khaki2",
  "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
  "darkturquoise", "green1", "yellow4", "yellow3",
  "darkorange4", "brown"
)


c23 <- c(
  "dodgerblue2", "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
 "gold1",
  "skyblue2",
  "palegreen2",
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
  "gray70", "khaki2",
  "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
  "darkturquoise", "green1", "yellow4", "yellow3",
  "darkorange4", "brown"
)



##Define helper functions



#This function selects for mtx libraries corresponding to sites of choice.
#Assumes input is already a count matrix from Salmon quant
#Species can be "Malassezia_restricta", "Malassezia_globosa" etc
run_DESeq_with_salmon_matrix <- function(input_matrix, 
                                        input_metadata=mtx_stats_chosen,
                                        lib_vec,
                                        cond, 
                                        ref_cond, 
                                        run_test=FALSE,
                                        control_for_individuals=TRUE,
                                  size_factor_function = "poscounts",
                                  species="Malassezia_restricta"){
  
  libs_to_pull <- input_metadata %>% dplyr::filter(LIBID %in% lib_vec) %>% pull(LIBID)
  
  if (species== "Malassezia_restricta"){
    
    loci<-"DNF"
    
  } else if (species=="Malassezia_globosa"){
    
    loci<-"MGL"
    
  } else if (species=="Malassezia_sympodialis"){
    
    loci<-"MSYG"
    
  } else if (species=="Malassezia_furfur"){
    
    loci <-"CBS"
    
  } else if (species=="Malassezia_arunalokei"){
    
    loci <-"MARU"
  }
  
  
  ##############################################
  ## prepare input read count matrix for DESeq2#
  ##############################################
  
  #Subset read count matrix with the selected libraries AND species.
  
  chosen_matrix <- input_matrix[grep(loci, row.names(input_matrix)),libs_to_pull]
  
  #Convert to matrix of integers
  
  chosen_matrix <- round(chosen_matrix)
  mode(chosen_matrix) <- "integer"
  
  ##############################################
  ## prepare metadata for DESeq2               #
  ##############################################
  

  selected_metadata <- input_metadata %>% dplyr::filter(LIBID %in% lib_vec) %>% 
    dplyr::select(LIBID, subject, region) %>% as.data.frame()
  
  rownames(selected_metadata) <- selected_metadata$LIBID
  
  selected_metadata <- selected_metadata %>% dplyr::select(-LIBID)
  
  selected_metadata$subject <- as.factor(selected_metadata$subject)
  selected_metadata$region <- as.factor(selected_metadata$region)
  
  #the row names of metadata should automatically be ordered in a way that matches the input matrix
  #reorder rows of the metadata
  idx <- match(colnames(chosen_matrix), rownames(selected_metadata))
  selected_metadata <- selected_metadata[idx,]
  
  
  #a vector of LIBIDs
  RNA_libs <- selected_metadata %>% row.names()
  
  ##############################################
  ## Run DESeq2                                #
  ##############################################
  #https://www.biostars.org/p/412320/ DESeqDataSetFromTximport rounds salmon matrix to integers, unlike DESeqDataSetFromMatrix
  #Here I am using the salmon read matrix straight off, so I have manually done the rounding
  
  #https://support.bioconductor.org/p/9137115/
  #If your design is not confounded (e.g. you have balanced your conditions of interest within batches or other nuisance variables) then you can do, e.g. ~batch + condition or       #~batch + nuisance1 + nuisance2 + condition.
  
  if(control_for_individuals==TRUE){
  dds <- DESeqDataSetFromMatrix(countData = chosen_matrix, 
                                colData = selected_metadata, 
                                design = ~subject+region)
  } else if (control_for_individuals==FALSE){
  dds <- DESeqDataSetFromMatrix(countData = chosen_matrix, 
                                colData = selected_metadata, 
                                design = ~region)  
    
  }

  #Pre-filtering to keep rows with a minimum median read count <= 10 for genes

  mat <- counts(dds)
  
  keep <- (rowMedians(mat) >= 10)
  dds <- dds[keep,]
  
  #####Estimate size factors
  dds <- estimateSizeFactors(dds,  type = size_factor_function)
  
  dds$region <- relevel(dds$region, ref_cond)
  
  normalized_counts <- counts(dds, normalized=TRUE)
  
  #See error and fix:https://support.bioconductor.org/p/98634/
  #See DESeq2 vignette about blind dispersion estimation
  #https://www.biostars.org/p/428369/
  
  vsd <- vst(dds, blind=FALSE)  
  
  vsd_mat <- assay(vsd)
  
  vsd_cor <- cor(vsd_mat)
  
  
  if (run_test==FALSE){
  outputs <- tibble::lst(chosen_matrix, keep, selected_metadata,
                         dds,
                         normalized_counts,
                         vsd, vsd_mat, vsd_cor)
  } else if (run_test==TRUE){
    
  dds <- DESeq(dds)   #wald test
    
  DE_results <- results(dds,contrast=c("region",cond,ref_cond),
                          alpha=0.05)
    
  DE_results_shrunken <- lfcShrink(dds,
                                     type="ashr",
                                     res=DE_results)
    
  DE_results_shrunken_df <- data.frame(DE_results_shrunken)
    
  DE_results_shrunken_df$gene <- rownames(DE_results_shrunken_df)
  
  outputs <- tibble::lst(lib_vec, chosen_matrix, keep, selected_metadata,
                         skin_site=cond, ref_skin_site=ref_cond,
                         dds,
                         normalized_counts,
                         vsd, vsd_mat, vsd_cor,
                         DE_results, DE_results_shrunken,
                         DE_results_shrunken_df)
  }
  return(outputs)
}


##modify the plotPCA function

plotPCA_custom.DESeqTransform = function(object, intgroup="condition", ntop=500, returnData=FALSE)
{
  # calculate the variance for each gene
  rv <- rowVars(assay(object))

  # select the ntop genes by variance
  select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]

  # perform a PCA on the data in assay(x) for the selected genes
  pca <- prcomp(t(assay(object)[select,]))

  # the contribution to the total variance for each component
  percentVar <- pca$sdev^2 / sum( pca$sdev^2 )

  if (!all(intgroup %in% names(colData(object)))) {
    stop("the argument 'intgroup' should specify columns of colData(dds)")
  }

  intgroup.df <- as.data.frame(colData(object)[, intgroup, drop=FALSE])
  
  # add the intgroup factors together to create a new grouping factor
  group <- if (length(intgroup) > 1) {
    factor(apply( intgroup.df, 1, paste, collapse=":"))
  } else {
    colData(object)[[intgroup]]
  }

  # assembly the data for the plot
  d <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], group=group, intgroup.df, name=colnames(object))

  if (returnData) {
    attr(d, "percentVar") <- percentVar[1:2]
    return(d)
  }
  
  ggplot(data=d, aes_string(x="PC1", y="PC2", color="group")) + geom_point(size=5) + 
    xlab(paste0("PC1: ",round(percentVar[1] * 100),"% variance")) +
      ylab(paste0("PC2: ",round(percentVar[2] * 100),"% variance")) +
        coord_fixed() + theme_classic() + scale_color_manual(values=c24)
}

setMethod("plotPCA", signature(object="DESeqTransform"), plotPCA_custom.DESeqTransform)



##This function creates a custom term2gene dataframe for specific Malassezia species, based on Eggnog annotated malassezia transcriptomes.

get_Malassezia_term2gene_df <- function(tx2gene=Malassezia_tx2gene, species, annotation_used="KEGG"){
  
  if (species== "Malassezia_restricta"){
    
    loci<-"DNF"
    
  } else if (species=="Malassezia_globosa"){
    
    loci<-"MGL"
    
  } else if (species=="Malassezia_sympodialis"){
    
    loci<-"MSYG"
    
  } else if (species=="Malassezia_furfur"){
    
    loci <-"CBS"
    
  } else if (species=="Malassezia_arunalokei"){
    
    loci <-"MARU"
  }
  
  #Get the species specific tx2gene df
  
  tx2gene_specific <- tx2gene %>% dplyr::filter(str_detect(tx2gene$gene, pattern = loci))
  #Add  KEGG pathway terms
  tx2gene_specific <- merge(tx2gene_specific, Malassezia_OG_annot, by = c("query",
                                                                          "gene"), all.x=TRUE)
  
  tx2gene_specific[is.na( tx2gene_specific)] <- "-"
  
  if (annotation_used=="KEGG"){
    Malassezia_anno_KO <-  tx2gene_specific %>% dplyr::select(c("gene", "KEGG_Pathway")) %>% 
      dplyr::filter(KEGG_Pathway != "-")
  
    Malassezia_anno_KO <- Malassezia_anno_KO %>% tidyr::separate_rows(KEGG_Pathway, sep = ",")

    Malassezia_anno_map <- Malassezia_anno_KO %>% dplyr::filter(str_detect(string=Malassezia_anno_KO$KEGG_Pathway,
                                                                         pattern="map"))
  
    #Create the species specific term2gene dataframe for KEGG pathways
  
    term2gene <- data.frame(from=Malassezia_anno_map$KEGG_Pathway, to=Malassezia_anno_map$gene)
    
  } else if (annotation_used == "GO"){
    
    Malassezia_anno_GO <- tx2gene_specific %>% dplyr::select(c("gene", "GOs")) %>% 
      dplyr::filter(GOs != "-")
    
    
    Malassezia_anno_GO <- Malassezia_anno_GO %>% tidyr::separate_rows(GOs, sep = ",") %>% unique()
    
    term2gene <- Malassezia_anno_GO %>% dplyr::rename(from="GOs", to="gene") %>% dplyr::select(from, to)
  }
  
  return(term2gene)
   
}

####
#The following function is for running DESeq from a input list object derived from pileup.sh's outputs
#Updated to analyze read counts for features that are aggregated into original propan_clusterIDs
run_DESeq_with_input_list <- function(input_list, 
                                   input_metadata=mtx_stats_chosen,
                                   cond, 
                                  ref_cond,
                                  lib_vec,
                                   run_test=FALSE, 
                                  control_for_individuals=TRUE,
                                  manual_vst_nsub = FALSE,
                                  size_factor_function = "poscounts"
                                  ){
  
  ##############################################
  ## prepare input read count matrix for DESeq2#
  ##############################################
  
  #Obtain count data for eligible mtx and mgx
  rawcounts <- input_list[lib_vec] %>% do.call("rbind",.)
  
  count_matrix <- pivot_wider(rawcounts %>% 
                        dplyr::select(propan_clusterID, unpaired_read_count_sum, LIBID), names_from = LIBID, 
                        values_from = unpaired_read_count_sum) %>%
                        as.data.frame()
  
  rownames(count_matrix) <- count_matrix$propan_clusterID
  
  count_matrix <- count_matrix %>% dplyr::select(-propan_clusterID) %>% as.matrix()
  
  #This matrix operation is much faster than mutate_all(~replace(.,is.na(.),0)) for tibbles/df
  count_matrix[is.na(count_matrix)] <- 0 
  
  ##############################################
  ## prepare metadata for DESeq2               #
  ##############################################
  
  
  selected_metadata <- input_metadata %>% dplyr::filter(LIBID %in% lib_vec) %>% 
    dplyr::select(LIBID, subject, region) %>% as.data.frame()
  
  rownames(selected_metadata) <- selected_metadata$LIBID
  
  selected_metadata <- selected_metadata %>% dplyr::select(-LIBID)
  
  selected_metadata$subject <- as.factor(selected_metadata$subject)
  selected_metadata$region <- as.factor(selected_metadata$region)
  
  #reorder rows of the metadata
  idx <- match(colnames(count_matrix), rownames(selected_metadata))
  selected_metadata <- selected_metadata[idx,]
  
 
  ##############################################
  ## Run DESeq2                                #
  ##############################################
  
  if (control_for_individuals==TRUE){
    dds <- DESeqDataSetFromMatrix(countData = count_matrix, 
                                colData = selected_metadata, 
                                design = ~ subject + region)
  } else if (control_for_individuals==FALSE){
    dds <- DESeqDataSetFromMatrix(countData = count_matrix, 
                                colData = selected_metadata, 
                                design = ~ region)
    
  }
  

  #Pre-filtering to keep rows with a minimum median read count for transcripts/propan clusters.

  mat <- counts(dds)
  
  keep <- (rowMedians(mat) >= 10)
  dds <- dds[keep,]

  #####Estimate size factors
  dds <- estimateSizeFactors(dds,  type = size_factor_function)
  
  dds$region <- relevel(dds$region, ref_cond)

  normalized_counts <- counts(dds, normalized=TRUE)
  
  # set manual_vst_nsub == TRUE if number of rows in dataset is lower than the DESeq2 default of 1000
  if (manual_vst_nsub == FALSE){
    vsd <- vst(dds, blind=FALSE) 
  } else if (manual_vst_nsub == TRUE){
    vsd <- vst(dds, blind=FALSE, nsub=sum( rowMedians(normalized_counts) >= 10 )) 
  }
   
  
  vsd_mat <- assay(vsd)
  
  vsd_cor <- cor(vsd_mat)

  
  if (run_test==FALSE){
  outputs <- tibble::lst(count_matrix, keep, selected_metadata,
                         dds,
                         normalized_counts,
                         vsd, vsd_mat, vsd_cor)
  }else if (run_test==TRUE){
    dds <- DESeq(dds)
    
    ##Removing rows which do not converge in beta 
    dds <- dds[which(mcols(dds)$betaConv),]
    
    DE_results <- results(dds,
                          contrast=c("region",cond,ref_cond),
                          alpha=0.05)
    
    DE_results_shrunken <- lfcShrink(dds,
                                     type="ashr",
                                     res=DE_results)
    
    DE_results_shrunken_df <- data.frame(DE_results_shrunken)
    
    DE_results_shrunken_df$propan_clusterID <- rownames(DE_results_shrunken_df)
    
    outputs <- tibble::lst(lib_vec, count_matrix, keep, 
                           cond, ref_cond,
                          selected_metadata,
                         dds,
                         normalized_counts,
                         vsd, vsd_mat, vsd_cor,
                         DE_results, DE_results_shrunken,
                         DE_results_shrunken_df)
    
  }
  
  return(outputs)
}


##########
##Wrappers for clusterprofiler analysis
#########

#Load KEGG pathway map IDs corresponding to organismal systems and human diseases
#These are not relevant for metagenomic/mtx analysis

KEGG_hum_disease_pathways <- read_tsv("../metadata/KEGG_hum_disease_pathway_modules.txt", 
                                      show_col_types = FALSE,
                                      col_names = "map_ID")

KEGG_org_sys_pathways <- read_tsv("../metadata/KEGG_organismal_systems_pathway_modules.txt", 
                                      show_col_types = FALSE,
                                      col_names = "map_ID")


#Depending on annotation_used, ("KEGG" or  "GO")
#An example input_annot can be the pangenome annotation csv downloaded from the propan website
#Another possible input can be eight_skin_bact_proteins_emapper_annot or Malassezia_CDS_emapper_annot, subsetted for species specificity
#pangene_names can be like S_epi_derep_pangenome_names.txt (species specific)
#NOTE: Inputs must be species specific

#Example:
#test_term2gene <- make_custom_term2gene_df(input_annot = eight_skin_bact_proteins_emapper_annot %>% 
#                                             dplyr::filter(species=="Cutibacterium_acnes"), annotation_used = "GO")

make_custom_term2gene_df <- function(input_annot, pangene_names, annotation_used="KEGG"){
  
  if(annotation_used=="KEGG"){
    colnames(input_annot)[7] <- "KEGG_Pathway"
    
    annot_KO <- input_annot %>% dplyr::select(propan_clusterID, KEGG_Pathway) %>% dplyr::filter(KEGG_Pathway != "-")
  
    annot_KO <- annot_KO %>% tidyr::separate_rows(KEGG_Pathway, sep = ";")

    annot_KO <- annot_KO %>% dplyr::filter(str_detect(string=annot_KO$KEGG_Pathway, pattern="map"))

    annot_KO$KEGG_Pathway_term <- str_match(string=annot_KO$KEGG_Pathway, pattern="map[0-9]*")[,1]
  
    pangene_names$propan_clusterID <- str_match(string=pangene_names$pangene, pattern="cluster_[0-9]*")[,1]
  
    pangene_names_filt <- merge(pangene_names, annot_KO, by ="propan_clusterID")
  
    #to=pangene_names_filt$pangene is also possible
    output_term2gene <- data.frame(from=pangene_names_filt$KEGG_Pathway_term, 
                                   to=pangene_names_filt$propan_clusterID) %>% unique()
    
    #remove rows corresponding to pathways for organismal systems or human diseases
    
    output_term2gene <- output_term2gene %>% dplyr::filter(!from %in% c(KEGG_hum_disease_pathways$map_ID,
                                                                        KEGG_org_sys_pathways$map_ID))
    
  } else if (annotation_used=="GO"){
 
    annot_GO <- input_annot %>% dplyr::select(propan_clusterID, GOs) %>% 
      dplyr::filter(GOs != "-")
    
    annot_GO <- annot_GO %>% tidyr::separate_rows(GOs, sep = ",") %>% unique()
    
    output_term2gene <- annot_GO %>% dplyr::rename(from="GOs", to="propan_clusterID") %>% dplyr::select(from, to)
    
  }
  
  
  return(output_term2gene)
  
}





#Changing df contains the changing genes (up or downregulated)
#background_df contains all detected genes in the DESeq2 results
run_clusterprofiler <- function(changing_df, background_df, term2gene, term2name=KEGG_term2name){
  
 #the "universe"/background of genes, is all the detected genes in the DEseq2 results and NOT all possible eggnog entries in the bacterial pangenome
  term2gene_filt <- term2gene %>% dplyr::filter(to %in% background_df$feature)
  
  #We actually want to define the universe as all detected genes, which is bigger than the intersect of the background_df and term2gene (previous line)
  other_background <- background_df %>% dplyr::filter(!feature %in% term2gene_filt$to)
  
  if (nrow(other_background) > 0){
    
    other_background_term2gene <- data.frame(from="map00000", to=other_background$feature)
  
    term2gene_universe <- rbind(term2gene_filt, other_background_term2gene)
    
  } else {
    
    term2gene_universe <- term2gene_filt
    
  }
  
  #Add dummy term to term2name
  term2name_dummy <- data.frame(from="map00000", to="No_annotation")
  term2name <- rbind(term2name, term2name_dummy)
  
  
  #changing_df contains the genes that are significantly different between conditions
  
  #clusterProfiler ORA analysis requires a ranked gene list, which contains three features
  #numeric vector: fold change or other type of numerical variable
  #named vector: every number has a name, the corresponding gene ID
  #sorted vector: number should be sorted in decreasing order
  
  #prepare the numeric vector of l2fc of significant DE genes
  geneList <- changing_df$log2FoldChange
  
  #Name the vectors
  names(geneList) <- as.character(changing_df$feature)
  
  #sort the vectors in decreasing order.
  geneList <- sort(geneList, decreasing = TRUE)
  
  #run the ORA analysis
 
  output <- enricher(gene=names(geneList),
                     pvalueCutoff = 0.05, 
                     pAdjustMethod = "BH",
                     minGSSize = 10,
                     maxGSSize = 500,
                     TERM2GENE = term2gene_universe,
                     TERM2NAME = term2name)
  
  
  return(output)
   
}

#Write a function to determine which enriched pathway is upregulated or downregulated
#DE_df can be something like M_restricta_Sc_Ch_DE_res
#It does not really make sense to call a pathway "up-" or "down-" regulated. See: https://advaitabio.com/ipathwayguide/how-do-i-know-if-a-pathway-is-up-regulated-or-down-regulated/

#The median_upreg and median_downreg labels are only for convenience

label_enriched_KEGG <- function(clusterprofiler_df, DE_df, comparison){
  
  pathway_vec <- vector(mode="character", length=nrow(clusterprofiler_df))
  
  gene_vec <- vector(mode="character", length=nrow(clusterprofiler_df))
  
  median_vec <- vector(mode="numeric", length=nrow(clusterprofiler_df))
  
  label_vec <- vector(mode="character", length=nrow(clusterprofiler_df))
  
  clusterprofiler_df$geneID <- gsub(pattern="/", replacement="|",clusterprofiler_df$geneID)
  
  for (i in 1:nrow(clusterprofiler_df)){
    
    pathway_vec[i] <- clusterprofiler_df[i,"ID"]

    gene_vec[i] <- clusterprofiler_df[i,"geneID"]
    
    DE_res_subset <- DE_df %>% dplyr::filter(padj < 0.05) %>% dplyr::filter(str_detect(.$gene,pattern=gene_vec[i]))
    
    median_l2fc <- median(DE_res_subset$log2FoldChange)
    
    median_vec[i] <- median_l2fc
    
    if (median_l2fc >0){
    
    label_vec[i] <- "median_upregulated"
      
    } else if (median_l2fc < 0){
    
    label_vec[i] <- "median_downregulated"
    } else if (median_l2fc ==0){
    
    label_vec[i] <- "error"
      
    }
    
  }
  
  output <- data.frame(KEGG_Pathway=pathway_vec,
                       genes=gene_vec,
                       median_l2fc=median_vec,
                       median_trend=label_vec,
                       comparision=comparison)
  
  return(output)
}


#Box plots of l2fc for an enriched pathway:
#Gene_list is a vector of genes like "DNF11_0321|DNF11_0971|DNF11_0973|DNF11_0970|DNF11_2685|DNF11_3115|DNF11_0972|DNF11_2433"
#label_df is the output of the label_enriched_KEGG function
DE_pathway_input_for_plot <- function(DE_df, label_df, gene_selection){
  
  DE_df_subset <- DE_df %>% dplyr::filter(str_detect(.$gene,pattern=gene_selection)) 
  
  label <- label_df %>% dplyr::filter(genes==gene_selection) %>% pull(KEGG_Pathway) %>% unique(.)
  
  num_genes <- nrow(DE_df_subset)
  
  #Accounts for Pathways that share all the genes from the input gene list.
  #Ideally length of this KEGG_Pathway vector should be 1, but exceptions exist
  DE_df_subset <- sapply(DE_df_subset,rep.int,times=length(label)) %>% as.data.frame()
  
  DE_df_subset$KEGG_Pathway <- rep(label, each=num_genes)
  
  output <- DE_df_subset %>% dplyr::select(c("log2FoldChange","padj","gene","KEGG_Pathway"))
  
  
  output <- merge(output, KEGG_term2name %>% dplyr::rename(KEGG_Pathway="from",
                                                      Pathway_desc="to"),
                  by="KEGG_Pathway")
  
  output$log2FoldChange <- as.numeric(output$log2FoldChange)
  
  return(output)
  
}

#####Wrappers for QC or analyzing different BACTERIAL (not fungi) species and running site specific DE on them.

#The updated wrapper function now simply accepts a pre-processed input list of pangene counts
#Make sure the list of counts are species specific
#The input list comprises of dfs with three columns: LIBID, propan_clusterID, unpaired_read_count_sum
#The input list is a named list, with each Library ID being a name

QC_bacteria_RNA_sites <- function(list_of_counts,
                                  species,
                                       site, ref_site,
                                       count_threshold,
                                  specify_vst_nsub = FALSE,
                                       shared_individuals_bet_sites=TRUE){
  
  site_libs <- mtx_stats_chosen %>% dplyr::filter(region %in% c(site,ref_site)) %>% pull(LIBID)
  
  species_site_metadata <- lapply(rna_k2_minimizer[site_libs], function(df){
  
    metadata_out <- df %>% dplyr::filter(k2_taxon == species) %>% dplyr::rename(LIBID=mtx_LIBID)
  
    metadata_out <- merge(metadata_out, mtx_stats_chosen %>% 
                            dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
    return(metadata_out)
    }) %>% do.call("rbind",.)
  
  species_site_mtx_counts <- list_of_counts[site_libs]

  control_for_individuals_boolean <- shared_individuals_bet_sites
  
  DE_PCA_input <- run_DESeq_with_input_list(input_list = species_site_mtx_counts,
                                                           lib_vec=species_site_metadata %>% 
                                              dplyr::filter(paired_counts >= count_threshold) %>%  pull(LIBID),
                                            cond=site,
                                            ref_cond=ref_site,
                                            control_for_individuals = control_for_individuals_boolean,
                                            manual_vst_nsub = specify_vst_nsub,
                                            run_test = FALSE)
    
  PCA_plot <- plotPCA(DE_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))
    
  output <- tibble::lst(species, 
                        site, 
                        ref_site,
                        count_threshold,
                        species_site_metadata,
                        species_site_mtx_counts,
                        PCA_plot)  
  
  return(output)
  
  
}

#The updated wrapper function now simply accepts a pre-processed input list of pangene counts
#Make sure the list of counts are species specific
#The input list comprises of dfs with three columns: LIBID, propan_clusterID, unpaired_read_count_sum
#The input list is a named list, with each Library ID being a name
#This function performs DESeq2 analysis and overrepresentation analysis (ORA) using clusterprofiler
compare_bacteria_RNA_sites <- function(list_of_counts, species_anno, species_pangene_names, 
                                       species, site, ref_site,
                                       count_threshold,
                                       specify_vst_nsub = FALSE,
                                       shared_individuals_bet_sites=TRUE){
  
  
  site_libs <- mtx_stats_chosen %>% dplyr::filter(region %in% c(site,ref_site)) %>% pull(LIBID)
  
  species_site_metadata <- lapply(rna_k2_minimizer[site_libs], function(df){
  
  metadata_out <- df %>% dplyr::filter(k2_taxon == species) %>% dplyr::rename(LIBID=mtx_LIBID)
  
  metadata_out <- merge(metadata_out, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
  return(metadata_out)
  }) %>% do.call("rbind",.)
  
  
  species_site_mtx_counts <- list_of_counts[site_libs]

  
  control_for_individuals_boolean <- shared_individuals_bet_sites
  
    
  species_site_filt_DESeq <-  run_DESeq_with_input_list(input_list = species_site_mtx_counts,
                                                           lib_vec=species_site_metadata %>% 
                                                          dplyr::filter(paired_counts >= count_threshold) %>%
                                                       pull(LIBID),
                                                           cond=site,
                                                           ref_cond=ref_site,
                                                       control_for_individuals = control_for_individuals_boolean,
                                                       manual_vst_nsub = specify_vst_nsub,
                                                           run_test = TRUE)
    
  species_site_DE_res <- species_site_filt_DESeq[["DE_results_shrunken_df"]] %>% dplyr::rename(feature=propan_clusterID)

  ### Run KEGG enrichment analysis 
  
  species_term2gene <- make_custom_term2gene_df(input_annot=species_anno,
                                                pangene_names = species_pangene_names)

  species_site_DE_KEGG_upreg <- run_clusterprofiler(changing_df = species_site_DE_res %>% dplyr::filter(padj < 0.05 & log2FoldChange > log(1.5)/log(2)),
                                              background_df=species_site_DE_res,
                                                 term2gene = species_term2gene)
  
  species_site_DE_KEGG_downreg <- run_clusterprofiler(changing_df = species_site_DE_res %>% dplyr::filter(padj < 0.05 & log2FoldChange < -(log(1.5)/log(2))),
                                              background_df=species_site_DE_res,
                                                 term2gene = species_term2gene)

  species_site_DE_KEGG_upreg_df <- as.data.frame(species_site_DE_KEGG_upreg)
  
  species_site_DE_KEGG_downreg_df <- as.data.frame(species_site_DE_KEGG_downreg) 
  

  
  output <- tibble::lst(species, 
                        site, 
                        ref_site,
                        count_threshold,
                        species_site_metadata,
                        species_site_mtx_counts,
                        control_for_individuals_boolean,
                        species_site_filt_DESeq,
                        species_site_DE_res,
                        species_term2gene,
                        species_site_DE_KEGG_upreg,
                        species_site_DE_KEGG_upreg_df,
                        species_site_DE_KEGG_downreg,
                        species_site_DE_KEGG_downreg_df
                        ) 
   
  return(output)
  
} 

###################################################
#The following function is for running DESeq from a input list object loaded from pileup.sh's outputs
#This function is used to run DEseq2 models for a continuous response variable - CSS normalized values for a chosen species
run_DESeq_with_input_list_and_mgx <- function(input_list, 
                                   input_metadata=mtx_stats_chosen,
                                  lib_vec,
                                   run_test=TRUE,
                                  size_factor_function = "poscounts"
                                  ){
  
  ##############################################
  ## prepare input read count matrix for DESeq2#
  ##############################################
  
  #Obtain count data for eligible mtx and mgx
  rawcounts <- input_list[lib_vec] %>% do.call("rbind",.)
  
  count_matrix <- pivot_wider(rawcounts %>% 
                        dplyr::select(pangene, unpaired_read_count, LIBID), names_from = LIBID, 
                        values_from = unpaired_read_count) %>%
                        as.data.frame()
  
  rownames(count_matrix) <- count_matrix$pangene
  
  count_matrix <- count_matrix %>% dplyr::select(-pangene) %>% as.matrix()
  
  #This matrix operation is much faster than mutate_all(~replace(.,is.na(.),0)) for tibbles/df
  count_matrix[is.na(count_matrix)] <- 0 
  
  ##############################################
  ## prepare metadata for DESeq2               #
  ##############################################
  
  #Note that "responding_species" is a continuous variable (e.g. CSS normalized log2 values for a species (mgx))
  #The interpretation of the LFC is the log of the fold change in expression for one unit of the variable
  selected_metadata <- input_metadata %>% dplyr::filter(LIBID %in% lib_vec) %>% 
    dplyr::select(LIBID, subj_region, responding_species) %>% as.data.frame()
  
  rownames(selected_metadata) <- selected_metadata$LIBID
  
  selected_metadata <- selected_metadata %>% dplyr::select(-LIBID)
 
  
  #reorder rows of the metadata
  idx <- match(colnames(count_matrix), rownames(selected_metadata))
  selected_metadata <- selected_metadata[idx,]
  
 
  ##############################################
  ## Run DESeq2                                #
  ##############################################
  
  dds <- DESeqDataSetFromMatrix(countData = count_matrix, 
                                colData = selected_metadata, 
                                design = ~ responding_species)
  

  #Pre-filtering to keep rows with a minimum median read count for transcripts.

  mat <- counts(dds)
  
  keep <- (rowMedians(mat) >= 10)
  dds <- dds[keep,]

  #####Estimate size factors
  dds <- estimateSizeFactors(dds,  type = size_factor_function)
 
  normalized_counts <- counts(dds, normalized=TRUE)
  
  #
  
  vsd <- vst(dds, blind=FALSE)  
  
  vsd_mat <- assay(vsd)
  
  vsd_cor <- cor(vsd_mat)

  
  if (run_test==FALSE){
  outputs <- tibble::lst(count_matrix, keep, selected_metadata,
                         dds,
                         normalized_counts,
                         vsd, vsd_mat, vsd_cor)
  }else if (run_test==TRUE){
    dds <- DESeq(dds)
    
    ##Removing rows which do not converge in beta 
    dds <- dds[which(mcols(dds)$betaConv),]
    
    DE_results <- results(dds,
                          alpha=0.05)
    
    DE_results_shrunken <- lfcShrink(dds,
                                     type="ashr",
                                     res=DE_results)
    
    DE_results_shrunken_df <- data.frame(DE_results_shrunken)
    
    DE_results_shrunken_df$pangene <- rownames(DE_results_shrunken_df)
    
    outputs <- tibble::lst(lib_vec, count_matrix, keep,
                          selected_metadata,
                         dds,
                         normalized_counts,
                         vsd, vsd_mat, vsd_cor,
                         DE_results, DE_results_shrunken,
                         DE_results_shrunken_df)
    
  }
  
  return(outputs)
}

#responding_species refer to the normalized counts of said species
#mgx_abundance can also be aldex_clr_values_fmt[["Tw_bracken_clr"]]
compare_bacteria_RNA_to_mgx <- function(
                                       species, responding_species, 
                                       site,
                                       mgx_abundance=bracken_MO_CSS_df_with_id,
                                       count_threshold){
  
  
  site_libs <- mtx_stats_chosen %>% dplyr::filter(region %in% site) %>% pull(LIBID)
  
  species_site_metadata <- lapply(rna_k2_minimizer[site_libs], function(df){
  
	  metadata_out <- df %>% dplyr::filter(k2_taxon == species) %>% dplyr::rename(LIBID=mtx_LIBID)
  
	  metadata_out <- merge(metadata_out, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region",
	                                                                           "subject","low_conc")),
					by="LIBID")
					
	  #Add species normalized counts (e.g. CSS, aldex2 clr) as a continuous variable
	  old_names <- c(responding_species, "mtx_LIBID")
	  new_names <- c("responding_species", "LIBID")
	
	  species_norm_values <- mgx_abundance %>% 
					dplyr::select(all_of(old_names)) %>% dplyr::rename_with(~ new_names, all_of(old_names))
																					
	  metadata_out <- merge(metadata_out, species_norm_values, by = "LIBID")
					
	  return(metadata_out)
	  }) %>% do.call("rbind",.)
  ##
  species_site_mtx_counts <- lapply(site_libs, function(x){
	df <- read_tsv(file=paste0("../processed/mtx_species_mapping/bt2_out/RNA/",x,"_bt2_microbe_pangenome_aligned_filtered_cov.tsv"),
                 show_col_types = FALSE)
	df$LIBID <- x
  
	#select species specific gene features
  
	df_filt <- df %>% dplyr::filter(str_detect(df$pangene, pattern = species))
  
	return(df_filt)
	})

  names(species_site_mtx_counts) <- site_libs
  
  #return(tibble::lst(species_site_mtx_counts, species_site_metadata))
    
  species_site_filt_DESeq <-  run_DESeq_with_input_list_and_mgx(input_list = species_site_mtx_counts,
                                                               input_metadata= species_site_metadata,
                                                           lib_vec=species_site_metadata %>% 
                                                          dplyr::filter(paired_counts >= count_threshold) %>%
                                                          pull(LIBID),
                                                           run_test = TRUE)
    
  species_site_DE_res <- species_site_filt_DESeq[["DE_results_shrunken_df"]] %>% dplyr::rename(gene=pangene)

  
  output <- tibble::lst(species, 
                        responding_species,
                        site,
                        count_threshold,
                        species_site_metadata,
                        species_site_mtx_counts,
                        species_site_filt_DESeq,
                        species_site_DE_res,
                        ) 
   
  return(output)
  
} 

###########################################

#This function selects for mtx libraries corresponding to sites of choice.
#Assumes input is already a count matrix from Salmon quant
#This function is used to run DEseq2 models for a continuous response variable - CSS normalized values for a chosen species
#Species can be "Malassezia_restricta", "Malassezia_globosa" etc
run_DESeq_with_salmon_matrix_and_MGX <- function(input_matrix, 
                                        input_metadata=mtx_stats_chosen,
                                        mgx_abundance=bracken_MO_CSS_df_with_id,
                                        lib_vec,
                                        run_test=TRUE,
                                  size_factor_function = "poscounts",
                                  species="Malassezia_restricta",
								  responding_species){
  
  libs_to_pull <- input_metadata %>% dplyr::filter(LIBID %in% lib_vec) %>% pull(LIBID)
  
  if (species== "Malassezia_restricta"){
    
    loci<-"DNF"
    
  } else if (species=="Malassezia_globosa"){
    
    loci<-"MGL"
    
  } else if (species=="Malassezia_sympodialis"){
    
    loci<-"MSYG"
    
  } else if (species=="Malassezia_furfur"){
    
    loci <-"CBS"
    
  } else if (species=="Malassezia_arunalokei"){
    
    loci <-"MARU"
  }
  
  
  ##############################################
  ## prepare input read count matrix for DESeq2#
  ##############################################
  
  #Subset read count matrix with the selected libraries AND species.
  
  chosen_matrix <- input_matrix[grep(loci, row.names(input_matrix)),libs_to_pull]
  
  #Convert to matrix of integers
  
  chosen_matrix <- round(chosen_matrix)
  mode(chosen_matrix) <- "integer"
  
  ##############################################
  ## prepare metadata for DESeq2               #
  ##############################################
  

  selected_metadata <- input_metadata %>% dplyr::filter(LIBID %in% lib_vec) %>% 
    dplyr::select(LIBID, region) %>% as.data.frame()
  
  selected_metadata$region <- as.factor(selected_metadata$region)
  
  #Add  normalized counts (CSS, aldex2 clr etc) as a continuous variable
  old_names <- c(responding_species, "mtx_LIBID")
  new_names <- c("responding_species", "LIBID")
	
  species_norm_values <- mgx_abundance %>% 
				dplyr::select(all_of(old_names)) %>% 
				dplyr::rename_with(~ new_names, all_of(old_names))
  
  selected_metadata <- merge(selected_metadata, species_norm_values, by = "LIBID")
  
  rownames(selected_metadata) <- selected_metadata$LIBID
  
  #the row names of metadata should automatically be ordered in a way that matches the input matrix
  #reorder rows of the metadata
  idx <- match(colnames(chosen_matrix), rownames(selected_metadata))
  selected_metadata <- selected_metadata[idx,]
  
  
  #a vector of LIBIDs
  RNA_libs <- selected_metadata %>% row.names()
  
  ##############################################
  ## Run DESeq2                                #
  ##############################################
  #https://www.biostars.org/p/412320/ DESeqDataSetFromTximport rounds salmon matrix to integers, unlike DESeqDataSetFromMatrix
  #Here I am using the salmon read matrix straight off, so I have manually done the rounding
  
     
  dds <- DESeqDataSetFromMatrix(countData = chosen_matrix, 
                                colData = selected_metadata, 
                                design = ~ responding_species)

  #Pre-filtering to keep rows with a minimum median read count <= 10 for genes

  mat <- counts(dds)
  
  keep <- (rowMedians(mat) >= 10)
  dds <- dds[keep,]
  
  #####Estimate size factors
  dds <- estimateSizeFactors(dds,  type = size_factor_function)
  
  normalized_counts <- counts(dds, normalized=TRUE)
  
  #See error and fix:https://support.bioconductor.org/p/98634/
  #See DESeq2 vignette about blind dispersion estimation
  
  vsd <- vst(dds, blind=FALSE)  
  
  vsd_mat <- assay(vsd)
  
  vsd_cor <- cor(vsd_mat)
  
  
  if (run_test==FALSE){
  outputs <- tibble::lst(chosen_matrix, keep, selected_metadata,
                         dds,
                         normalized_counts,
                         vsd, vsd_mat, vsd_cor)
  } else if (run_test==TRUE){
    
  dds <- DESeq(dds)   #wald test
    
  DE_results <- results(dds, alpha=0.05)
    
  DE_results_shrunken <- lfcShrink(dds,
                                     type="ashr",
                                     res=DE_results)
    
  DE_results_shrunken_df <- data.frame(DE_results_shrunken)
    
  DE_results_shrunken_df$gene <- rownames(DE_results_shrunken_df)
  
  outputs <- tibble::lst(lib_vec, species, responding_species,
						chosen_matrix, keep, selected_metadata,
                         dds,
                         normalized_counts,
                         vsd, vsd_mat, vsd_cor,
                         DE_results, DE_results_shrunken,
                         DE_results_shrunken_df)
  }
  return(outputs)
}





###################################################


#Function to build facet plots inspired by ocean mtx paper figure 5

plot_pathway_facets <- function(input_df){
  
  ggplot(input_df, aes(x = log2FoldChange, y = annot , color = increased_in)) +
  geom_point() +
  geom_vline(xintercept=0) + 
  geom_segment(aes(yend=annot), xend=0) +
  scale_y_discrete(labels = label_wrap_gen(width=20)) +
  facet_grid(Pathway_desc~.,
             scales = "free", space = "free",
             labeller = label_wrap_gen(width = 1.5, multi_line = TRUE)) + 
  theme(panel.spacing = unit(.05, "lines"),
        panel.border = element_rect(color = "black", fill = NA, size = 0.2), 
       strip.background = element_rect(color = "black", size = 1)) 
  
}

plot_custom_gene_facets <- function(input_df){
  
  input_df <- input_df %>% dplyr::filter(padj < 0.05)
  
  ggplot(input_df, aes(x = log2FoldChange, y = annot  , color = increased_in)) +
  geom_point() +
  geom_vline(xintercept=0) + 
  geom_segment(aes(yend=annot), xend=0) +
  scale_y_discrete(labels = label_wrap_gen(width=20)) +
  facet_grid(Description~.,
             scales = "free", space = "free",
             labeller = label_wrap_gen(width = 1.5, multi_line = TRUE)) + 
  theme(panel.spacing = unit(.05, "lines"),
        panel.border = element_rect(color = "black", fill = NA, size = 0.2), 
        strip.background = element_rect(color = "black", size = 1)) 
  
}

#Convenience function to add annotations from propan back to a dataframe containing propan cluster names

get_propan_annots <- function(input_df, annot_df){
  
  input_df$propan_clusterID <- str_match(string=input_df$pangene, pattern="cluster_[0-9]*")[,1]


  output <- merge(input_df, annot_df,  all.x=TRUE, by ="propan_clusterID")
  
  return(output)
  
}


GSEA_from_DESeq <- function(genelist, gene_names, term2gene, term2name = KEGG_term2name){

names(genelist) <- as.character(gene_names)
# omit any NA values 
genelist<-na.omit(genelist)
#sort the genelist in decreasing order.
genelist <- sort(genelist, decreasing = TRUE)

set.seed(123)
GSEA_out <- GSEA(geneList = genelist, TERM2GENE = term2gene, 
             TERM2NAME = term2name, eps= 0, nPermSimple=10000, seed=TRUE)

return(GSEA_out)

}

#https://www.biostars.org/p/467197/ for plotting pathway GSEA normalized enrichment scores in a bar plot

make_NES_barplot <- function(GSEA_df, title){
  
  GSEA_df$direction <- ifelse(GSEA_df$NES > 0, "upregulated", "downregulated")
  cols <- c("downregulated" = "darkblue", "upregulated" = "red")
  
  
  ggplot(GSEA_df, aes(reorder(Description, NES), NES, fill = direction)) +
  geom_col() +
  scale_fill_manual(values = cols) +
  theme(axis.text.x = element_text(vjust = 0.5, hjust=1)) +
  coord_flip() +
  labs(x="Pathway/Function", y="Normalized Enrichment Score") + ggtitle(title) + theme_classic()
  
}


#We want to find a set of GO slim metagenome terms that cover all/as much data as possible and represent them in the NES plot
#adapted from https://support.bioconductor.org/p/128407/
#go_ids is a vector of GO terms of interest
#Mode can be "MF" or "BP"
associate_GO_to_slim <- function(go_ids, 
                                 obo_path="../metadata/goslim_metagenomics.obo",
                                 mode="MF"){
  
  myCollection <- GOCollection(go_ids)
  
  # Retrieve GOslims from GO OBO file set
  slim <- getOBOCollection(obo_path)

    
  if (mode=="BP"){
    # Retrieve Biological Process (BP) GOslims
    slimdf <- goSlim(myCollection, slim, "BP", verbose)
    # List of GOslims and all GO IDs from `go_ids`
    gomap <- as.list(GOBPOFFSPRING[rownames(slimdf)])
    
  } else if (mode=="MF"){
    # Retrieve Biological Process (MF) GOslims
    slimdf <- goSlim(myCollection, slim, "MF", verbose)
    # List of GOslims and all GO IDs from `go_ids`
    gomap <- as.list(GOMFOFFSPRING[rownames(slimdf)])
  }
  
  
  # Maps `go_ids` to matching GOslims: lapply(gomap, intersect, ids(myCollection))
  
  # Append all mapped GO IDs to `slimdf`
  # `sapply` needed to apply paste() to create semi-colon delimited values
  slimdf$ids <- sapply(lapply(gomap, intersect, ids(myCollection)), paste, collapse=";")
  
  # Remove "character(0) string from "ids" column
  slimdf$ids[slimdf$ids == "character(0)"] <- ""
  
  slimdf[slimdf==""]<-NA
  
  slimdf$GO_slim_parent <- rownames(slimdf)
  
  slimdf$annotation_type <- mode
  
  # Add self-matching GOIDs to "ids" column, if not present
  #i.e the slimmed parent can be itself if it is a slimmed term also
  self_matching_parent_ids  <- intersect(go_ids,slimdf$GO_slim_parent)
  
  slimdf_nonself_subset <- slimdf %>% dplyr::filter(!GO_slim_parent %in% self_matching_parent_ids)
  slimdf_self_subset <- slimdf %>% dplyr::filter(GO_slim_parent %in% self_matching_parent_ids)
  
  
  
  slimdf_self_subset$ids <- ifelse(slimdf_self_subset$Count<=1, 
                                   slimdf_self_subset$GO_slim_parent,
                                   paste0(slimdf_self_subset$ids,";",slimdf_self_subset$GO_slim_parent))
  
  slimdf_self_subset$Count <- str_count(slimdf_self_subset$ids, "GO")


  slimdf_out <- rbind(slimdf_nonself_subset, slimdf_self_subset)
  slimdf_out <- slimdf_out %>% dplyr::rename(ID=ids) %>% dplyr::select(-Percent)
  
  return(slimdf_out)
  
}

#Function to color code NES bar plots by GO slim (parent categories)
#chosen_parent_ids can be a vector like c("transport","generation of precursor metabolites and energy"...)

prepare_NES_plot_input <- function(df, slimdf, chosen_parent_ids){
  
  slimdf_subset <- slimdf %>% tidyr::separate_rows(ID, sep = ";") %>% 
    dplyr::select(c("ID","Term")) %>% 
    dplyr::filter(Term %in% chosen_parent_ids) %>%
    dplyr::rename(GO_slim_parent_term=Term)
    
  
  df_out <- merge(df, slimdf_subset, by="ID", all.x=TRUE)
  df_out$GO_slim_parent_term <- as.factor(df_out$GO_slim_parent_term)
  
  return(df_out)
  
}




make_NES_barplot_with_slim <- function(GSEA_df, title, x_axis_lab="Function/Process"){
  
  GSEA_df$ID_and_Desc <- paste0(GSEA_df$ID," ",GSEA_df$Description)
  
  
  ggplot(GSEA_df, aes(reorder(ID_and_Desc, NES), NES, fill = GO_slim_parent_term)) +
  geom_col(colour="black",position="dodge") +
  scale_fill_manual(values = c23) +
  theme(axis.text.x = element_text(vjust = 0.5, hjust=1)) +
  coord_flip() +
  labs(x=x_axis_lab, y="Normalized Enrichment Score") + ggtitle(title) + theme_classic()
  
}

```

### Summarize unpaired read counts for each feature (Pangene or Uniref90 cluster) at species level


CAUTION: should condense subsp into the same species. 

CAUTION: Genus level and above counts here are not representative because it does not factor reads that are same genus but shared between species

CAUTION: Because of the above point, species level counts for each feature are necessarily an underestimate.

CAUTION: Do not include Homo sapiens and unclassified in this analysis or in the RPK formula

This should only take into account features with >= 50% read coverage

```{r eval=FALSE}

mtx_taxa_count_summary <- lapply(mtx_to_pull, function(x){
  
  library <- x
  
  taxa_count_df <- read_tsv(paste0("../data/MTX_tax_summary/",x,"_merged_all_aligned_taxonomy_summary.tsv"), 
                            show_col_types = FALSE,
                            col_names = c("unpaired_read_count", "pangene",
                                          "k2_taxon", "uniref90_ID")) %>% 
    dplyr::filter(! k2_taxon %in% c("unclassified","Homo sapiens"))
  
  #from bowtie2 nt alignment, to get pangene lengths
  pangene_df <- read_tsv(paste0("../data/MTX_annotations/",x,"_merged_panalign_annot.tsv"), show_col_types = FALSE) %>%
            dplyr::select(pangene, length)
 
  #From translated search (reads that did not align using bowtie2), to get uniref90 cluster AA lengths
  
  uniref90_df <- read_tsv(paste0("../data/MTX_annotations/",x,"_merged_transl-search_annot.tsv"), show_col_types = FALSE) %>%
            dplyr::select(uniref90_ID,AA_length)
  
  #If a read aligned to a pangene, calculate RPK with the length of the pangene feature in nt on a per taxon level
  taxa_pangene_count_df <- taxa_count_df %>% dplyr::filter(pangene!="-") %>% merge(., pangene_df, by ="pangene")
  
  #convert nt length to kilobase scale
  taxa_pangene_count_df$length <- (taxa_pangene_count_df$length)/1000
  taxa_pangene_count_df$annotated_RPK <- taxa_pangene_count_df$unpaired_read_count/taxa_pangene_count_df$length
  
  taxa_pangene_count_df <- taxa_pangene_count_df %>% dplyr::select(-length)
  
  #If a read aligned to a uniref90 entry via translated search, 
  #calculate RPK with the length of the uniref90 rep feature in nt (not AA) on a per taxon level
  
  taxa_uniref90_count_df <- taxa_count_df %>% dplyr::filter(pangene=="-") %>% merge(., uniref90_df, 
                                                                                    by ="uniref90_ID")
  
  ##converting AA length to equivalent length in nt, then convert length to kilobase scale
  taxa_uniref90_count_df$length <- (taxa_uniref90_count_df$AA_length * 3)/1000

  taxa_uniref90_count_df$annotated_RPK <- taxa_uniref90_count_df$unpaired_read_count/taxa_uniref90_count_df$length
  
  taxa_uniref90_count_df <- taxa_uniref90_count_df %>% dplyr::select(-c("length","AA_length"))
  
  #
  output <- rbind(taxa_pangene_count_df, taxa_uniref90_count_df)
  output$LIBID=library
    
  return(output)
  
})

#Repeat for MGX reads


mgx_taxa_count_summary <- lapply(mgx_to_pull, function(x){
  
  library <- x
  
  taxa_count_df <- read_tsv(paste0("../data/MGX_tax_summary/",x,"_merged_all_aligned_taxonomy_summary.tsv"), 
                            show_col_types = FALSE,
                            col_names = c("unpaired_read_count", "pangene",
                                          "k2_taxon", "uniref90_ID")) %>% 
    dplyr::filter(! k2_taxon %in% c("unclassified","Homo sapiens"))
  
  #from bowtie2 nt alignment
  pangene_df <- read_tsv(paste0("../data/MGX_annotations/",x,"_merged_panalign_annot.tsv"), show_col_types = FALSE) %>%
            dplyr::select(pangene, length)
 
  #From translated search (reads that did not align using bowtie2)
  
  uniref90_df <- read_tsv(paste0("../data/MGX_annotations/",x,"_merged_transl-search_annot.tsv"), show_col_types = FALSE) %>%
            dplyr::select(uniref90_ID,AA_length)
  
  #If a read aligned to a pangene, calculate RPK with the length of the pangene feature in nt on a per taxon level
  taxa_pangene_count_df <- taxa_count_df %>% dplyr::filter(pangene!="-") %>% merge(., pangene_df, by ="pangene")
  
  #convert nt length to kilobase scale
  taxa_pangene_count_df$length <- (taxa_pangene_count_df$length)/1000
  taxa_pangene_count_df$annotated_RPK <- taxa_pangene_count_df$unpaired_read_count/taxa_pangene_count_df$length
  
  taxa_pangene_count_df <- taxa_pangene_count_df %>% dplyr::select(-length)
  
  #If a read aligned to a uniref90 entry via translated search, 
  #calculate RPK with the length of the uniref90 rep feature in nt (not AA) on a per taxon level
  
  taxa_uniref90_count_df <- taxa_count_df %>% dplyr::filter(pangene=="-") %>% merge(., uniref90_df, 
                                                                                    by ="uniref90_ID")
  
  ##converting AA length to equivalent length in nt, then convert length to kilobase scale
  taxa_uniref90_count_df$length <- (taxa_uniref90_count_df$AA_length * 3)/1000

  taxa_uniref90_count_df$annotated_RPK <- taxa_uniref90_count_df$unpaired_read_count/taxa_uniref90_count_df$length
  
  taxa_uniref90_count_df <- taxa_uniref90_count_df %>% dplyr::select(-c("length","AA_length"))
  
  #
  output <- rbind(taxa_pangene_count_df, taxa_uniref90_count_df)
  output$LIBID=library
    
  return(output)
  
})

## Now sum up the counts and RPKs per organism.

mtx_taxa_count_summary_fmt <- lapply(mtx_taxa_count_summary, function(df){
  
  #per taxa summary
  df_summary <- df %>% dplyr::select(c("k2_taxon","unpaired_read_count","annotated_RPK","LIBID")) %>%
    group_by(k2_taxon, LIBID) %>% summarise(read_count_sum=sum(unpaired_read_count), RPK_sum = sum(annotated_RPK))

  return(df_summary)
  
})

names(mtx_taxa_count_summary_fmt) <- mtx_to_pull

mgx_taxa_count_summary_fmt <- lapply(mgx_taxa_count_summary, function(df){
  
  #per taxa summary
  df_summary <- df %>% dplyr::select(c("k2_taxon","unpaired_read_count","annotated_RPK","LIBID")) %>%
    group_by(k2_taxon, LIBID) %>% summarise(read_count_sum=sum(unpaired_read_count), RPK_sum = sum(annotated_RPK))

  return(df_summary)
  
})

names(mgx_taxa_count_summary_fmt) <- mgx_to_pull



#Now we need only include the features at species level, and aggregate sub-species reads at species level
#Then search for subsp and extract the two terms before it to get species e.g. 	Cutibacterium_acnes_subsp._acnes

#However in the formula, let the denominator be the RPK sum across species level reads only (excluding Human and unclassified) 

#We also need an estimate of #unpaired, unannotated (no pangene or uniref match) reads at species and subsp. level from kraken2 results.

#Thankfully, the k2.s.tsv already contains: awk -F "\t" -v OFS="\t" '($4=="S" || $4 =="U"){print $1,$2,$6}' "${sample_id}"_kraken2.tax | tr -s ' ' | sed 's/^ //g' > "${sample_id}"_k2.s.tsv, where column 2 is the Number of fragments covered by the clade rooted at this taxon = sum of all lower ranks under the species.

mtx_taxa_count_summary_subsp_collapse <- lapply(names(mtx_taxa_count_summary_fmt), function(x){
  taxa_df <- mtx_taxa_count_summary_fmt[[x]]
  #In this temporary column, obtain species level classifications of "subsp" labels or any label with more than one "_" 
  #to catch annotations like Streptococcus_oralis_Uo5
  #Do not include species level classifications like "Actinomyces_sp._oral_taxon_414" as subsp

  taxa_df$subsp_temp <- ifelse(str_detect(taxa_df$k2_taxon, pattern="_sp._", negate=TRUE) & (str_detect(taxa_df$k2_taxon, pattern="_subsp._")|
                                  str_count(taxa_df$k2_taxon,"_")>1), taxa_df$k2_taxon, NA)
  
  taxa_df$k2_taxon <- ifelse(!is.na(taxa_df$subsp_temp), word(taxa_df$subsp_temp,1,2,sep="_"), taxa_df$k2_taxon)
  
  taxa_df <- taxa_df %>% dplyr::rename(tmp_count=read_count_sum, tmp_RPK=RPK_sum)
  

  #Subsp count and RPK information condensed into species features
  #Features higher than species level will not have a "_" in the k2_taxon and should be excluded 
  
  #side note: filter does not work on grouped_df classes. The ungroup() function is necessary should you wish to do this
  taxa_df_summary <- taxa_df  %>%
    dplyr::select(-subsp_temp) %>% group_by(k2_taxon, LIBID) %>% 
    summarise(read_count_sum=sum(tmp_count), RPK_sum = sum(tmp_RPK))
  
  #Integrate library specific kraken2 taxa count information to calculate species level reads mapped to unknown functions
  #These numbers will differ from the "unannotated" output table from the pipeline because they account for reads mapped to features but with < 50% coverage across the feature
  
  k2_df <- read_tsv(paste0("../data/kraken2/RNA/",x,"_merged_k2.s.tsv"),
                    col_names = c("rel_abun","paired_counts","k2_taxon"), show_col_types = FALSE) %>% 
    dplyr::select(-c("rel_abun")) %>% 
    dplyr::filter(! k2_taxon %in% c("unclassified","Homo sapiens"))
  #Convert to unpaired read count numbers for compatibility with the pangene and diamond alignment results
  k2_df$k2_unpaired <- k2_df$paired_counts *2
  
  k2_df <- k2_df %>% dplyr::select(-paired_counts)
  
  k2_df$k2_taxon <- gsub(pattern=" ",replacement="_", k2_df$k2_taxon)
  
  taxa_df_summary <- merge(taxa_df_summary, k2_df, by = "k2_taxon", all.y=TRUE)
  
  taxa_df_summary$LIBID <- x
  
  taxa_df_summary[is.na(taxa_df_summary)] <- 0
  
  #Condense read and RPK information for known and unknown functions, at species level
  taxa_df_summary$unknown_fun_counts <- taxa_df_summary$k2_unpaired - taxa_df_summary$read_count_sum
  
  #Assume unknown gene(s) of length 1 kilobase recruiting all reads that failed to map to known sequences.
  #https://github.com/biobakery/humann 
  
  taxa_df_summary$unknown_fun_RPK <- taxa_df_summary$unknown_fun_counts  #assume 1 Kb, so denominator is 1

  #stack the halves of the dfs
  known_frac_df <- taxa_df_summary %>% dplyr::select(k2_taxon,LIBID,read_count_sum,RPK_sum) %>%
    dplyr::rename(read_counts=read_count_sum,RPK=RPK_sum)
  unknown_frac_df <- taxa_df_summary %>% 
    dplyr::select(k2_taxon,LIBID,unknown_fun_counts,unknown_fun_RPK) %>%
    dplyr::rename(read_counts=unknown_fun_counts,RPK=unknown_fun_RPK)
  
  combined_df <- rbind(known_frac_df, unknown_frac_df)
  
  output <- combined_df %>% group_by(k2_taxon, LIBID) %>% 
    summarise(read_count_sum=sum(read_counts), RPK_sum = sum(RPK))
  
  return(output)
})

names(mtx_taxa_count_summary_subsp_collapse) <- names(mtx_taxa_count_summary_fmt)

mgx_taxa_count_summary_subsp_collapse <- lapply(names(mgx_taxa_count_summary_fmt), function(x){
  taxa_df <- mgx_taxa_count_summary_fmt[[x]]
  #In this temporary column, obtain species level classifications of "subsp" labels or any label with more than one "_" 
  #to catch annotations like Streptococcus_oralis_Uo5
  #Must exclude species level classifications like "Actinomyces_sp._oral_taxon_414"

  taxa_df$subsp_temp <- ifelse(str_detect(taxa_df$k2_taxon, pattern="_sp._", negate=TRUE) & (str_detect(taxa_df$k2_taxon, pattern="_subsp._")|
                                  str_count(taxa_df$k2_taxon,"_")>1), taxa_df$k2_taxon, NA)
  
  taxa_df$k2_taxon <- ifelse(!is.na(taxa_df$subsp_temp), word(taxa_df$subsp_temp,1,2,sep="_"), taxa_df$k2_taxon)
  
  taxa_df <- taxa_df %>% dplyr::rename(tmp_count=read_count_sum, tmp_RPK=RPK_sum)
  

  #Subsp count and RPK information condensed into species features
  #Features higher than species level will not have a "_" in the k2_taxon and should be excluded (apart from "unclassified")
  
  #side note: filter does not work on grouped_df classes. The ungroup() function is necessary should you wish to do this
  taxa_df_summary <- taxa_df  %>%
    dplyr::select(-subsp_temp) %>% group_by(k2_taxon, LIBID) %>% 
    summarise(read_count_sum=sum(tmp_count), RPK_sum = sum(tmp_RPK))
  
  #Integrate library specific kraken2 taxa count information to calculate species level reads mapped to unknown functions
  #These numbers will differ from the "unannotated" output table from the pipeline because they account for reads mapped to features but with < 50% coverage across the feature
  
  k2_df <- read_tsv(paste0("../data/kraken2/DNA/",x,"_merged_k2.s.tsv"),
                    col_names = c("rel_abun","paired_counts","k2_taxon"), show_col_types = FALSE) %>% 
    dplyr::select(-c("rel_abun")) %>% 
    dplyr::filter(! k2_taxon %in% c("unclassified","Homo sapiens"))
  #Convert to unpaired read count numbers for compatibility with the pangene and diamond alignment results
  k2_df$k2_unpaired <- k2_df$paired_counts *2
  
  k2_df <- k2_df %>% dplyr::select(-paired_counts)
  
  k2_df$k2_taxon <- gsub(pattern=" ",replacement="_", k2_df$k2_taxon)
  
  taxa_df_summary <- merge(taxa_df_summary, k2_df, by = "k2_taxon", all.y=TRUE)
  
  taxa_df_summary$LIBID <- x
  
  taxa_df_summary[is.na(taxa_df_summary)] <- 0
  
  #Condense read and RPK information for known and unknown functions, at species level
  taxa_df_summary$unknown_fun_counts <- taxa_df_summary$k2_unpaired - taxa_df_summary$read_count_sum
  
  #Assume unknown gene(s) of length 1 kilobase recruiting all reads that failed to map to known sequences.
  #https://github.com/biobakery/humann 
  
  taxa_df_summary$unknown_fun_RPK <- taxa_df_summary$unknown_fun_counts  #assume 1 Kb, so denominator is 1

  #stack the halves of the dfs
  known_frac_df <- taxa_df_summary %>% dplyr::select(k2_taxon,LIBID,read_count_sum,RPK_sum) %>%
    dplyr::rename(read_counts=read_count_sum,RPK=RPK_sum)
  unknown_frac_df <- taxa_df_summary %>% 
    dplyr::select(k2_taxon,LIBID,unknown_fun_counts,unknown_fun_RPK) %>%
    dplyr::rename(read_counts=unknown_fun_counts,RPK=unknown_fun_RPK)
  
  combined_df <- rbind(known_frac_df, unknown_frac_df)
  
  output <- combined_df %>% group_by(k2_taxon, LIBID) %>% 
    summarise(read_count_sum=sum(read_counts), RPK_sum = sum(RPK))
  
  
  return(output)
})

names(mgx_taxa_count_summary_subsp_collapse) <- names(mgx_taxa_count_summary_fmt)


#Load as RData objects to avoid running this code chunk each time

saveRDS(mtx_taxa_count_summary_fmt, file="../processed/mtx_taxa_count_summary_fmt.RDS")
saveRDS(mgx_taxa_count_summary_fmt, file="../processed/mgx_taxa_count_summary_fmt.RDS")

saveRDS(mtx_taxa_count_summary_subsp_collapse, file="../processed/mtx_taxa_count_summary_subsp_collapse.RDS")
saveRDS(mgx_taxa_count_summary_subsp_collapse, file="../processed/mgx_taxa_count_summary_subsp_collapse.RDS")

```

Load the results of the previous code chunk

```{r}

mtx_taxa_count_summary_subsp_collapse <- readRDS(file="../processed/mtx_taxa_count_summary_subsp_collapse.RDS")

mgx_taxa_count_summary_subsp_collapse <- readRDS(file="../processed/mgx_taxa_count_summary_subsp_collapse.RDS")

```

## Calculate transcription ratio at taxa level.

I am well aware that taxa transcription ratios can be affected by differences in lysis efficiency for DNA and RNA extraction. This is why the high correlation between the two extraction methods in mock_comm_DNA_DNA_analysis.Rmd is helpful

One strategy would involve a Kruskal Wallis test of log transcription ratios (5 sites), across the 'core' and 'prevalent' taxa, followed by p -value adjustment, then post hoc tests for a few examples.


For simplicity, filter away very weakly abundant signals within libraries (< 0.1% relative abundance). This is now preferred because transcription ratios could be skewed if the denominator is very small.


Microbial reads in mtx_mgx_stats_chosen are the sum of microbial reads (bacterial, fungal, viral and archaeal) at species level and above. This also includes contributions from spike ins and contaminants

However, we want to do taxa level TPM calculations, it should be over SPECIES level reads that are not contaminants nor spike ins.

We also distinguish this from DOMINANT TAXA analysis because we do not filter away rare taxa by relative abundance here.

There will be features that are absent at RNA level but present at DNA level. These are considered transcriptionally inactive.

There will also be some features that are PRESENT at RNA level but ABSENT at DNA level. We need more consideration for how to call them transcriptionaly active features. For those that pass this criteria, create another column of "inferred" vs "measured" transcriptional_activity


Since we do not filter away rare taxa by relative abundance here, we need another way of separating false positives:
For taxon DNA (NOT RNA) measurements, use minimizer information from kraken2 to distinguish true from false positives.
The criteria are inspired from the krakenuniq paper https://genomebiology.biomedcentral.com/articles/10.1186/s13059-018-1568-0:
a) at least 2000 unique k-mers per 1 million non-human reads OR
b) If a) is not satisfied, then minimum paired read count of 10 and at least 10x more distinct minimizers than read pairs.

N.B: unclassified k2 reads are given a pass by default, but we will NOT use kraken2 unclassified reads in transcription ratio calculations


From cell reports methods (We don't use this anymore)
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8594859/
taxonomy classification reports produced by KrakenUniq were parsed to retain entries at genus level. These entries were filtered to retain only the ones that have at least 100 reads and a Kmers to reads ratio of at least 7 or a minimum of 1000 Kmers. 


See k2_minimizer_analysis.Rmd, where we demonstrate that >= 10^4 distinct minimizers per million species level reads is a good cut off for rRNA DEPLETED mtx libraries
So for MTX, use the criteria:  >= 10^4 distinct minimizers per million at species level, and >= 0.1% relative abundance.

Species level reads are non-contaminant, non-spike in, microbial reads!


For MGX, use the following criteria:  (>= 2000 distinct minimizers per million, and >= 0.1% relative abundance) 
OR true positive detected in paired MTX data.

These criteria are more conservative than the previous attempt at this analysis, which permitted >= 10 reads as long as minimizers >= 10* read pairs. That allowed too many false positives.

################
After filtering false positive reads, do a re-normalization

```{r eval=FALSE}
#Load in kraken2 species level minimizer information for DNA and RNA
#Do not count "unclassified" reads since they are not species level.
#Non-fungal, non human eukaryotic reads are not counted at species level since the kraken2 database used does not represent them
#

##Start with RNA k2 minimizers.

rna_k2_minimizer <- lapply(mtx_to_pull, function(x) {
  
  df <- read_tsv(paste0("../data/kraken2/minimizer_df/RNA/",x,"_merged_decont_k2.s.tsv"),
                    col_names = c("rel_abun","paired_counts","minimizer_count","distinct_minimizer_count","k2_taxon"), show_col_types = FALSE) %>% 
    dplyr::select(-c("rel_abun","minimizer_count")) %>% 
    dplyr::filter(!k2_taxon %in% c("unclassified","Homo sapiens"))
  
  df$k2_taxon <- gsub(pattern=" ", replacement="_", df$k2_taxon)
  
  #label the non-contaminant, non spike in, non human reads at species level
  
  #label source as "non-contaminant", "contaminant", "spike". Note that "Listeria, Plesiomonas and Vibrio" are the spikes
  df_bio  <- df %>% dplyr::filter(str_detect(df$k2_taxon, genera_mask, negate=TRUE)) %>% 
    dplyr::filter(! k2_taxon %in% species_to_remove)
  
  df_bio$source <- "non_contaminant"
  
  df_contam <- df %>% 
    dplyr::filter(str_detect(df$k2_taxon, genera_mask) | k2_taxon %in% species_to_remove)
  
  df_contam$source <- ifelse(str_detect(df_contam$k2_taxon, "^Listeria|^Plesiomonas|^Vibrio"), "spike", "contaminant")
  
  #Set relative abundance of contaminants and spike ins to zero
  df_contam$rel_abun <- 0
  
  #Compute relative abundance at species level for for non-contaminants and non-spikes
  #expressed as percentage abundance
  df_bio$rel_abun <- (df_bio$paired_counts / sum(df_bio$paired_counts))*100

  df_labelled <- rbind(df_bio, df_contam)
  
  #rel abundance >= 0.1% for a non contaminant, non spike in.
  df_labelled$abun_filter <- ifelse(df_labelled$rel_abun >= 0.1, TRUE, FALSE)  
 
  #library specific minimizer threshold    
  #Count the number of non-contaminant, non_spike in microbial read pairs at SPECIES LEVEL
  microbial_reads <- sum(df_bio$paired_counts) 
  microbial_reads_per_million <- microbial_reads/1E6
  
  minimizer_threshold <- 10000*microbial_reads_per_million
  
  df_labelled$species_microbial_read_pair_total <- microbial_reads  
  df_labelled$minimizer_threshold <- minimizer_threshold
  
  #distinct minimizer to PER MILLION microbial read pair (non contaminant, non spike in, microbe reads at species level) ratio
  df_labelled$minimizer_microbe_ratio <- df_labelled$distinct_minimizer_count / microbial_reads_per_million
  
  #for clarity purposes, set contaminant and spike in values to 0
  df_labelled$minimizer_microbe_ratio <- ifelse(df_labelled$source == "non_contaminant",
                                                df_labelled$minimizer_microbe_ratio, 0)
  
  
  df_labelled$minimizer_filter <- ifelse(df_labelled$distinct_minimizer_count >= minimizer_threshold,TRUE, FALSE)
  
  #taxa_pass_filter based on the two criteria stated:
  
  #a) at least 10000 unique k-mers per 1 million microbial reads AND
  #b) at least >= 0.1% relative abundance amongst non contaminant, non spike in, microbe reads at species level
  
  df_labelled$taxa_pass_filter <- ifelse(df_labelled$minimizer_filter ==TRUE &
                                           df_labelled$abun_filter ==TRUE, TRUE,FALSE)
  df_labelled$mtx_LIBID <- x
  
  return(df_labelled)
  
})


names(rna_k2_minimizer) <- mtx_to_pull

#Write the results

lapply(names(rna_k2_minimizer), function(x){
  
  write_tsv(rna_k2_minimizer[[x]], 
            file=paste0("../processed/k2_species_renorm/RNA/unfiltered/",x,"_k2_minimizer.s.tsv"))
  
})


##Next, extend the logic to DNA k2 minimizers, with the added use of RNA true positives to "validate" DNA true positives


k2_minimizer <- lapply(mgx_to_pull, function(x) {
  
  df <- read_tsv(paste0("../data/kraken2/minimizer_df/DNA/",x,"_merged_decont_k2.s.tsv"),
                    col_names = c("rel_abun","paired_counts","minimizer_count","distinct_minimizer_count","k2_taxon"), show_col_types = FALSE) %>% 
    dplyr::select(-c("rel_abun","minimizer_count")) %>% 
    dplyr::filter(!k2_taxon %in% c("unclassified","Homo sapiens"))
  
  df$k2_taxon <- gsub(pattern=" ", replacement="_", df$k2_taxon)
  
  #label the non-contaminant, non spike in, non human reads at species level
  
  #label source as "non-contaminant", "contaminant", "spike". Note that "Listeria, Plesiomonas and Vibrio" are the spikes
  df_bio  <- df %>% dplyr::filter(str_detect(df$k2_taxon, genera_mask, negate=TRUE)) %>% 
    dplyr::filter(! k2_taxon %in% species_to_remove)
  
  df_bio$source <- "non_contaminant"
  
  df_contam <- df %>% 
    dplyr::filter(str_detect(df$k2_taxon, genera_mask) | k2_taxon %in% species_to_remove)
  
  df_contam$source <- ifelse(str_detect(df_contam$k2_taxon, "^Listeria|^Plesiomonas|^Vibrio"), "spike", "contaminant")
  
  
    
  #Set relative abundance of contaminants and spike ins to zero
  df_contam$rel_abun <- 0
  
  #Compute relative abundance at species level for for non-contaminants and non-spikes
  #expressed as percentage abundance
  df_bio$rel_abun <- (df_bio$paired_counts / sum(df_bio$paired_counts))*100
  
  df_labelled <- rbind(df_bio, df_contam)
  
  #rel abundance >= 0.1% for a non contaminant, non spike in.
  df_labelled$abun_filter <- ifelse(df_labelled$rel_abun >= 0.1, TRUE, FALSE)
  
  #library specific minimizer threshold    
  #Count the number of non-contaminant, non_spike in microbial read pairs at SPECIES LEVEL
  microbial_reads <- sum(df_bio$paired_counts) 
  microbial_reads_per_million <- microbial_reads/1E6
  
  minimizer_threshold <- 2000*microbial_reads_per_million
  
  df_labelled$species_microbial_read_pair_total <- microbial_reads  
  df_labelled$minimizer_threshold <- minimizer_threshold
  
  #distinct minimizer to PER MILLION microbial read pair (non contaminant, non spike in, microbe reads at species level) ratio
  df_labelled$minimizer_microbe_ratio <- df_labelled$distinct_minimizer_count / microbial_reads_per_million
  
  #for clarity purposes, set contaminant and spike in values to 0
  df_labelled$minimizer_microbe_ratio <- ifelse(df_labelled$source == "non_contaminant",
                                                df_labelled$minimizer_microbe_ratio, 0)
  
  df_labelled$minimizer_filter <- ifelse(df_labelled$distinct_minimizer_count >= minimizer_threshold,TRUE, FALSE)
  
  #taxa_pass_filter for MGX data if 
  #a) at least 2000 unique k-mers per 1 million microbial reads AND
  #b) at least >= 0.1% relative abundance amongst non contaminant, non spike in, microbe reads at species level
  
  #OR
  
  #c) There was a true positive RNA signal in the paired library
  
  matched_mtx_id <- mtx_mgx_stats_chosen %>% dplyr::filter(mgx_LIBID==x) %>% pull(mtx_LIBID) %>% unique(.)
  
  #true positive (TP) taxa in matching mtx data
  matched_mtx_TP <- rna_k2_minimizer[[matched_mtx_id]] %>% dplyr::filter(taxa_pass_filter==TRUE) %>% pull(k2_taxon)
  
  df_labelled$mtx_filter <- ifelse(df_labelled$k2_taxon %in% matched_mtx_TP, TRUE, FALSE)
  
  #####
  df_labelled$taxa_pass_filter <- ifelse((df_labelled$minimizer_filter ==TRUE &
                                           df_labelled$abun_filter ==TRUE)|df_labelled$mtx_filter==TRUE, TRUE,FALSE)
  df_labelled$mgx_LIBID <- x
  
  df_labelled$matched_mtx_LIBID <- matched_mtx_id
  
  return(df_labelled)
  
}) 

names(k2_minimizer) <- mgx_to_pull

#write the results

lapply(names(k2_minimizer), function(x){
  
  write_tsv(k2_minimizer[[x]], 
            file=paste0("../processed/k2_species_renorm/DNA/unfiltered/",x,"_k2_minimizer.s.tsv"))
  
})

```

```{r eval=FALSE}
##Perform total sum scaling renormalization on taxa that passed filters.

k2_minimizer_renorm <- lapply(names(k2_minimizer), function(x){
  
  #True positive
  df_TP <- k2_minimizer[[x]] %>% 
    dplyr::filter(taxa_pass_filter==TRUE)
  
  #Compute relative abundance at species level expressed as percentage abundance
  df_TP$rel_abun <- (df_TP$paired_counts / sum(df_TP$paired_counts))*100
  
  return(df_TP)
  
})

names(k2_minimizer_renorm ) <- mgx_to_pull

rna_k2_minimizer_renorm <- lapply(names(rna_k2_minimizer), function(x){
  
  #True positive
  df_TP <- rna_k2_minimizer[[x]] %>% 
    dplyr::filter(taxa_pass_filter==TRUE)
  
  #Compute relative abundance at species level expressed as percentage abundance
  df_TP$rel_abun <- (df_TP$paired_counts / sum(df_TP$paired_counts))*100
  
  return(df_TP)
  
})

names(rna_k2_minimizer_renorm ) <- mtx_to_pull

```

Save the renormalized dataframes. These would be suitable for downstream analyses in other notebooks

Note: perhaps should remove the species_microbe_read_total to avoid confusion? 
```{r eval=FALSE}
lapply(names(rna_k2_minimizer_renorm), function(x){
  
  write_tsv(rna_k2_minimizer_renorm[[x]], 
            file=paste0("../processed/k2_species_renorm/RNA/",x,"_k2_renorm.s.tsv"))
  
})


lapply(names(k2_minimizer_renorm), function(x){
  
  write_tsv(k2_minimizer_renorm[[x]], 
            file=paste0("../processed/k2_species_renorm/DNA/",x,"_k2_renorm.s.tsv"))
  
})



```

Load the unnormalized and renormalized dataframes to avoid running the previous code chunks

```{r}

#MTX data

rna_k2_minimizer <- lapply(mtx_to_pull, function(x){
  
  df_out <- read_tsv(file=paste0("../processed/k2_species_renorm/RNA/unfiltered/",x,"_k2_minimizer.s.tsv"),
           show_col_types = FALSE)
  return(df_out)
  
})

names(rna_k2_minimizer) <- mtx_to_pull

rna_k2_minimizer_renorm <- lapply(mtx_to_pull, function(x){
  
  df_out <- read_tsv(file=paste0("../processed/k2_species_renorm/RNA/",x,"_k2_renorm.s.tsv"),
           show_col_types = FALSE)
  
  return(df_out)
  
})

names(rna_k2_minimizer_renorm) <- mtx_to_pull

#MGX data
k2_minimizer_renorm <- lapply(mgx_to_pull, function(x){
  
  df_out <- read_tsv(file=paste0("../processed/k2_species_renorm/DNA/",x,"_k2_renorm.s.tsv"),
           show_col_types = FALSE)
  
  return(df_out)
  
})

names(k2_minimizer_renorm) <- mgx_to_pull


```


## Compute transcriptional activity


Calculate normalized transcriptional activity as RNA/DNA ratio  (TPM (RNA)/CPM (DNA))

references for transcriptional activity: Abu-Ali and Huttenhower + Humann2 paper (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6235447/)

RPK and TPM calculations


```{r}

#Merge mtx and mgx data by taxonomic features, taking into account some features present in one dataset but not the other
#mtx_to_pull
combined_taxa_count_list <- lapply(mtx_to_pull, function(x){
  
  mtx_id <- x
  mgx_id <- mtx_mgx_stats_chosen %>% dplyr::filter(mtx_LIBID==x) %>% pull(mgx_LIBID)
  
  subject_region <- mtx_mgx_stats_chosen %>% dplyr::filter(mtx_LIBID==x) %>% pull(subj_region)
  body_site <- mtx_mgx_stats_chosen %>% dplyr::filter(mtx_LIBID==x) %>% pull(region)
  
  ###df with minimizers for mgx data, non-contaminant species that passed filters. No unclassified or human reads
  minimizer_df <- k2_minimizer_renorm[[mgx_id]] %>% 
    dplyr::select(k2_taxon, mgx_LIBID, paired_counts,rel_abun) %>%
    dplyr::rename(mgx_paired_counts=paired_counts, 
                  mgx_rel_abun = rel_abun)
  
  ###df with minimizers for mtx data, non-contaminant species that passed filters. No unclassified or human reads
  mtx_minimizer_df <- rna_k2_minimizer_renorm[[mtx_id]] %>% 
    dplyr::select(k2_taxon, mtx_LIBID, paired_counts, rel_abun) %>%
    dplyr::rename(mtx_paired_counts=paired_counts, 
                  mtx_rel_abun = rel_abun)
  
  
  
  #Species level analysis: Add unpaired counts and RPK at mtx level
  #For unpaired counts, subspecies will be collapsed into the parent species
  mtx_taxa_df <- mtx_taxa_count_summary_subsp_collapse[[mtx_id]] %>% 
    dplyr::rename(mtx_counts=read_count_sum,mtx_RPK=RPK_sum) %>% ungroup() %>% 
    dplyr::filter(k2_taxon %in% mtx_minimizer_df$k2_taxon) %>% dplyr::select(-LIBID)
  
  
  mtx_minimizer_df <- merge(mtx_minimizer_df, mtx_taxa_df, by = "k2_taxon", all.x=TRUE)
  
  #Species level analysis: Add unpaired counts and RPK at mgx level
  mgx_taxa_df <- mgx_taxa_count_summary_subsp_collapse[[mgx_id]] %>% 
    dplyr::rename(mgx_counts=read_count_sum,mgx_RPK=RPK_sum) %>% ungroup() %>%
    dplyr::filter(k2_taxon %in% minimizer_df$k2_taxon) %>% dplyr::select(-LIBID)
  
  minimizer_df <- merge(minimizer_df, mgx_taxa_df, by = "k2_taxon", all.x=TRUE)
  
  
  combined_df <- merge(minimizer_df,mtx_minimizer_df, all=TRUE, by = "k2_taxon")
  
 
  combined_df[is.na(combined_df)] <- 0
  
  combined_df$mtx_LIBID <- x
  
  
  ###Also calculate the TPM (for mtx) and CPM (for mgx)
  ##Important result
  #No zero smoothing or imputation used
  #The scaling factor should be based on per million FILTERED AND CLASSIFIED reads at species level. (So no K2 unclassified etc)
  #It would not make sense to do TPM calculations with false positives and contaminants still included.
  
  mtx_RPK_sum <- combined_df %>% pull(mtx_RPK) %>% sum(.)
  
  mtx_scaling_factor <- mtx_RPK_sum / 1000000
    
  mgx_RPK_sum <- combined_df %>% pull(mgx_RPK) %>% sum(.)
  
  mgx_scaling_factor <- mgx_RPK_sum / 1000000
  
  
  combined_df$mtx_TPM <- combined_df$mtx_RPK/mtx_scaling_factor
  combined_df$mgx_CPM <- combined_df$mgx_RPK/mgx_scaling_factor
  
  
  combined_df$transcriptional_activity <- combined_df$mtx_TPM/combined_df$mgx_CPM
  
  
  #Compute a separate set of TPMs and transcriptional activity without Malassezia.
  #This would be a rough proxy for "prokaryotic transcriptional activity"
  
  
  mtx_RPK_prok_sum <- combined_df %>% 
    dplyr::filter(str_detect(string=.$k2_taxon,
                             pattern="Malassezia",
                             negate=TRUE)) %>% pull(mtx_RPK) %>% sum(.)
  
  mtx_prok_scaling_factor <- mtx_RPK_prok_sum / 1000000
    
  mgx_RPK_prok_sum <- combined_df %>% 
    dplyr::filter(str_detect(string=.$k2_taxon,
                             pattern="Malassezia",
                             negate=TRUE)) %>% pull(mgx_RPK) %>% sum(.)
  
  mgx_prok_scaling_factor <- mgx_RPK_prok_sum / 1000000
  
  
  combined_df$mtx_TPM_prok <- ifelse(str_detect(string=combined_df$k2_taxon,
                             pattern="Malassezia",
                             negate=TRUE), combined_df$mtx_RPK/mtx_prok_scaling_factor,0)
  
  combined_df$mgx_CPM_prok <- ifelse(str_detect(string=combined_df$k2_taxon,
                             pattern="Malassezia",
                             negate=TRUE), combined_df$mgx_RPK/mgx_prok_scaling_factor,0)
  
  
  combined_df$prok_transcriptional_activity <- ifelse(str_detect(string=combined_df$k2_taxon,
                             pattern="Malassezia",
                             negate=TRUE),combined_df$mtx_TPM_prok/combined_df$mgx_CPM_prok, 0)
  
  

  return(combined_df)
  
})

names(combined_taxa_count_list) <- mtx_to_pull



```

Save the results of the previous code chunk
```{r eval=FALSE}
#3096
combined_taxa_count_activity_df <- do.call("rbind",combined_taxa_count_list) 

combined_taxa_count_activity_df <- merge(combined_taxa_count_activity_df,
                                         mtx_mgx_stats_chosen %>% 
                                           dplyr::select(mtx_LIBID,subj_region,region))

write_tsv(combined_taxa_count_activity_df, "../processed/combined_taxa_count_activity_df.tsv")

```



#Matrix of transcription ratios (test per species)


These species are prevalent across multple skin sites (metagenomic level): Cutibacterium acnes, Malassezia globosa, Malassezia restricta, Staphylococcus capitis, Staphylococcus epidermidis and staphylococcus hominis

We can also perform a similar analysis, with Corynebacterium species even though it is not a prevalent microbe across all 5 sites.



https://www.technologynetworks.com/informatics/articles/the-kruskal-wallis-test-370025
https://www.r-bloggers.com/2022/05/how-to-perform-the-kruskal-wallis-test-in-r/

K-W test -> significant? -> Pairwise wilcox. 

https://stats.stackexchange.com/questions/384742/wilcoxon-test-non-normality-non-equal-variances-sample-size-not-the-same
tl;dr if you want to interpret the rejection of the null hypothesis as evidence that measurement in group 1 is greater than those for group 2, then you do need the assumption of equal variance (in fact, equal distributions) between the two populations. If you are satisfied with showing that the distribution of measurements differs in some way from that of the two groups, then you don't need the extra assumption.

You don't need to worry about unequal sample size (this will affect the power of the test, but not its validity) or Normality.

https://stats.stackexchange.com/questions/56971/alternative-to-one-way-anova-unequal-variance
Even for Anova, there's a rule of thumb that the ANOVA is robust to heterogeneity of variance so long as the largest variance is not more than 4 times the smallest variance. Furthermore, the general effect of heterogeneity of variance is to make the ANOVA less efficient. That is, you would have lower power. Since you have a significant effect anyway, there is less reason to be concerned here.


The distribution of the Kruskal-Wallis test statistic approximates a chi-square distribution, with k-1 degrees of freedom, if the number of observations in each group is 5 or more. 

Every taxa tested here is represented in at least 5 or more libraries per site, at the metagenomic level

```{r}
subsetted_taxa_count_df <- do.call("rbind",combined_taxa_count_list) %>% 
  dplyr::filter(k2_taxon %in% c("Cutibacterium_acnes","Malassezia_globosa",
                                "Malassezia_restricta","Staphylococcus_capitis",
                                "Staphylococcus_epidermidis","Staphylococcus_hominis",
                                "Corynebacterium_tuberculostearicum",
                                "Corynebacterium_kefirresidentii"))

#add skin site information
subsetted_taxa_count_df <- merge(subsetted_taxa_count_df, mtx_mgx_stats_chosen %>% dplyr::select(mtx_LIBID,region))

#For each species, only keep the regions (skin sites) with at least 5 libraries where the species can be detected (metagenomically present)

subsetted_taxa_count_overview <- plyr::count(subsetted_taxa_count_df, c("k2_taxon","region"))

taxa_to_KW_test <- c("Cutibacterium_acnes","Malassezia_globosa",
                                "Malassezia_restricta","Staphylococcus_capitis",
                                "Staphylococcus_epidermidis","Staphylococcus_hominis",
                      "Corynebacterium_tuberculostearicum",
                     "Corynebacterium_kefirresidentii")

#kruskal wallis test
#return output as a list of lists
subsetted_taxa_KW_test_results <- lapply(taxa_to_KW_test, function(species_name){
  
  species_specific_df <- subsetted_taxa_count_df %>% dplyr::filter(k2_taxon == species_name)
  
  KW_test_result <- kruskal.test(transcriptional_activity ~ region, data = species_specific_df)
  
  #unadjusted for multiple comparisons
  KW_p_value <- KW_test_result$p.value
  

  #For some reason, ggpubr::compare_means does not output identical p values as pairwise.wilcox.test
  #pairwise_wilcox_result <- compare_means(transcriptional_activity ~ region, 
  #                     p.adjust.method = "fdr", method='wilcox.test', data = species_specific_df)
  
  #triangular matrix for neater heatmaps
  pairwise_wilcox_result_triangular <- pairwise.wilcox.test(species_specific_df$transcriptional_activity,
                                                            species_specific_df$region, 
                                                            p.adjust.method = "fdr", exact=FALSE)
  
  pairwise_wilcox_result_triangular <- melt(pairwise_wilcox_result_triangular$p.value, na.rm=TRUE) %>%
    dplyr::rename(group1=Var1, group2=Var2, p.adj=value)
  
  pairwise_wilcox_result_triangular$p_adj.signif <- case_when(
  pairwise_wilcox_result_triangular$p.adj >= 0.05 ~ "ns",
  pairwise_wilcox_result_triangular$p.adj < 1e-04  ~ "****",
  pairwise_wilcox_result_triangular$p.adj < 1e-03 ~ "***",
  pairwise_wilcox_result_triangular$p.adj < 1e-02 ~ "**",
  pairwise_wilcox_result_triangular$p.adj < 0.05 ~ "*")
  
  pairwise_wilcox_result_triangular$p_adj.signif <- factor(pairwise_wilcox_result_triangular$p_adj.signif,
                                                  levels=c("****","***","**","*","ns"))

  pairwise_wilcox_result_triangular$p.adj_exp <- format(pairwise_wilcox_result_triangular$p.adj, 
                                                        scientific=TRUE, digits=3)
  
  
  KW_summary_df <- data.frame(k2_taxon=species_name,kruskal_wallis_p_value=KW_p_value)
  
  output <- lst(KW_summary_df, KW_test_result, pairwise_wilcox_result_triangular)
  
  return(output)
  
})

names(subsetted_taxa_KW_test_results) <- taxa_to_KW_test


subsetted_taxa_KW_test_summary <- lapply(taxa_to_KW_test, function(x){
  
  df_out <- subsetted_taxa_KW_test_results[[x]]$KW_summary_df
  
}) %>% do.call("rbind",.)

#adjust for multiple testing

subsetted_taxa_KW_test_summary$kruskal_wallis_p_adj <- p.adjust(subsetted_taxa_KW_test_summary$kruskal_wallis_p_value,
                                                                method="fdr")
```

For box plots, we transform the transcriptional activities by log2(transcription activity + 1).

This transformation preserves the zero values. 

https://stats.stackexchange.com/questions/178744/how-do-logarithmic-measurements-affect-the-wilcoxon-rank-sum-test
The Wilcoxon test should give identical results since rank ordering is preserved).

```{r}
#Boxplots for transcriptional activity, per species
#only show the significant differences

subsetted_taxa_count_df$log2_transcriptional_activity <- log2(subsetted_taxa_count_df$transcriptional_activity + 1)

subsetted_taxa_count_df$region <- factor(subsetted_taxa_count_df$region, levels=c("Sc",
                                                                                  "Ch",
                                                                                  "Ac",
                                                                                  "Vf",
                                                                                  "Tw"))

#########
#C_acnes#
#########

#Displaying the p value in the boxplot is too messy. We can display them in a companion heatmap?

C_acnes_trans_act_boxplot <- ggplot(subsetted_taxa_count_df %>% 
         dplyr::filter(k2_taxon == "Cutibacterium_acnes"), 
       aes(x=region,y=log2_transcriptional_activity)) + geom_boxplot() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.title.x=element_blank()) + 
  ggtitle("C_acnes transcriptional activity") #stat_pvalue_manual(subsetted_taxa_KW_test_results$Cutibacterium_acnes$pairwise_wilcox_result, 
 #                                                                 label = "p.adj",
  #                                                                y.position = seq(from=2,by=0.2, length.out=10))

ggsave(filename="../plots/transcription_activity/C_acnes_trans_act_boxplot.pdf",
       plot=C_acnes_trans_act_boxplot,
       height = 8, width = 10)

C_acnes_trans_act_boxplot


C_acnes_pairwise_wilcox_result <- subsetted_taxa_KW_test_results$Cutibacterium_acnes$pairwise_wilcox_result_triangular



C_acnes_trans_act_p_val_plot <- ggplot(data=C_acnes_pairwise_wilcox_result, aes(x=group1, y = group2, fill=p_adj.signif)) + 
  geom_tile(colour ="white") + geom_text(aes(label=p.adj_exp)) +
  scale_fill_manual(values=c(#"#b62020",
                             "#fe2e2e",
                             "#fe8181",
                             "#ffb6c1",
                             "white")) + 
  scale_x_discrete(expand = c(0, 0)) + 
  scale_y_discrete(expand = c(0, 0)) + 
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.2, hjust=1)) +
  theme(panel.background = element_rect(fill = 'white')) +
  theme(axis.title = element_blank()) + ggtitle("C_acnes")


ggsave(filename="../plots/transcription_activity/C_acnes_trans_act_p_val_plot.pdf",
       plot=C_acnes_trans_act_p_val_plot,
       height = 8, width = 10)



C_acnes_trans_act_p_val_plot

```

```{r}


#########
#M_globosa#
#########

#Displaying the p value in the boxplot is too messy. We can display them in a companion heatmap?

M_globosa_trans_act_boxplot <- ggplot(subsetted_taxa_count_df %>% 
         dplyr::filter(k2_taxon == "Malassezia_globosa"), 
       aes(x=region,y=log2_transcriptional_activity)) + geom_boxplot() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.title.x=element_blank()) + 
  ggtitle("M_globosa transcriptional activity") #stat_pvalue_manual(subsetted_taxa_KW_test_results$Malassezia_globosa$pairwise_wilcox_result, 
 #                                                                 label = "p.adj",
  #                                                                y.position = seq(from=2,by=0.2, length.out=10))

ggsave(filename="../plots/transcription_activity/M_globosa_trans_act_boxplot.pdf",
       plot=M_globosa_trans_act_boxplot,
       height = 8, width = 10)

M_globosa_trans_act_boxplot


M_globosa_pairwise_wilcox_result <- subsetted_taxa_KW_test_results$Malassezia_globosa$pairwise_wilcox_result_triangular


M_globosa_trans_act_p_val_plot <- ggplot(data=M_globosa_pairwise_wilcox_result, aes(x=group1, y = group2, fill=p_adj.signif)) + 
  geom_tile(colour ="white") + geom_text(aes(label=p.adj_exp)) +
  scale_fill_manual(values=c(#"#b62020",
                             "#fe2e2e",
                             "#fe8181",
                             #"#ffb6c1",
                             "white")) + 
  scale_x_discrete(expand = c(0, 0)) + 
  scale_y_discrete(expand = c(0, 0)) + 
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.2, hjust=1)) +
  theme(panel.background = element_rect(fill = 'white')) +
  theme(axis.title = element_blank()) + ggtitle("M_globosa")


ggsave(filename="../plots/transcription_activity/M_globosa_trans_act_p_val_plot.pdf",
       plot=M_globosa_trans_act_p_val_plot,
       height = 8, width = 10)



M_globosa_trans_act_p_val_plot


```


```{r}

#########
#M_restricta#
#########

#Displaying the p value in the boxplot is too messy. We can display them in a companion heatmap?

M_restricta_trans_act_boxplot <- ggplot(subsetted_taxa_count_df %>% 
         dplyr::filter(k2_taxon == "Malassezia_restricta"), 
       aes(x=region,y=log2_transcriptional_activity)) + geom_boxplot() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.title.x=element_blank()) + 
  ggtitle("M_restricta transcriptional activity") #stat_pvalue_manual(subsetted_taxa_KW_test_results$Malassezia_restricta$pairwise_wilcox_result, 
 #                                                                 label = "p.adj",
  #                                                                y.position = seq(from=2,by=0.2, length.out=10))

ggsave(filename="../plots/transcription_activity/M_restricta_trans_act_boxplot.pdf",
       plot=M_restricta_trans_act_boxplot,
       height = 8, width = 10)

M_restricta_trans_act_boxplot


M_restricta_pairwise_wilcox_result <- subsetted_taxa_KW_test_results$Malassezia_restricta$pairwise_wilcox_result_triangular


M_restricta_trans_act_p_val_plot <- ggplot(data=M_restricta_pairwise_wilcox_result, aes(x=group1, y = group2, fill=p_adj.signif)) + 
  geom_tile(colour ="white") + geom_text(aes(label=p.adj_exp)) +
  scale_fill_manual(values=c("#b62020",
                             "#fe2e2e",
                             "#fe8181",
                             "#ffb6c1",
                             "white")) + 
  scale_x_discrete(expand = c(0, 0)) + 
  scale_y_discrete(expand = c(0, 0)) + 
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.2, hjust=1)) +
  theme(panel.background = element_rect(fill = 'white')) +
  theme(axis.title = element_blank()) + ggtitle("M_restricta")


ggsave(filename="../plots/transcription_activity/M_restricta_trans_act_p_val_plot.pdf",
       plot=M_restricta_trans_act_p_val_plot,
       height = 8, width = 10)



M_restricta_trans_act_p_val_plot




```


```{r}

#########
#S_capitis#
#########

#Displaying the p value in the boxplot is too messy. We can display them in a companion heatmap?

S_capitis_trans_act_boxplot <- ggplot(subsetted_taxa_count_df %>% 
         dplyr::filter(k2_taxon == "Staphylococcus_capitis"), 
       aes(x=region,y=log2_transcriptional_activity)) + geom_boxplot() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.title.x=element_blank()) + 
  ggtitle("S_capitis transcriptional activity") #stat_pvalue_manual(subsetted_taxa_KW_test_results$Staphylococcus_capitis$pairwise_wilcox_result, 
 #                                                                 label = "p.adj",
  #                                                                y.position = seq(from=2,by=0.2, length.out=10))

ggsave(filename="../plots/transcription_activity/S_capitis_trans_act_boxplot.pdf",
       plot=S_capitis_trans_act_boxplot,
       height = 8, width = 10)

S_capitis_trans_act_boxplot


S_capitis_pairwise_wilcox_result <- subsetted_taxa_KW_test_results$Staphylococcus_capitis$pairwise_wilcox_result_triangular


S_capitis_trans_act_p_val_plot <- ggplot(data=S_capitis_pairwise_wilcox_result, aes(x=group1, y = group2, fill=p_adj.signif)) + 
  geom_tile(colour ="white") + geom_text(aes(label=p.adj_exp)) +
  scale_fill_manual(values=c(#"#b62020",
                             "#fe2e2e",
                             "#fe8181",
                             "#ffb6c1",
                             "white")) + 
  scale_x_discrete(expand = c(0, 0)) + 
  scale_y_discrete(expand = c(0, 0)) + 
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.2, hjust=1)) +
  theme(panel.background = element_rect(fill = 'white')) +
  theme(axis.title = element_blank()) + ggtitle("S_capitis")


ggsave(filename="../plots/transcription_activity/S_capitis_trans_act_p_val_plot.pdf",
       plot=S_capitis_trans_act_p_val_plot,
       height = 8, width = 10)



S_capitis_trans_act_p_val_plot


```

```{r}

#########
#S_epidermidis#
#########

#Displaying the p value in the boxplot is too messy. We can display them in a companion heatmap?

S_epidermidis_trans_act_boxplot <- ggplot(subsetted_taxa_count_df %>% 
         dplyr::filter(k2_taxon == "Staphylococcus_epidermidis"), 
       aes(x=region,y=log2_transcriptional_activity)) + geom_boxplot() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.title.x=element_blank()) + 
  ggtitle("S_epidermidis transcriptional activity") #stat_pvalue_manual(subsetted_taxa_KW_test_results$Staphylococcus_epidermidis$pairwise_wilcox_result, 
 #                                                                 label = "p.adj",
  #                                                                y.position = seq(from=2,by=0.2, length.out=10))

ggsave(filename="../plots/transcription_activity/S_epidermidis_trans_act_boxplot.pdf",
       plot=S_epidermidis_trans_act_boxplot,
       height = 8, width = 10)

S_epidermidis_trans_act_boxplot


S_epidermidis_pairwise_wilcox_result <- subsetted_taxa_KW_test_results$Staphylococcus_epidermidis$pairwise_wilcox_result_triangular


S_epidermidis_trans_act_p_val_plot <- ggplot(data=S_epidermidis_pairwise_wilcox_result, aes(x=group1, y = group2, fill=p_adj.signif)) + 
  geom_tile(colour ="white") + geom_text(aes(label=p.adj_exp)) +
  scale_fill_manual(values=c("#b62020",
                             "#fe2e2e",
                             "#fe8181",
                             #"#ffb6c1",
                             "white")) + 
  scale_x_discrete(expand = c(0, 0)) + 
  scale_y_discrete(expand = c(0, 0)) + 
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.2, hjust=1)) +
  theme(panel.background = element_rect(fill = 'white')) +
  theme(axis.title = element_blank()) + ggtitle("S_epidermidis")


ggsave(filename="../plots/transcription_activity/S_epidermidis_trans_act_p_val_plot.pdf",
       plot=S_epidermidis_trans_act_p_val_plot,
       height = 8, width = 10)



S_epidermidis_trans_act_p_val_plot




```

```{r}

#########
#S_hominis#
#########

#Displaying the p value in the boxplot is too messy. We can display them in a companion heatmap?

S_hominis_trans_act_boxplot <- ggplot(subsetted_taxa_count_df %>% 
         dplyr::filter(k2_taxon == "Staphylococcus_hominis"), 
       aes(x=region,y=log2_transcriptional_activity)) + geom_boxplot() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.title.x=element_blank()) + 
  ggtitle("S_hominis transcriptional activity") #stat_pvalue_manual(subsetted_taxa_KW_test_results$Staphylococcus_hominis$pairwise_wilcox_result, 
 #                                                                 label = "p.adj",
  #                                                                y.position = seq(from=2,by=0.2, length.out=10))

ggsave(filename="../plots/transcription_activity/S_hominis_trans_act_boxplot.pdf",
       plot=S_hominis_trans_act_boxplot,
       height = 8, width = 10)

S_hominis_trans_act_boxplot


S_hominis_pairwise_wilcox_result <- subsetted_taxa_KW_test_results$Staphylococcus_hominis$pairwise_wilcox_result_triangular


S_hominis_trans_act_p_val_plot <- ggplot(data=S_hominis_pairwise_wilcox_result, aes(x=group1, y = group2, fill=p_adj.signif)) + 
  geom_tile(colour ="white") + geom_text(aes(label=p.adj_exp)) +
  scale_fill_manual(values=c(#"#b62020",
                             #"#fe2e2e",
                             "#fe8181",
                             #"#ffb6c1",
                             "white")) + 
  scale_x_discrete(expand = c(0, 0)) + 
  scale_y_discrete(expand = c(0, 0)) + 
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.2, hjust=1)) +
  theme(panel.background = element_rect(fill = 'white')) +
  theme(axis.title = element_blank()) + ggtitle("S_hominis")


ggsave(filename="../plots/transcription_activity/S_hominis_trans_act_p_val_plot.pdf",
       plot=S_hominis_trans_act_p_val_plot,
       height = 8, width = 10)



S_hominis_trans_act_p_val_plot





```


```{r}

#########
#C_tuberculostearicum
#########

#Displaying the p value in the boxplot is too messy. We can display them in a companion heatmap?

C_tuberculo_trans_act_boxplot <- ggplot(subsetted_taxa_count_df %>% 
         dplyr::filter(k2_taxon == "Corynebacterium_tuberculostearicum"), 
       aes(x=region,y=log2_transcriptional_activity)) + geom_boxplot() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.title.x=element_blank()) + 
  ggtitle("C_tuberculo transcriptional activity") #stat_pvalue_manual(subsetted_taxa_KW_test_results$Corynebacterium_tuberculostearicum$pairwise_wilcox_result, 
 #                                                                 label = "p.adj",
  #                                                                y.position = seq(from=2,by=0.2, length.out=10))

ggsave(filename="../plots/transcription_activity/C_tuberculo_trans_act_boxplot.pdf",
       plot=C_tuberculo_trans_act_boxplot,
       height = 8, width = 10)

C_tuberculo_trans_act_boxplot


C_tuberculo_pairwise_wilcox_result <- subsetted_taxa_KW_test_results$Corynebacterium_tuberculostearicum$pairwise_wilcox_result_triangular


C_tuberculo_trans_act_p_val_plot <- ggplot(data=C_tuberculo_pairwise_wilcox_result, aes(x=group1, y = group2, fill=p_adj.signif)) + 
  geom_tile(colour ="white") + geom_text(aes(label=p.adj_exp)) +
  scale_fill_manual(values=c(#"#b62020",
                             #"#fe2e2e",
                             "#fe8181",
                             #"#ffb6c1",
                             "white")) + 
  scale_x_discrete(expand = c(0, 0)) + 
  scale_y_discrete(expand = c(0, 0)) + 
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.2, hjust=1)) +
  theme(panel.background = element_rect(fill = 'white')) +
  theme(axis.title = element_blank()) + ggtitle("C_tuberculo")


ggsave(filename="../plots/transcription_activity/C_tuberculo_trans_act_p_val_plot.pdf",
       plot=C_tuberculo_trans_act_p_val_plot,
       height = 8, width = 10)



C_tuberculo_trans_act_p_val_plot
```
```{r}

#########
#Corynebacterium_kefirresidentii
#########

C_kefirr_trans_act_boxplot <- ggplot(subsetted_taxa_count_df %>% 
         dplyr::filter(k2_taxon == "Corynebacterium_kefirresidentii"), 
       aes(x=region,y=log2_transcriptional_activity)) + geom_boxplot() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.title.x=element_blank()) + 
  ggtitle("C_kefirr transcriptional activity") #stat_pvalue_manual(subsetted_taxa_KW_test_results$Corynebacterium_kefirresidentii$pairwise_wilcox_result, 
 #                                                                 label = "p.adj",
  #                                                                y.position = seq(from=2,by=0.2, length.out=10))

ggsave(filename="../plots/transcription_activity/C_kefirr_trans_act_boxplot.pdf",
       plot=C_kefirr_trans_act_boxplot,
       height = 8, width = 10)

C_kefirr_trans_act_boxplot


C_kefirr_pairwise_wilcox_result <- subsetted_taxa_KW_test_results$Corynebacterium_kefirresidentii$pairwise_wilcox_result_triangular


C_kefirr_trans_act_p_val_plot <- ggplot(data=C_kefirr_pairwise_wilcox_result, aes(x=group1, y = group2, fill=p_adj.signif)) + 
  geom_tile(colour ="white") + geom_text(aes(label=p.adj_exp)) +
  scale_fill_manual(values=c(#"#b62020",
                             "#fe2e2e",
                             "#fe8181",
                             "#ffb6c1",
                             "white")) + 
  scale_x_discrete(expand = c(0, 0)) + 
  scale_y_discrete(expand = c(0, 0)) + 
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.2, hjust=1)) +
  theme(panel.background = element_rect(fill = 'white')) +
  theme(axis.title = element_blank()) + ggtitle("C_kefirr")


ggsave(filename="../plots/transcription_activity/C_kefirr_trans_act_p_val_plot.pdf",
       plot=C_kefirr_trans_act_p_val_plot,
       height = 8, width = 10)



C_kefirr_trans_act_p_val_plot




```


```{r}
#These categories are outdated for plotting purposes (17/04/2024)

#As an alternative, we could make bubble plots with size of the bubbles scaling with prevalence but shading scaling with median transcriptional activity (RNA/DNA ratio)

#With malassezia
find_mtx_taxa_categories <- function(site, input_list=combined_taxa_count_list){
  
  site_vector <- mtx_stats_chosen %>% dplyr::filter(region==site) %>% pull(LIBID)
  
  no_of_samples <- length(input_list[site_vector])
  
  site_df <- do.call("rbind", input_list[site_vector])
  
  ######################
  #For measured features
  #####################
  #dataframe summarizing the frequency of detection across sites
  #https://stackoverflow.com/questions/55645082/dplyr-row-count-by-group-excluding-zeros
  
  freq_measured_df <- site_df %>% dplyr::filter(transcriptional_activity != 0) %>% group_by(k2_taxon) %>% 
    summarise_at(vars(transcriptional_activity), ~sum(. != 0)) %>% dplyr::rename(n_detected=transcriptional_activity)
  
  freq_measured_df$percent_detected_at_site <- (freq_measured_df$n_detected/no_of_samples)*100
   
  #dataframe summarizing median transcriptional_activity (TPM/CPM) for features in samples with measured activity ONLY, per feature
 
  median_measured_df <- site_df %>% dplyr::filter(transcriptional_activity != 0) %>% group_by(k2_taxon) %>% 
    summarise(median_detect_transcriptional_activity = median(transcriptional_activity),
              mean_detect_transcriptional_activity = mean(transcriptional_activity))
  
  combined_df <- merge(freq_measured_df, median_measured_df, by = "k2_taxon", all.x=TRUE)
  
  #all features must be measured in at least two independent samples of the same site.
  combined_df <- combined_df %>% dplyr::filter(n_detected >= 2)
  
  combined_df$transcript_cat <- ifelse(combined_df$percent_detected_at_site >= 80 & 
                                         combined_df$median_detect_transcriptional_activity > 1, "Core_high",
                                         "temp_placeholder")
  
  combined_df$transcript_cat <- ifelse(combined_df$percent_detected_at_site >= 80 & 
                                         combined_df$median_detect_transcriptional_activity <= 1, "Core_low",
                                       combined_df$transcript_cat)
  
  combined_df$transcript_cat <- ifelse(combined_df$percent_detected_at_site < 80 & 
                                         combined_df$median_detect_transcriptional_activity > 1, "Variable_high",
                                       combined_df$transcript_cat)
  
  combined_df$transcript_cat <- ifelse(combined_df$percent_detected_at_site < 80 & 
                                         combined_df$median_detect_transcriptional_activity <= 1,
                                         "Variable_low",
                                       combined_df$transcript_cat)

  combined_df$region <- site
  return(combined_df)
 
}

```


Calculate the transcription activity per site 

See taxa_activity.Rmd for the balloon plots used in the manuscript.

```{r}

Tw_species_ratio <- find_mtx_taxa_categories(site="Tw")

Ch_species_ratio <- find_mtx_taxa_categories(site="Ch")

Vf_species_ratio <- find_mtx_taxa_categories(site="Vf")

Ac_species_ratio <- find_mtx_taxa_categories(site="Ac")

Sc_species_ratio <- find_mtx_taxa_categories(site="Sc")
```


```{r eval=FALSE}
write_tsv(Tw_species_ratio, "../processed/normalized/Tw_species_ratio.tsv")

write_tsv(Ch_species_ratio, "../processed/normalized/Ch_species_ratio.tsv")

write_tsv(Vf_species_ratio, "../processed/normalized/Vf_species_ratio.tsv")

write_tsv(Ac_species_ratio, "../processed/normalized/Ac_species_ratio.tsv")

write_tsv(Sc_species_ratio, "../processed/normalized/Sc_species_ratio.tsv")




```



## Load in eight species pangenome results to find gene clusters expressed by a majority of the same organism within a site
19th Sep update

Read FADU:a Quantification Tool for Prokaryotic Transcriptomic Analyses for a brief primer on the complexities of using traditional methods like Salmon or featurecounts for prokaryotic transcript counting. 

You can cite https://www.nature.com/articles/s41522-022-00328-6 for the use of bbmap pileup.sh for generating read counts to ORFs

Salmon requires reference transcripts, but prokaryotic transcripts exist as operons. This makes it less suited.

Load in the read count matrix for mtx mapped to the eight species pangenome (bowtie2 -> bbmap pileup.sh) 

We will convert the read counts to RPK and then species specific TPM (meaning per million mapped reads to species specific pangenes)

We will ignore unmapped reads here

```{r}

mtx_bt2_pangenome_counts <- lapply(mtx_to_pull, function(x){
  df <- read_tsv(file=paste0("../processed/mtx_species_mapping/bt2_out/RNA/",x,"_bt2_microbe_pangenome_aligned_filtered_cov.tsv"),
                 show_col_types = FALSE)
  df$LIBID <- x
  
  return(df)
})

calculate_species_TPM <- function(df, species){
  
  df_filt <- df %>% dplyr::filter(str_detect(df$pangene, pattern = species))
  
  df_filt$RPK <- (df_filt$unpaired_read_count/df_filt$length) *1000
  
  #does not count unmapped reads
  per_mill_scaling_factor <- sum(df_filt$RPK)/1E6
  
  df_filt$TPM <- df_filt$RPK/per_mill_scaling_factor
  
  df_filt$propan_clusterID <- str_match(string=df_filt$pangene, pattern="cluster_[0-9]*")[,1]
  
  #merge clusters together to fit the propan definitions
  df_filt_merge <- df_filt %>% group_by(propan_clusterID) %>% 
    summarise(unpaired_read_count_sum=sum(unpaired_read_count),
              RPK_sum=sum(RPK),
              TPM_sum=sum(TPM)) %>% ungroup()
  
  df_out <- df_filt_merge %>% dplyr::select(propan_clusterID, unpaired_read_count_sum,RPK_sum, TPM_sum) %>% unique()
  df_out$species <- species
  
  library_id <- df_filt %>% pull(LIBID) %>% unique()
  df_out$LIBID <- library_id
  
  return(df_out)
  
  
}

#categorizes expressed transcripts as "majority_expressed" or "not_majority_expressed"
#mainly used in the older Oct 2023 version of this analysis.
#do not use the terms core and non-core to minimize confusion
#results only make more sense if species highly abundant at the metatranscriptomes for a site.
categorize_expression_per_group <- function(df, cluster_prevalence_cutoff=50){
  
  
  #count the number of individuals per site with reads mapping to given species
  
  species_individual_site_freq <- df %>% dplyr::select(LIBID,region) %>% unique()
  species_individual_site_freq <- plyr::count(species_individual_site_freq, "region") %>% dplyr::rename(n_individual=freq) #region, freq
  
  
  #An older threshold was unpaired read count >= 5 and TPM >= 1
  #We will use unpaired_read_count <= 10 as our threshold for consistency across DESeq2 analyses
  df_expressed <- df %>% dplyr::filter(unpaired_read_count_sum >=10)
  
  #cluster freq is the number of unique individuals for which "robust expression was detected
  df_expressed_freq_by_site <- plyr::count(df_expressed, vars = c("propan_clusterID","region")) %>% dplyr::rename(cluster_freq=freq)
  
  df_expressed_freq_by_site <- merge(df_expressed_freq_by_site, species_individual_site_freq, by = "region" )
  
  df_expressed_freq_by_site$cluster_prevalence <- (df_expressed_freq_by_site$cluster_freq/df_expressed_freq_by_site$n_individual)*100
  
  df_expressed_majority_by_site <- df_expressed_freq_by_site %>% dplyr::filter(cluster_prevalence > cluster_prevalence_cutoff)
                                                      
  
  return(df_expressed_majority_by_site)
  
}


```

Get C_acnes counts after mapping to C acnes pangenomes.

```{r}

C_acnes_mtx_bt2_pangenome_counts <- lapply(mtx_bt2_pangenome_counts, function(x){
  
  output <-  calculate_species_TPM(x, species="Cutibacterium_acnes")
  
  return(output)
  
}) %>% do.call("rbind",.)

#add region information

C_acnes_mtx_bt2_pangenome_counts <- merge(C_acnes_mtx_bt2_pangenome_counts, mtx_stats_chosen %>% dplyr::select(LIBID,region), by ="LIBID")
                                          

#The worry is that these Scalp and cheeks are not comparable due to difference in C acnes coverage
#Sanity check shows this is ok

#Aggregate read counts per library

C_acnes_mtx_bt2_pangenome_counts_aggregate <- C_acnes_mtx_bt2_pangenome_counts %>% 
                                              group_by(LIBID,region) %>% summarise(total_read_count_in_sample=sum(unpaired_read_count_sum))

C_acnes_mtx_bt2_pangenome_counts_aggregate$region <- factor(C_acnes_mtx_bt2_pangenome_counts_aggregate$region,
                                                            levels=c("Sc","Ch","Vf","Ac","Tw"))

ggplot(C_acnes_mtx_bt2_pangenome_counts_aggregate %>% dplyr::filter(region %in% c("Sc","Ch")), 
       aes(x=region,y=log10(total_read_count_in_sample))) + geom_boxplot() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.title.x=element_blank()) + 
  ggtitle("Expressed C. acnes features")

#ggsave(plot = last_plot(), "../plots/DESeq_taxa/C_acnes_mtx_Sc_Ch_counts.pdf")


```

Not done yet : Do fisher's exact for secreted proteins in some median quantile of expression? Perhaps last figure last panel, site by site.



```{r eval=FALSE}

#C acnes pangenes with "function unknown" (S), or no known COG category("-")

#not very helpful
C_acnes_anno_COG_freq <- plyr::count(C_acnes_anno, vars="COG")


```


### Inter site DESeq2 comparisons, species specific.

## Bacterial DE analysis

C acnes on Scalp vs cheek. Use GSEA.


# GSEA notes
DESeq2 analysis + GSEA
https://alexslemonade.github.io/refinebio-examples/03-rnaseq/pathway-analysis_rnaseq_02_gsea.html
https://bioconductor.org/packages/release/bioc/vignettes/fgsea/inst/doc/fgsea-tutorial.html
https://davetang.org/muse/2018/01/10/using-fast-preranked-gene-set-enrichment-analysis-fgsea-package/

https://bioinformatics.ccr.cancer.gov/docs/btep-coding-club/FunctionalEnrich_clusterProfiler/

#Ranking genes for GSEA based on "stat" for DESeq2 or just "p-value"
https://www.biostars.org/p/9526168/
https://www.biostars.org/p/9559224/
https://www.biostars.org/p/420955/
For the Wald test, stat is the Wald statistic: the log2FoldChange divided by lfcSE, which is compared to a standard Normal distribution to generate a two-tailed pvalue.

#However, shrunken DESeq2 results estimated using poscounts have no "stat" column

The advice was to use the "LFC" after shrinkage:
https://support.bioconductor.org/p/129277/

# Method description of fgseaMultilevel (default algo in clusterprofiler GSEA())
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10278684/
We performed preranked GSEA using the fgseaMultiLevel() function from the fgsea package in R (Korotkevich et al., 2021), with the following parameters: minSize = 10, maxSize = 500, eps = 0.0, nPermSimple = 1000. The observed enrichment score (ES) is compared with an empirical null distribution of ESs generated by randomly shuffling phenotype labels and gene ordering 1000 times; the nominal p value is then calculated as 1 minus the proportion of permutations for which the observed ES was greater or lesser than the null distribution, for positive or negative ES, respectively. 



"TERM2NAME" for clusterprofiler is simply KEGG_term2name

Remember: The input list for these functions comprises of dfs with three columns: LIBID, propan_clusterID, unpaired_read_count_sum

```{r}

#Read counts for the propan clusters that are expressed by a majority of individuals with C acnes for Sc and Ch

C_acnes_mtx_cluster_counts <- C_acnes_mtx_bt2_pangenome_counts %>% 
  dplyr::select(LIBID, propan_clusterID, unpaired_read_count_sum)

#convert to input list
C_acnes_mtx_cluster_counts_list <- split(C_acnes_mtx_cluster_counts, 
                                                  f=C_acnes_mtx_cluster_counts$LIBID)

C_acnes_Sc_Ch_DE_QC <- QC_bacteria_RNA_sites(list_of_counts = C_acnes_mtx_cluster_counts_list,
                                                  species="Cutibacterium_acnes",
                                                  site="Sc", ref_site="Ch",
                                                  count_threshold = 200000,
                                                  shared_individuals_bet_sites=TRUE)

C_acnes_Sc_Ch_DE_QC[["PCA_plot"]]


#
C_acnes_Sc_Ch_DE_analysis <- compare_bacteria_RNA_sites(list_of_counts = C_acnes_mtx_cluster_counts_list,
                                                        species_anno=C_acnes_anno, 
                                                        species_pangene_names = C_acnes_pangene_names,
                                                  species="Cutibacterium_acnes",
                                                  site="Sc", ref_site="Ch",
                                                  count_threshold = 200000,
                                                  shared_individuals_bet_sites=TRUE)

plotDispEsts(C_acnes_Sc_Ch_DE_analysis[["species_site_filt_DESeq"]]$dds)

DESeq2::plotMA(C_acnes_Sc_Ch_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken)


summary(C_acnes_Sc_Ch_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken)




#check the DE results 
C_acnes_Sc_Ch_DE_results_shrunken <- C_acnes_Sc_Ch_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken_df

C_acnes_Sc_Ch_DE_results_shrunken <- merge(C_acnes_Sc_Ch_DE_results_shrunken, C_acnes_anno, by = "propan_clusterID")

C_acnes_Sc_Ch_DE_results_shrunken_signif <- C_acnes_Sc_Ch_DE_results_shrunken %>% dplyr::filter(padj < 0.05)


#GSEA analysis (alternative to ORA) using KEGG

C_acnes_Sc_Ch_DE_GSEA_KEGG <- GSEA_from_DESeq(genelist = C_acnes_Sc_Ch_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = C_acnes_Sc_Ch_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = C_acnes_Sc_Ch_DE_analysis$species_term2gene,
                                         term2name = KEGG_term2name)




clusterProfiler::dotplot(C_acnes_Sc_Ch_DE_GSEA_KEGG, showCategory=10, split=".sign") + facet_grid(.~.sign)

#Plot NES for GSEA

make_NES_barplot(C_acnes_Sc_Ch_DE_GSEA_KEGG@result, title= "Cutibacterium acnes transcripts, Sc vs Ch")

ggsave(filename="../plots/DESeq_taxa/C_acnes_Sc_Ch_DE_GSEA_KEGG_NES.pdf",
       plot=last_plot(),
       height = 8, width = 10)


##GSEA using GO (BF)

C_acnes_GO_term2gene <- make_custom_term2gene_df(input_annot = eight_skin_bact_proteins_emapper_annot %>% 
                                           dplyr::filter(species=="Cutibacterium_acnes"), annotation_used = "GO")


C_acnes_Sc_Ch_DE_GSEA_GO_BP <- GSEA_from_DESeq(genelist = C_acnes_Sc_Ch_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = C_acnes_Sc_Ch_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = C_acnes_GO_term2gene %>% dplyr::filter(from %in% GO_BP_term2name$from ),
                                         term2name = GO_BP_term2name)

clusterProfiler::dotplot(C_acnes_Sc_Ch_DE_GSEA_GO_BP, showCategory=10, split=".sign") + facet_grid(.~.sign)


#Plot NES for GSEA, GO BP
make_NES_barplot(C_acnes_Sc_Ch_DE_GSEA_GO_BP@result, title= "Cutibacterium acnes transcripts, Sc vs Ch")


##GSEA using GO (MF)

C_acnes_Sc_Ch_DE_GSEA_GO_MF <- GSEA_from_DESeq(genelist = C_acnes_Sc_Ch_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = C_acnes_Sc_Ch_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = C_acnes_GO_term2gene %>% dplyr::filter(from %in% GO_MF_term2name$from ),
                                         term2name = GO_MF_term2name)

clusterProfiler::dotplot(C_acnes_Sc_Ch_DE_GSEA_GO_MF, showCategory=10, split=".sign") + facet_grid(.~.sign)


#Plot NES for GSEA, GO MF
make_NES_barplot(C_acnes_Sc_Ch_DE_GSEA_GO_MF@result, title= "Cutibacterium acnes transcripts, Sc vs Ch")


#test <- C_acnes_Sc_Ch_DE_GSEA_GO_MF@result



```

GO results largely agree with KEGG analysis for C acnes, namely increased ribogenesis activity in Sc vs Ch

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2859892/
Furthermore, transcription of rRNA represents a major bottleneck in the synthesis of ribosomes. (Irep to estimate microbial growth rates for C acnes?)

Plot a Volcano plot for C acnes Sc vs Ch. This will be figure S3A

```{r}

#Label cluster_1501 (phospholipase C), cluster_1490 (phosphatidylinositol kinase) , metallopeptidase activity, peptidase

#stress responses higher in Scalp?. 1674 alkyl hydroperoxide reductase)
#https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6598116/



#Color the points that correspond to "Ribosome" == map03010, 

C_acnes_term2gene <- C_acnes_Sc_Ch_DE_analysis$species_term2gene

C_acnes_term2gene_ribosome <- C_acnes_term2gene %>% dplyr::filter(from == "map03010")

C_acnes_Sc_Ch_volcano_keyvals_color <- ifelse( C_acnes_Sc_Ch_DE_results_shrunken$propan_clusterID %in% C_acnes_term2gene_ribosome$to,'red', 'black')

C_acnes_Sc_Ch_volcano_keyvals_color[is.na(C_acnes_Sc_Ch_volcano_keyvals_color)] <- 'black'
names(C_acnes_Sc_Ch_volcano_keyvals_color)[C_acnes_Sc_Ch_volcano_keyvals_color == 'red'] <- 'Ribosome'


#https://stackoverflow.com/questions/74205581/show-the-volcano-plot-points-with-colour-above-the-others-in-background-with-ggp
#Warning: the vector for the lab= argument must match the order of the rownames in the results
EnhancedVolcano(C_acnes_Sc_Ch_DE_results_shrunken,
                lab = NA, #C_acnes_Sc_Ch_DE_results_shrunken$propan_clusterID, 
                title = "Cutibacterium acnes transcripts, Sc vs Ch",
                x='log2FoldChange',
                y='padj',
                #selectLab = c('cluster_1501', 'cluster_1490', 'cluster_1674'),
                #boxedLabels = TRUE,
                #drawConnectors = TRUE,
                labSize = 3.0,
                labFace = 'bold',
                pCutoff = 0.05,
                FCcutoff=0,
                colCustom = C_acnes_Sc_Ch_volcano_keyvals_color)


ggsave(filename="../plots/DESeq_taxa/C_acnes_Sc_Ch_DE_volcano.pdf",
       plot=last_plot(),
       height = 8, width = 10)

```

Plot a Volcano plot for S epidermidis Tw vs Ch.

```{r}

S_epi_mtx_bt2_pangenome_counts <- lapply(mtx_bt2_pangenome_counts, function(x){
  
  output <-  calculate_species_TPM(x, species="Staphylococcus_epidermidis")
  
  return(output)
  
}) %>% do.call("rbind",.)


S_epi_mtx_bt2_pangenome_counts <- merge(S_epi_mtx_bt2_pangenome_counts, mtx_stats_chosen %>% dplyr::select(LIBID,region), by ="LIBID")

S_epi_mtx_cluster_counts <- S_epi_mtx_bt2_pangenome_counts %>% 
  dplyr::select(LIBID, propan_clusterID, unpaired_read_count_sum)

#convert to input list
S_epi_mtx_cluster_counts_list <- split(S_epi_mtx_cluster_counts, 
                                                  f=S_epi_mtx_cluster_counts$LIBID)




#count threshold differ from C_acnes due to lower abundance
S_epi_Ch_Tw_DE_QC <- QC_bacteria_RNA_sites(list_of_counts = S_epi_mtx_cluster_counts_list,
                                                  species="Staphylococcus_epidermidis",
                                                  site="Ch", ref_site="Tw",
                                                  count_threshold = 150000,
                                                  shared_individuals_bet_sites=TRUE)

S_epi_Ch_Tw_DE_QC[["PCA_plot"]]


# Not enough S epi on scalp for a good comparison
#S_epi_Sc_Tw_DE_QC <- QC_bacteria_RNA_sites(list_of_counts = S_epi_mtx_cluster_counts_list,
#                                                  species="Staphylococcus_epidermidis",
#                                                  site="Sc", ref_site="Tw",
#                                                  count_threshold = 150000,
#                                                  shared_individuals_bet_sites=FALSE)

#S_epi_Sc_Tw_DE_QC[["PCA_plot"]]

#
S_epi_Ch_Tw_DE_analysis <- compare_bacteria_RNA_sites(list_of_counts = S_epi_mtx_cluster_counts_list,
                                                        species_anno=S_epi_anno, 
                                                        species_pangene_names = S_epi_pangene_names,
                                                  species="Staphylococcus_epidermidis",
                                                  site="Ch", ref_site="Tw",
                                                  count_threshold = 150000, #200000 only yields 4 cheek samples
                                                  shared_individuals_bet_sites=TRUE)

boxplot(S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$vsd_mat, 
         xlab="", 
         ylab="VST counts")


plotDispEsts(S_epi_Ch_Tw_DE_analysis[["species_site_filt_DESeq"]]$dds)

DESeq2::plotMA(S_epi_Ch_Tw_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken)


summary(S_epi_Ch_Tw_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken)

#check the DE results 
S_epi_Ch_Tw_DE_results_shrunken <- S_epi_Ch_Tw_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken_df

S_epi_Ch_Tw_DE_results_shrunken <- merge(S_epi_Ch_Tw_DE_results_shrunken, S_epi_anno, by = "propan_clusterID")

S_epi_Ch_Tw_DE_results_shrunken_signif <- S_epi_Ch_Tw_DE_results_shrunken %>% dplyr::filter(padj < 0.05)

#S_epi_Ch_Tw_DE_analysis$species_site_DE_KEGG_upreg_df

#S_epi_Ch_Tw_DE_analysis$species_site_DE_KEGG_downreg_df


S_epi_Ch_Tw_DE_GSEA_GO_MF <- GSEA_from_DESeq(genelist = S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_epi_GO_term2gene %>% dplyr::filter(from %in% GO_MF_term2name$from ),
                                         term2name = GO_MF_term2name)



#GSEA analysis for KEGG
#no term enriched under specific pvalueCutoff...
S_epi_Ch_Tw_DE_GSEA_KEGG <- GSEA_from_DESeq(genelist = S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_epi_Ch_Tw_DE_analysis$species_term2gene,
                                         term2name = KEGG_term2name)



#GSEA using GO (MF)

S_epi_GO_term2gene <- make_custom_term2gene_df(input_annot = eight_skin_bact_proteins_emapper_annot %>% 
                                           dplyr::filter(species=="Staphylococcus_epidermidis"), annotation_used = "GO")

#No term enriched under specific pvalue cut off...
S_epi_Ch_Tw_DE_GSEA_GO_MF <- GSEA_from_DESeq(genelist = S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_epi_GO_term2gene %>% dplyr::filter(from %in% GO_MF_term2name$from ),
                                         term2name = GO_MF_term2name)

#GSEA using GO (BP)
#No term enriched under specific pvalue cut off...
S_epi_Ch_Tw_DE_GSEA_GO_BP <- GSEA_from_DESeq(genelist = S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_epi_GO_term2gene %>% dplyr::filter(from %in% GO_BP_term2name$from ),
                                         term2name = GO_BP_term2name)

#GSEA using GO (CC)
#5 genes related to cell wall structure enriched in Tw relative to Ch, but small number of genes
#not very interesting
S_epi_Ch_Tw_DE_GSEA_GO_CC <- GSEA_from_DESeq(genelist = S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_epi_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_epi_GO_term2gene %>% dplyr::filter(from %in% GO_CC_term2name$from ),
                                         term2name = GO_CC_term2name)

clusterProfiler::dotplot(S_epi_Ch_Tw_DE_GSEA_GO_CC, showCategory=10, split=".sign") + facet_grid(.~.sign)

make_NES_barplot(S_epi_Ch_Tw_DE_GSEA_GO_CC@result, title= "S epidermidis transcripts, Ch vs Tw")

#clusterProfiler::dotplot(test, showCategory=10, split=".sign") + facet_grid(.~.sign)

#test2 <- test@result

#test3 <- S_epi_Tw_Ch_DE_analysis$species_site_filt_DESeq$selected_metadata
```




```{r eval=FALSE}
#S capitis
S_cap_mtx_bt2_pangenome_counts <- lapply(mtx_bt2_pangenome_counts, function(x){
  
  output <-  calculate_species_TPM(x, species="Staphylococcus_capitis")
  
  return(output)
  
}) %>% do.call("rbind",.)

S_cap_mtx_bt2_pangenome_counts <- merge(S_cap_mtx_bt2_pangenome_counts, mtx_stats_chosen %>% dplyr::select(LIBID,region), by ="LIBID")

S_cap_mtx_cluster_counts <- S_cap_mtx_bt2_pangenome_counts %>% 
  dplyr::select(LIBID, propan_clusterID, unpaired_read_count_sum)

#convert to input list
S_cap_mtx_cluster_counts_list <- split(S_cap_mtx_cluster_counts, 
                                                  f=S_cap_mtx_cluster_counts$LIBID)

S_cap_Sc_Ch_DE_QC <- QC_bacteria_RNA_sites(list_of_counts = S_cap_mtx_cluster_counts_list,
                                                  species="Staphylococcus_capitis",
                                                  site="Sc", ref_site="Ch",
                                                  count_threshold = 200000,
                                                  shared_individuals_bet_sites=FALSE)

S_cap_Sc_Ch_DE_QC[["PCA_plot"]]

S_cap_Sc_Ch_DE_analysis <- compare_bacteria_RNA_sites(list_of_counts = S_cap_mtx_cluster_counts_list,
                                                        species_anno=S_capitis_anno, 
                                                        species_pangene_names = S_capitis_pangene_names,
                                                  species="Staphylococcus_capitis",
                                                  site="Sc", ref_site="Ch",
                                                  count_threshold = 200000,
                                                  shared_individuals_bet_sites=FALSE)

boxplot(S_cap_Sc_Ch_DE_analysis$species_site_filt_DESeq$vsd_mat, 
         xlab="", 
         ylab="VST counts")


plotDispEsts(S_cap_Sc_Ch_DE_analysis[["species_site_filt_DESeq"]]$dds)

DESeq2::plotMA(S_cap_Sc_Ch_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken)

#Generally just low counts..
summary(S_cap_Sc_Ch_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken)


S_cap_Sc_Ch_DE_GSEA <- GSEA_from_DESeq(genelist = S_cap_Sc_Ch_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_cap_Sc_Ch_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_cap_Sc_Ch_DE_analysis$species_term2gene,
                                         term2name = KEGG_term2name)


#make_NES_barplot(S_cap_Sc_Ch_DE_GSEA@result, title= "nani")

```

S capitis Sc vs Tw

```{r}
#Need to lower count threshold to 100000 to accomodate more samples?

S_cap_Sc_Tw_DE_QC <- QC_bacteria_RNA_sites(list_of_counts = S_cap_mtx_cluster_counts_list,
                                                  species="Staphylococcus_capitis",
                                                  site="Sc", ref_site="Tw",
                                                  count_threshold = 150000,
                                                  shared_individuals_bet_sites=TRUE)

S_cap_Sc_Tw_DE_QC[["PCA_plot"]]


S_cap_Sc_Tw_DE_analysis <- compare_bacteria_RNA_sites(list_of_counts = S_cap_mtx_cluster_counts_list,
                                                        species_anno=S_capitis_anno, 
                                                        species_pangene_names = S_capitis_pangene_names,
                                                  species="Staphylococcus_capitis",
                                                  site="Sc", ref_site="Tw",
                                                  count_threshold = 150000,
                                                  shared_individuals_bet_sites=TRUE)

boxplot(S_cap_Sc_Tw_DE_analysis$species_site_filt_DESeq$vsd_mat, 
         xlab="", 
         ylab="VST counts")


plotDispEsts(S_cap_Sc_Tw_DE_analysis[["species_site_filt_DESeq"]]$dds)

DESeq2::plotMA(S_cap_Sc_Tw_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken)

summary(S_cap_Sc_Tw_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken)


#GSEA using KEGG
S_cap_Sc_Tw_DE_GSEA_KEGG <- GSEA_from_DESeq(genelist = S_cap_Sc_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_cap_Sc_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_cap_Sc_Tw_DE_analysis$species_term2gene,
                                         term2name = KEGG_term2name)


clusterProfiler::dotplot(S_cap_Sc_Tw_DE_GSEA_KEGG, showCategory=10, split=".sign") + facet_grid(.~.sign)


make_NES_barplot(S_cap_Sc_Tw_DE_GSEA_KEGG@result, title= "S capitis transcripts, Sc vs Tw")


#GSEA using GO (MF)

S_cap_GO_term2gene <- make_custom_term2gene_df(input_annot = eight_skin_bact_proteins_emapper_annot %>% 
                                           dplyr::filter(species=="Staphylococcus_capitis"), annotation_used = "GO")


S_cap_Sc_Tw_DE_GSEA_GO_MF <- GSEA_from_DESeq(genelist = S_cap_Sc_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_cap_Sc_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_cap_GO_term2gene %>% dplyr::filter(from %in% GO_MF_term2name$from ),
                                         term2name = GO_MF_term2name)


clusterProfiler::dotplot(S_cap_Sc_Tw_DE_GSEA_GO_MF, showCategory=20, split=".sign") + facet_grid(.~.sign)


test <- S_cap_Sc_Tw_DE_GSEA_GO_MF@result


#GSEA using GO (BP)

S_cap_Sc_Tw_DE_GSEA_GO_BP <- GSEA_from_DESeq(genelist = S_cap_Sc_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_cap_Sc_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_cap_GO_term2gene %>% dplyr::filter(from %in% GO_BP_term2name$from ),
                                         term2name = GO_BP_term2name)


clusterProfiler::dotplot(S_cap_Sc_Tw_DE_GSEA_GO_BP, showCategory=20, split=".sign") + facet_grid(.~.sign)

test2 <- S_cap_Sc_Tw_DE_GSEA_GO_BP@result

```


S capitis Ch vs Tw has few differentially changing features

```{r eval=FALSE}

S_cap_Ch_Tw_DE_QC <- QC_bacteria_RNA_sites(list_of_counts = S_cap_mtx_cluster_counts_list,
                                                  species="Staphylococcus_capitis",
                                                  site="Ch", ref_site="Tw",
                                                  count_threshold = 150000,
                                                  shared_individuals_bet_sites=FALSE)

S_cap_Ch_Tw_DE_QC[["PCA_plot"]]


S_cap_Ch_Tw_DE_analysis <- compare_bacteria_RNA_sites(list_of_counts = S_cap_mtx_cluster_counts_list,
                                                        species_anno=S_capitis_anno, 
                                                        species_pangene_names = S_capitis_pangene_names,
                                                  species="Staphylococcus_capitis",
                                                  site="Ch", ref_site="Tw",
                                                  count_threshold = 150000,
                                                  shared_individuals_bet_sites=FALSE)

boxplot(S_cap_Ch_Tw_DE_analysis$species_site_filt_DESeq$vsd_mat, 
         xlab="", 
         ylab="VST counts")


plotDispEsts(S_cap_Ch_Tw_DE_analysis[["species_site_filt_DESeq"]]$dds)

DESeq2::plotMA(S_cap_Ch_Tw_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken)

summary(S_cap_Ch_Tw_DE_analysis[["species_site_filt_DESeq"]]$DE_results_shrunken)


#GSEA using KEGG
S_cap_Ch_Tw_DE_GSEA_KEGG <- GSEA_from_DESeq(genelist = S_cap_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_cap_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_cap_Ch_Tw_DE_analysis$species_term2gene,
                                         term2name = KEGG_term2name)


clusterProfiler::dotplot(S_cap_Ch_Tw_DE_GSEA_KEGG, showCategory=10, split=".sign") + facet_grid(.~.sign)


make_NES_barplot(S_cap_Ch_Tw_DE_GSEA_KEGG@result, title= "S capitis transcripts, Ch vs Tw")


#GSEA using GO (MF)

S_cap_GO_term2gene <- make_custom_term2gene_df(input_annot = eight_skin_bact_proteins_emapper_annot %>% 
                                           dplyr::filter(species=="Staphylococcus_capitis"), annotation_used = "GO")


S_cap_Ch_Tw_DE_GSEA_GO_MF <- GSEA_from_DESeq(genelist = S_cap_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_cap_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_cap_GO_term2gene %>% dplyr::filter(from %in% GO_MF_term2name$from ),
                                         term2name = GO_MF_term2name)


clusterProfiler::dotplot(S_cap_Ch_Tw_DE_GSEA_GO_MF, showCategory=20, split=".sign") + facet_grid(.~.sign)


test <- S_cap_Ch_Tw_DE_GSEA_GO_MF@result


#GSEA using GO (BP)

S_cap_Ch_Tw_DE_GSEA_GO_BP <- GSEA_from_DESeq(genelist = S_cap_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = S_cap_Ch_Tw_DE_analysis$species_site_filt_DESeq$DE_results_shrunken_df$propan_clusterID,
                                         term2gene = S_cap_GO_term2gene %>% dplyr::filter(from %in% GO_BP_term2name$from ),
                                         term2name = GO_BP_term2name)


clusterProfiler::dotplot(S_cap_Ch_Tw_DE_GSEA_GO_BP, showCategory=20, split=".sign") + facet_grid(.~.sign)

test2 <- S_cap_Ch_Tw_DE_GSEA_GO_BP@result

```


# S hominis insufficiently distributed for fair comparisons
```{r eval=FALSE}
S_hom_mtx_bt2_pangenome_counts <- lapply(mtx_bt2_pangenome_counts, function(x){
  
  output <-  calculate_species_TPM(x, species="Staphylococcus_hominis")
  
  return(output)
  
}) %>% do.call("rbind",.)

S_hom_mtx_bt2_pangenome_counts <- merge(S_hom_mtx_bt2_pangenome_counts, mtx_stats_chosen %>% dplyr::select(LIBID,region), by ="LIBID")

S_hom_mtx_cluster_counts <- S_hom_mtx_bt2_pangenome_counts %>% 
  dplyr::select(LIBID, propan_clusterID, unpaired_read_count_sum)

#convert to input list
S_hom_mtx_cluster_counts_list <- split(S_hom_mtx_cluster_counts, 
                                                  f=S_hom_mtx_cluster_counts$LIBID)


S_hom_Vf_Tw_DE_QC <- QC_bacteria_RNA_sites(list_of_counts = S_hom_mtx_cluster_counts_list,
                                                  species="Staphylococcus_hominis",
                                                  site="Vf", ref_site="Tw",
                                                  count_threshold = 200000,
                                                  shared_individuals_bet_sites=FALSE)
S_hom_Vf_Tw_DE_QC[["PCA_plot"]]

```

S epi Tw vs Ch volcano plotting

```{r}
S_epi_term2gene <- S_epi_Tw_Ch_DE_analysis$species_term2gene

#Color the points that correspond to "Citrate cycle (TCA cycle)" - map00020
S_epi_term2gene_TCA <- S_epi_term2gene %>% dplyr::filter(from == "map00020")
#Color points corresponding to "Glycerolipid metabolism" - map00561 
S_epi_term2gene_Glycerolipid <- S_epi_term2gene %>% dplyr::filter(from == "map00561")

S_epi_Tw_Ch_volcano_keyvals_color <- ifelse(S_epi_Tw_Ch_DE_results_shrunken$propan_clusterID %in% S_epi_term2gene_TCA$to,'red', 
ifelse(S_epi_Tw_Ch_DE_results_shrunken$propan_clusterID %in% S_epi_term2gene_Glycerolipid$to, "gold",
                                            'black'))

S_epi_Tw_Ch_volcano_keyvals_color[is.na(S_epi_Tw_Ch_volcano_keyvals_color)] <- 'black'
names(S_epi_Tw_Ch_volcano_keyvals_color)[S_epi_Tw_Ch_volcano_keyvals_color == 'red'] <- 'TCA cycle'
names(S_epi_Tw_Ch_volcano_keyvals_color)[S_epi_Tw_Ch_volcano_keyvals_color == 'gold'] <- 'Glycerolipid metabolism'

#https://stackoverflow.com/questions/74205581/show-the-volcano-plot-points-with-colour-above-the-others-in-background-with-ggp
#Warning: the vector for the lab= argument must match the order of the rownames in the results
EnhancedVolcano(S_epi_Tw_Ch_DE_results_shrunken,
                lab = S_epi_Tw_Ch_DE_results_shrunken$propan_clusterID,
                title = "Staphylococcus epidermidis transcripts, Tw vs Ch",
                x='log2FoldChange',
                y='padj',
                selectLab = c('cluster_11604','cluster_2378','cluster_2778','cluster_128', 'cluster_1746', 'cluster_2264', 'cluster_624',
                              'cluster_16312', 'cluster_1041', 'cluster_989','cluster_1658'),
                #boxedLabels = TRUE,
                drawConnectors = TRUE,
                labSize = 3.0,
                labFace = 'bold',
                pCutoff = 0.05,
                FCcutoff=0,
                colCustom = S_epi_Tw_Ch_volcano_keyvals_color)


ggsave(filename="../plots/DESeq_taxa/S_epi_Tw_Ch_DE_volcano.pdf",
       plot=last_plot(),
       height = 8, width = 10)




```


############

## Malassezia DE analysis with salmon

Fungal DE analysis

Salmon DESeq2 analysis for Malassezia. See 04 notebook (27/01/2023)

https://bioconductor.org/packages/devel/bioc/vignettes/tximport/inst/doc/tximport.html

Process quant.sf files with tximport.

We need to create a two column dataframe linking transcript id (column 1) to gene id (column 2)



```{r}

Malassezia_salmon_files <- file.path("../data/Malassezia_mtx_mapping", paste0(mtx_to_pull, "_quant.sf"))

names(Malassezia_salmon_files) <- mtx_to_pull

Malassezia_txi.salmon <- tximport(Malassezia_salmon_files, type="salmon", tx2gene=Malassezia_tx2gene)

Malassezia_count_matrix <- Malassezia_txi.salmon$counts

#Convert to matrix of integers
  
Malassezia_integer_count_matrix <- round(Malassezia_count_matrix)
mode(Malassezia_integer_count_matrix) <- "integer"
#write.table(Malassezia_integer_count_matrix, file="../data/Malassezia_integer_count_matrix.txt", row.names=TRUE, col.names=TRUE)

Malassezia_TPM_matrix <- Malassezia_txi.salmon$abundance
#write.table(Malassezia_TPM_matrix, file="../data/Malassezia_TPM_matrix.txt", row.names=TRUE, col.names=TRUE)

#We need to generate a custom term2gene dataframe specific to M restricta 

M_res_term2gene <- get_Malassezia_term2gene_df(species="Malassezia_restricta")
M_res_term2gene <- M_res_term2gene %>% dplyr::filter(!from %in% c(KEGG_hum_disease_pathways$map_ID,
                                               KEGG_org_sys_pathways$map_ID))

MGL_term2gene <- get_Malassezia_term2gene_df(species="Malassezia_globosa")
MGL_term2gene <- MGL_term2gene %>% dplyr::filter(!from %in% c(KEGG_hum_disease_pathways$map_ID,
                                               KEGG_org_sys_pathways$map_ID))



```
What are the Malassezia clusters that are expressed by a majority of Malassezia spp on scalp and cheeks

Majority: expressed by >= 50% of Malassezia globosa/restricta at site. At least 10 reads

```{r eval=FALSE}

categorize_expression_per_group_from_site_matrix <- function(count_matrix, TPM_matrix, expressed_prevalence_cutoff=50){
  
  count_df <- melt(count_matrix, value.name = "read_count") %>% dplyr::rename(gene=Var1,LIBID=Var2)
  TPM_df <- melt(TPM_matrix, value.name = "TPM") %>% dplyr::rename(gene=Var1,LIBID=Var2)
  
  count_TPM_df <- merge(count_df, TPM_df, by=c("gene", "LIBID"))
  
  median_TPM_df <- count_TPM_df %>% group_by(gene) %>% summarise(median_TPM=median(TPM)) %>% ungroup(.)
  
  #count the number of individuals per site
  
  species_individual_site_freq <- length(unique(count_df$LIBID))
  
  df_expressed <- count_TPM_df %>% dplyr::filter(read_count >=10)
  
  #expressed freq is the number of unique individuals for which  expression was detected
  df_expressed_freq_by_site <- plyr::count(df_expressed, vars ="gene") %>% dplyr::rename(expressed_freq=freq)
  
  df_expressed_freq_by_site$expressed_prevalence <- (df_expressed_freq_by_site$expressed_freq/species_individual_site_freq)*100
  
  df_expressed_majority_by_site <- df_expressed_freq_by_site %>% dplyr::filter(expressed_prevalence > expressed_prevalence_cutoff)
                                                      
  df_expressed_majority_by_site <- merge(df_expressed_majority_by_site, median_TPM_df, by = "gene", all.x=TRUE)
  return(df_expressed_majority_by_site)
  
}

#For Malassezia restricta

M_res_Sc_count_matrix <- Malassezia_count_matrix[grep("DNF",row.names(Malassezia_count_matrix)),mtx_Sc_ids]

M_res_Ch_count_matrix <- Malassezia_count_matrix[grep("DNF",row.names(Malassezia_count_matrix)),mtx_Ch_ids]


M_res_Sc_TPM_matrix <- Malassezia_TPM_matrix[grep("DNF",row.names(Malassezia_TPM_matrix)),mtx_Sc_ids]

M_res_Ch_TPM_matrix <- Malassezia_TPM_matrix[grep("DNF",row.names(Malassezia_TPM_matrix)),mtx_Ch_ids]



####



M_res_Ch_mtx_majority <- categorize_expression_per_group_from_site_matrix(count_matrix = M_res_Ch_count_matrix,
                                                                          TPM_matrix = M_res_Ch_TPM_matrix)
M_res_Ch_mtx_majority <- merge(M_res_Ch_mtx_majority, M_res_gtf_annots, by = "gene", all.x=TRUE)

```



# Look at Malassezia restricta comparisons between Scalp and Ch (DESeq analysis)


Select Scalp and Cheek samples with a threshold kraken2 count of Malassezia restricta

```{r}

mtx_Sc_Ch_libs <- mtx_stats_chosen %>% dplyr::filter(region %in% c("Sc","Ch")) %>% pull(LIBID)

M_res_Sc_Ch_count_matrix <- Malassezia_count_matrix[grep("DNF",row.names(Malassezia_count_matrix)),
                                                    mtx_Sc_Ch_libs]


M_restricta_Sc_Ch <- lapply(rna_k2_minimizer[mtx_Sc_Ch_libs], function(df){
  
  output <- df %>% dplyr::filter(k2_taxon == "Malassezia_restricta") %>% dplyr::rename(LIBID=mtx_LIBID)
  
  output <- merge(output, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
  return(output)
  
}) %>% do.call("rbind",.)

#select those with a minimum M restricta read threshold by K2.


M_restricta_Sc_Ch_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = M_res_Sc_Ch_count_matrix,
                                                           lib_vec=M_restricta_Sc_Ch %>% dplyr::filter(paired_counts >= 200000) %>% pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Ch",
                                                           run_test = FALSE,
                                                           species="Malassezia_restricta")

plotPCA(M_restricta_Sc_Ch_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))


```
Some outliers for cheeks: MHS396 and MHS418 (SMT005_Ch) and MHS399 (SMT027_Sc) for scalp. Remove them from the DESeq analysis? 

Update: The advice is to not remove from DESeq analysis

```{r eval=FALSE}

M_restricta_Sc_Ch_filt_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = M_res_Sc_Ch_count_matrix,
                                                           lib_vec=M_restricta_Sc_Ch %>% 
                                                             dplyr::filter(paired_counts >= 200000) %>% 
                                                             dplyr::filter(!LIBID %in% c("MHS396","MHS399","MHS418")) %>%
                                                             pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Ch",
                                                           run_test = FALSE,
                                                           species="Malassezia_restricta")


plotPCA(M_restricta_Sc_Ch_filt_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))


```
As you can see, substantial inter individual heterogeneity within Ch and Sc, but the two sites have a distinct M res transcriptome.

MHS396 is also an outlier for cheeks.

https://support.bioconductor.org/p/104500/
Caveat: Using lfcThreshold is testing against an LFC threshold of 0.5, which is not the same as asking for which genes the estimated LFC is larger than 0.5

Feedback: Suggested to not filter away the libraries anyway, apart from keeping a minimum count threshold. But in case we need to reverse this change, the original filter was
lib_vec=M_restricta_Sc_Ch %>%  dplyr::filter(paired_counts >= 200000) %>% dplyr::filter(!LIBID %in% c("MHS328","MHS396","MHS399","MHS418")) %>%  pull(LIBID)

```{r}

M_restricta_Sc_Ch_filt_DESeq <- run_DESeq_with_salmon_matrix(input_matrix = M_res_Sc_Ch_count_matrix,
                                                           lib_vec=M_restricta_Sc_Ch %>% 
                                                             dplyr::filter(paired_counts >= 200000) %>%  pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Ch",
                                                           run_test = TRUE,
                                                           species="Malassezia_restricta")

plotDispEsts(M_restricta_Sc_Ch_filt_DESeq[["dds"]])

DESeq2::plotMA(M_restricta_Sc_Ch_filt_DESeq[["DE_results_shrunken"]])


summary(M_restricta_Sc_Ch_filt_DESeq[["DE_results_shrunken"]])

M_restricta_Sc_Ch_DE_res <- M_restricta_Sc_Ch_filt_DESeq[["DE_results_shrunken_df"]] %>% dplyr::rename(feature=gene)
```
M_restricta_Sc_Ch_DE_res 

Distribution of known and unknown function genes (sorted). baseMean or l2fc on X axis, y axis freq?

baseMean, is a just the average of the normalized count values, dividing by size factors, taken over all samples

Let "unknown" proteins be uncharacterized protein and hypothetical protein in proteinID

Can also do for genes in the secretory pathway (signal P prediction) 

```{r}

M_restricta_Sc_Ch_DE_res_annot <- merge(M_restricta_Sc_Ch_DE_res,
                                        M_res_gtf_annots %>% dplyr::rename(feature=gene), 
                                        by = "feature")

M_restricta_Sc_Ch_DE_res_annot$unknown_function <- ifelse(M_restricta_Sc_Ch_DE_res_annot$proteinID %in% 
                                                            c("uncharacterized protein","hypothetical protein"),
                                                          TRUE,FALSE)

M_restricta_Sc_Ch_DE_res_annot <- merge(M_restricta_Sc_Ch_DE_res_annot, 
                                        malassezia_secretory %>% 
                                          dplyr::select(pangene,prediction) %>%
                                          dplyr::rename(feature=pangene,
                                                        signalP_prediction=prediction),
                                        by="feature", all.x=TRUE)

M_restricta_Sc_Ch_DE_res_annot$signalP_prediction <- ifelse(is.na(M_restricta_Sc_Ch_DE_res_annot$signalP_prediction),
                                                            "OTHER",M_restricta_Sc_Ch_DE_res_annot$signalP_prediction)


#https://rdrr.io/cran/ggformula/man/geom_spline.html

#Not much difference
ggplot(M_restricta_Sc_Ch_DE_res_annot, aes(log2FoldChange, color=unknown_function)) +
  geom_freqpoly(bins=1000)

ggplot(M_restricta_Sc_Ch_DE_res_annot, aes(baseMean, color=unknown_function)) +
  geom_freqpoly(bins=100)


ggplot(M_restricta_Sc_Ch_DE_res_annot, aes(log2FoldChange, color=signalP_prediction)) +
  geom_freqpoly(bins=100)

ggplot(M_restricta_Sc_Ch_DE_res_annot, aes(baseMean, color=signalP_prediction)) +
  geom_freqpoly(bins=100)


```



Over representation analysis with KEGG (Outdated, use GSEA instead of ORA).

```{r eval=FALSE}
### KEGG enrichment analysis (ORA)
#Use M_res_term2gene

M_restricta_Sc_Ch_DE_KEGG_upreg <- run_clusterprofiler(changing_df = M_restricta_Sc_Ch_DE_res %>% dplyr::filter(padj < 0.05 & log2FoldChange > 0), background_df=M_restricta_Sc_Ch_DE_res, term2gene = M_res_term2gene)


M_restricta_Sc_Ch_DE_KEGG_upreg_df <- as.data.frame(M_restricta_Sc_Ch_DE_KEGG_upreg)


M_restricta_Sc_Ch_DE_KEGG_downreg <- run_clusterprofiler(changing_df = M_restricta_Sc_Ch_DE_res %>% dplyr::filter(padj < 0.05 & log2FoldChange < 0), background_df=M_restricta_Sc_Ch_DE_res, term2gene = M_res_term2gene)


M_restricta_Sc_Ch_DE_KEGG_downreg_df <- as.data.frame(M_restricta_Sc_Ch_DE_KEGG_downreg)
```


```{r}
#Volcano plot

###Color the points that are involved in peroxisome pathway, enriched lipid pathways or both 

#points that correspond to "peroxisome" pathway - map04146
M_res_term2gene_peroxisome <- M_res_term2gene %>% dplyr::filter(from == "map04146")
#points that correspond to enriched lipid metabolic pathways
#map00565: Ether lipid metabolism
#map00564: Glycerophospholipid metabolism
#map00600: Sphingolipid metabolism

M_res_term2gene_enriched_lipid_metab <- M_res_term2gene %>% 
  dplyr::filter(from %in%  c("map00561","map00564","map00600"))

M_res_Sc_Ch_volcano_keyvals_color <- ifelse(M_restricta_Sc_Ch_DE_res$feature %in% 
                                              intersect(M_res_term2gene_peroxisome$to,M_res_term2gene_enriched_lipid_metab$to), 'green',
                                            ifelse(M_restricta_Sc_Ch_DE_res$feature %in% M_res_term2gene_peroxisome$to,'royalblue', 
                                                   ifelse(M_restricta_Sc_Ch_DE_res$feature %in% M_res_term2gene_enriched_lipid_metab$to, "gold",
                                            'black')))

M_res_Sc_Ch_volcano_keyvals_color[is.na(M_res_Sc_Ch_volcano_keyvals_color)] <- 'black'
names(M_res_Sc_Ch_volcano_keyvals_color)[M_res_Sc_Ch_volcano_keyvals_color == 'royalblue'] <- 'Peroxisome'
names(M_res_Sc_Ch_volcano_keyvals_color)[M_res_Sc_Ch_volcano_keyvals_color == 'gold'] <- 'Ether lipid/Glycerophospholipid/Sphingolipid metabolism'
names(M_res_Sc_Ch_volcano_keyvals_color)[M_res_Sc_Ch_volcano_keyvals_color == 'green'] <- 'Both'



M_restricta_volcano_gene_labels <- data.frame(gene=rownames(M_restricta_Sc_Ch_DE_res))

M_restricta_volcano_gene_labels <- merge(M_restricta_volcano_gene_labels, M_res_gtf_annots, all.x=TRUE, by ="gene")

M_restricta_volcano_gene_labels$gene_annot <- ifelse(is.na(M_restricta_volcano_gene_labels$gene_tag),
                                                     M_restricta_volcano_gene_labels$gene,
                                                     M_restricta_volcano_gene_labels$gene_tag)


EnhancedVolcano(M_restricta_Sc_Ch_DE_res,
                lab = M_restricta_volcano_gene_labels$gene_annot,
                title = "Commonly expressed Malassezia restricta transcripts, Sc vs Ch",
                x='log2FoldChange',
                y='padj',
                selectLab = c('plcN_1', 'plcN_2',
                              'plcN_3', 'plcN_4',
                              'plcN_5','plcN_6',
                              'plcN_7', 'stt4', 'pik1',
                              'Acot8','POT1', 'LACS7', 'POX2', 'PEX11B'),
                #boxedLabels = TRUE,
                drawConnectors = TRUE,
                labFace = 'bold',
                labSize = 3.0,
                pCutoff = 0.05,
                FCcutoff=0,
                colCustom = M_res_Sc_Ch_volcano_keyvals_color)

ggsave(filename="../plots/DESeq_taxa/M_restricta_Sc_Ch_DE_volcano.pdf",
       plot=last_plot(),
       height = 8, width = 10)


M_restricta_Sc_Ch_DE_res_annot <- merge(M_restricta_Sc_Ch_DE_res %>% dplyr::rename(gene=feature), M_restricta_volcano_gene_labels, by ="gene", all.x = TRUE)


# Sanity check: plot the Malassezia restricta read pair counts for the chosen libraries, separated by site.

M_restricta_Sc_Ch %>%  dplyr::filter(paired_counts >= 200000) %>% mutate(region= fct_relevel(region, "Sc", "Ch")) %>%
  
  ggplot(aes(x=region, y=paired_counts, fill=region)) + geom_boxplot() + theme_classic() + 
  ggtitle("Paired read counts for Malassezia restricta, selected libraries")
```

GSEA with KEGG and GO 

Remove irrelevant KEGG mappings for Human diseases and organismal systems

```{r}
##GSEA with KEGG

M_restricta_Sc_Ch_DE_GSEA_KEGG <- GSEA_from_DESeq(genelist = M_restricta_Sc_Ch_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
                                         gene_names = M_restricta_Sc_Ch_filt_DESeq$DE_results_shrunken_df$gene,
                                         term2gene = M_res_term2gene,
                                         term2name = KEGG_term2name)

make_NES_barplot(M_restricta_Sc_Ch_DE_GSEA_KEGG@result, title= "Malassezia restricta transcripts, Sc vs Ch")

ggsave(filename="../plots/DESeq_taxa/M_restricta_Sc_Ch_DE_NES_KEGG.pdf",
       plot=last_plot(),
       height = 8, width = 10)


##GSEA with GO

M_res_GO_term2gene <-  get_Malassezia_term2gene_df(species="Malassezia_restricta", annotation_used = "GO")

#GO, biological process

M_restricta_Sc_Ch_DE_GSEA_GO_BP <- GSEA_from_DESeq(genelist = 
M_restricta_Sc_Ch_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
gene_names = M_restricta_Sc_Ch_filt_DESeq$DE_results_shrunken_df$gene,
                                         term2gene = M_res_GO_term2gene %>% dplyr::filter(from %in% GO_BP_term2name$from ),
                                         term2name = GO_BP_term2name)

clusterProfiler::dotplot(M_restricta_Sc_Ch_DE_GSEA_GO_BP, showCategory=20, split=".sign") + facet_grid(.~.sign)


#associate with parent GO slim (metagenomes)
M_restricta_Sc_Ch_DE_GSEA_GO_BP_slim <- associate_GO_to_slim(M_restricta_Sc_Ch_DE_GSEA_GO_BP@result$ID, mode="BP")


#Plot NES for GSEA, GO BP
make_NES_barplot(M_restricta_Sc_Ch_DE_GSEA_GO_BP@result, title= "M restricta transcripts, Sc vs Ch")


#GO, molecular function

M_restricta_Sc_Ch_DE_GSEA_GO_MF <- GSEA_from_DESeq(genelist = 
M_restricta_Sc_Ch_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
gene_names = M_restricta_Sc_Ch_filt_DESeq$DE_results_shrunken_df$gene,
                                         term2gene = M_res_GO_term2gene %>% dplyr::filter(from %in% GO_MF_term2name$from ),
                                         term2name = GO_MF_term2name)

clusterProfiler::dotplot(M_restricta_Sc_Ch_DE_GSEA_GO_MF, showCategory=20, split=".sign") + facet_grid(.~.sign)


make_NES_barplot(M_restricta_Sc_Ch_DE_GSEA_GO_MF@result, title= "M restricta transcripts, Sc vs Ch")

#GO, CC

M_restricta_Sc_Ch_DE_GSEA_GO_CC <- GSEA_from_DESeq(genelist = 
M_restricta_Sc_Ch_filt_DESeq$DE_results_shrunken_df$log2FoldChange,
gene_names = M_restricta_Sc_Ch_filt_DESeq$DE_results_shrunken_df$gene,
                                         term2gene = M_res_GO_term2gene %>% dplyr::filter(from %in% GO_CC_term2name$from ),
                                         term2name = GO_CC_term2name)

clusterProfiler::dotplot(M_restricta_Sc_Ch_DE_GSEA_GO_CC, showCategory=20, split=".sign") + facet_grid(.~.sign)



```




Note: 
https://support.bioconductor.org/p/9139346/

Be sure to properly interpret the results; over-represented GO categories could then either be due to the up-regulated or down-regulated genes (or a combination thereof). If you want to deduce whether from a biological perspective a process seems to be more or less active (in the experimental group compared to the reference), you will thus need to check afterwards the (log2) fold changes of the genes belonging to a GO category.


KEGG pathway enrichment of DE genes using clusterprofiler

BgRatio stands for "background ratio", which is the ratio of genes of a specific pathway in the input list, over genes of that pathway in the universe (background list)


See lab meeting: Minghao_270423 for a good summary


Composition of human Sebum (https://www.sciencedirect.com/science/article/pii/S0022202X15525864)

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9944974/
The production of Malassezia phospholipases on the skin could result in the removal of epidermal lipids, disruption of the epidermal barrier function, and the development of seborrheic dermatitis when sebum production is constitutionally decreased (Cannizzo et al. 2007).

https://perspectivesinmedicine.cshlp.org/content/4/8/a019802.full

Malassezia are dependent on host lipids and secrete lipases and phospholipases that likely release host fatty acids.

Malassezia fungi are the only known free-living fungi to lack fatty acid synthase (Xu et al. 2007), suggesting that they obtain lipids from the host skin. The lack of a fatty acid synthase is a trait shared with some skin bacteria in the genus Corynebacterium (Tauch et al. 2005).

Scalp gene expression at the mRNA level has been demonstrated for lipase and phospholipase genes of M. globosa (Xu et al. 2007) and M. restricta (Lee et al. 2013).

########
Interestingly, the CDP-alchohol Phosphatidyltransferase appears to be for phosphatidylethanolamine (PE) biosynthesis, ethanolamine => PE
See also https://www.lipidmaps.org/resources/lipidweb/lipidweb_html/lipids/complex/pe/index.htm
https://www.genome.jp/dbget-bin/www_bfind_sub?mode=bfind&max_hit=1000&locale=en&serv=gn&dbkey=alldb&keywords=R02057&page=1 (For DNF0321)


https://www.pnas.org/doi/10.1073/pnas.0706756104
The phospholipase C entry refers to the secretory enzyme similar to Pseudomonas aeruginosa phospholipase C and not the more commonly discussed cytoplasmic phosphoinositol-specific phospholipase C

Hydrolyzes phosphatidylserine as well as phosphatidylcholine. (P aeruginosa) https://www.uniprot.org/uniprotkb/P15713/entry

######

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7374198/
Phospholipids are structural components of membranes and play many essential roles in cell biology, like membrane trafficking, membrane identity, and anchoring of membrane proteins, and also serve as signaling molecules and as precursors of signaling molecules. We found differences in the content of PC and PE, which were detected in higher concentrations than PS, phosphatidylglycerol (PG), and cardiolipin. CDP-DAG and Kennedy pathways can synthesize PE and PC (Klug and Daum, 2014). Genes associated with CDP-DAG were present in all strains, but important genes in the Kennedy pathways were not (EKI1 was absent in all strains, and CKI1 was present only in M. pachydermatis). This probably means that Malassezia strains can synthesize PE and PC only using CDP-DAG and that M. pachydermatis can synthesize PC also via the Kennedy pathway. PLC1 encodes phospholipase C, forming DG, inositol, and G3P (glycerol-3-phosphate), which can serve again as precursors for phospholipid synthesis (Henry et al., 2012). This is missing in M. sympodialis and may be related to differences observed in the metabolism of this species. However, further analyses are required to confirm this. GEP4p is involved in the dephosphorylation of PGP to PG and is apparently not present in M. pachydermatis (Henry et al., 2012), and it may be the reason why this lipid species was in fact not detected in our analysis.

#####

Ned1 is a https://en.wikipedia.org/wiki/Phosphatidate_phosphatase  phosphatidate phosphatase (PAP, EC 3.1.3.4) is a key regulatory enzyme in lipid metabolism, catalyzing the conversion of phosphatidate to diacylglycerol:[1][2]

https://www.ncbi.nlm.nih.gov/protein/AYO43060.1/
PSD -> An evolutionarily ancient mechanism for producing phosphatidylethanolamine is to decarboxylate phosphatidylserine and the enzyme catalyzing this reaction, phosphatidylserine decarboxylase

But psd2 and psd3 have redundant roles, just perhaps differential localization: https://pubmed.ncbi.nlm.nih.gov/29290583/

PE is a minor component of Malassezia restricta membranes in vitro (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7374198/ fig 1), but may be important in virulence in other eukaryotes https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5872331/

###
LSB6, stt4 and pik1 are for biosynthesis of PI4P

###
Sphingolipids, a group of lipids containing the sphingoid base, have both structural and biological functions in human epidermis. Ceramides (a type of sphingolipid), as a part of extracellular lipids in the stratum corneum, are important elements of the skin barrier and are involved in the prevention of transepidermal water loss.

https://www.nature.com/articles/s41375-021-01378-z useful paper for sphingo metab

###
https://www.sciencedirect.com/science/article/pii/S0022202X15525864
The fatty acid chain lengths of human sebum vary considerably, but are predominantly 16 and 18 carbons (stearic, C18:0, oleic, C18:1Δ9, linoleic, C18:2Δ9Δ12, palmitic, 16:0, sapienic, 16:1Δ6, and palmitoleic, C16:1Δ9, Figure 1)

Peroxisomes are essential organelles for the specialized oxidation of a wide variety of fatty acids

```{r}

M_restricta_Sc_Ch_DE_KEGG_labels<- label_enriched_KEGG(clusterprofiler_df = M_restricta_Sc_Ch_DE_KEGG_downreg_df,
                                                       DE_df = M_restricta_Sc_Ch_DE_res %>% dplyr::rename(gene=feature),
                                                       comparison="Sc_vs_Ch")



M_restricta_Sc_Ch_DE_chosen_pathways <- lapply(M_restricta_Sc_Ch_DE_KEGG_labels$genes, function(selection){
  
  output <- DE_pathway_input_for_plot(M_restricta_Sc_Ch_DE_res %>% dplyr::rename(gene=feature), 
                                      label_df = M_restricta_Sc_Ch_DE_KEGG_labels,
                                      gene_selection = selection)
  
}) %>% do.call("rbind",.)

#All of this is pre-filtered for p.adj <0.05
M_restricta_Sc_Ch_DE_chosen_pathways$increased_in <- ifelse(M_restricta_Sc_Ch_DE_chosen_pathways$log2FoldChange > 0,
                                                            "Sc", "Ch")



M_restricta_Sc_Ch_DE_chosen_pathways <- merge(M_restricta_Sc_Ch_DE_chosen_pathways, 
                                              M_res_gtf_annots, by = "gene")

#These facet plots were inspired by ocean mtx paper figure 5


M_restricta_Sc_Ch_DE_lipid_pathway_plot <-plot_pathway_facets(input_df = M_restricta_Sc_Ch_DE_chosen_pathways %>%
                                                                dplyr::filter(str_detect(.$Pathway_desc,
                                                                                        pattern="lipid|Inositol"))
                                                              )   

#map00565: Ether lipid metabolism
#map00564: Glycerophospholipid metabolism
#map00600: Sphingolipid metabolism


M_restricta_Sc_Ch_DE_lipid_pathway_plot



#Saved in ppt slide ratios.
ggsave(filename="../plots/DESeq_taxa/M_restricta_Sc_Ch_DE_lipid_pathway_plot.pdf" ,
       plot=M_restricta_Sc_Ch_DE_lipid_pathway_plot,
       height = 9, width = 12)


```

# Malassezia globosa comparisons between Scalp and cheek

```{r}

M_globosa_Sc_Ch_count_matrix <- Malassezia_count_matrix[grep("MGL",row.names(Malassezia_count_matrix)),
                                                    mtx_Sc_Ch_libs]


M_globosa_Sc_Ch <- lapply(rna_k2_minimizer[mtx_Sc_Ch_libs], function(df){
  
  output <- df %>% dplyr::filter(k2_taxon == "Malassezia_globosa") %>% dplyr::rename(LIBID=mtx_LIBID)
  
  output <- merge(output, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
  return(output)
  
}) %>% do.call("rbind",.)



M_globosa_Sc_Ch_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = M_globosa_Sc_Ch_count_matrix,
                                                           lib_vec=M_globosa_Sc_Ch %>% dplyr::filter(paired_counts >= 200000) %>% pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Ch",
                                                           run_test = FALSE,
                                                           species="Malassezia_globosa")

plotPCA(M_globosa_Sc_Ch_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))
```

The decision was taken to not remove the outliers in the PCA

```{r eval=FALSE}
##Remove outliers.

M_globosa_Sc_Ch_filt_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = Malassezia_count_matrix,
                                                           lib_vec=M_globosa_Sc_Ch %>% 
                                                             dplyr::filter(paired_counts >= 200000) %>% 
                                                             dplyr::filter(!LIBID %in% c("MHS385","MHS426","MHS432")) %>%
                                                             pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Ch",
                                                           run_test = FALSE,
                                                           species="Malassezia_globosa")


plotPCA(M_globosa_Sc_Ch_filt_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))
```

Run DESeq2

```{r}

M_globosa_Sc_Ch_filt_DESeq <- run_DESeq_with_salmon_matrix(input_matrix = M_globosa_Sc_Ch_count_matrix,
                                                           lib_vec=M_globosa_Sc_Ch %>% 
                                                             dplyr::filter(paired_counts >= 200000) %>%  pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Ch",
                                                           run_test = TRUE,
                                                           species="Malassezia_globosa")

plotDispEsts(M_globosa_Sc_Ch_filt_DESeq[["dds"]])

DESeq2::plotMA(M_globosa_Sc_Ch_filt_DESeq[["DE_results_shrunken"]])


summary(M_globosa_Sc_Ch_filt_DESeq[["DE_results_shrunken"]])

M_globosa_Sc_Ch_DE_res <- M_globosa_Sc_Ch_filt_DESeq[["DE_results_shrunken_df"]] %>% dplyr::rename(feature=gene)


#No term enriched
#test_genelist <- M_globosa_Sc_Ch_filt_DESeq$DE_results_shrunken_df$log2FoldChange
#names(test_genelist) <- as.character(M_globosa_Sc_Ch_filt_DESeq$DE_results_shrunken_df$gene)
# omit any NA values 
#test_genelist<-na.omit(test_genelist)
#sort the genelist in decreasing order.
#test_genelist <- sort(test_genelist, decreasing = TRUE)

#test_term2gene <- MGL_term2gene

#set.seed(123)
#test <- GSEA(geneList = test_genelist, TERM2GENE = test_term2gene, 
             #TERM2NAME = KEGG_term2name, eps= 0, nPermSimple=10000, seed=TRUE)

#clusterProfiler::dotplot(test, showCategory=10, split=".sign") + facet_grid(.~.sign)

#test2 <- test@result




```


Volcano plots

```{r}
##nicer volcano plot

M_globosa_Sc_Ch_volcano_gene_labels <- data.frame(gene=rownames(M_globosa_Sc_Ch_filt_DESeq[["DE_results_shrunken"]]))

#MGL_OG_annot has a duplicate label for MGL2189. Remove the row that contains the entry seed_ortholog: 208960.XP_007267230.1
#Fix the raw file some other time

MGL_OG_annot <- MGL_OG_annot %>% dplyr::filter(seed_ortholog != "208960.XP_007267230.1")

M_globosa_Sc_Ch_volcano_gene_labels <- merge(M_globosa_Sc_Ch_volcano_gene_labels, MGL_OG_annot, all.x=TRUE, by ="gene")


M_globosa_Sc_Ch_volcano_gene_labels$annot <- ifelse(is.na(M_globosa_Sc_Ch_volcano_gene_labels$annot), 
                                                    M_globosa_Sc_Ch_volcano_gene_labels$gene,
                                                    M_globosa_Sc_Ch_volcano_gene_labels$annot)


#Color the lipases

M_globosa_Sc_Ch_volcano_keyvals_color <- ifelse(str_detect(M_globosa_Sc_Ch_volcano_gene_labels$annot,
                                                           pattern= "lipase|Lipase"), 'royalblue', 'black')
                                              
names(M_globosa_Sc_Ch_volcano_keyvals_color)[M_globosa_Sc_Ch_volcano_keyvals_color == 'royalblue'] <- 'Lipases'


EnhancedVolcano(M_globosa_Sc_Ch_filt_DESeq[["DE_results_shrunken"]],
                lab = M_globosa_Sc_Ch_volcano_gene_labels$annot, 
                title = "Malassezia globosa transcripts, Sc vs Ch",
                x='log2FoldChange',
                y='padj',
                selectLab = c('MGL_1311_Secretory lipase', 'MGL_4197_Secretory lipase', 'MGL_4054_Secretory lipase'),
                drawConnectors = TRUE,
                labFace = 'bold',
                pCutoff = 0.05,
                FCcutoff=0,
                colCustom = M_globosa_Sc_Ch_volcano_keyvals_color)

ggsave(filename="../plots/DESeq_taxa/M_globosa_Sc_Ch_DE_volcano.pdf",
       plot=last_plot(),
       height = 8, width = 10)

```
KEGG enrichment

```{r}
###

### KEGG enrichment analysis 
#Use MGL_term2gene
#only two hits for W metabolism

M_globosa_Sc_Ch_DE_KEGG_upreg <- run_clusterprofiler(changing_df = M_globosa_Sc_Ch_DE_res %>% dplyr::filter(padj < 0.05 & log2FoldChange > 0), background_df=M_globosa_Sc_Ch_DE_res, term2gene = MGL_term2gene)


M_globosa_Sc_Ch_DE_KEGG_upreg_df <- as.data.frame(M_globosa_Sc_Ch_DE_KEGG_upreg)


M_globosa_Sc_Ch_DE_KEGG_downreg <- run_clusterprofiler(changing_df = M_globosa_Sc_Ch_DE_res %>% dplyr::filter(padj < 0.05 & log2FoldChange < 0), background_df=M_globosa_Sc_Ch_DE_res, term2gene = M_res_term2gene)


M_globosa_Sc_Ch_DE_KEGG_downreg_df <- as.data.frame(M_globosa_Sc_Ch_DE_KEGG_downreg)

###Look at the annotations more carefully

M_globosa_Sc_Ch_DE_res <- merge(M_globosa_Sc_Ch_DE_res %>% dplyr::rename(gene=feature), MGL_OG_annot %>% dplyr::select(c("gene", "Description", "annot")), 
                                all.x=TRUE, by = "gene")

M_globosa_Sc_Ch_DE_res$increased_in <- ifelse(M_globosa_Sc_Ch_DE_res$log2FoldChange > 0, "Sc", "Ch")



#The function will only plot those genes with padj < 0.05
M_globosa_Sc_Ch_DE_lipase_plot <-plot_custom_gene_facets(input_df = M_globosa_Sc_Ch_DE_res %>%
                                                                dplyr::filter(str_detect(.$Description,
                                                                                        pattern="Secretory lipase|^Lipase"))
                                                             )   

M_globosa_Sc_Ch_DE_lipase_plot


#ggsave(filename="../plots/DESeq_Malassezia/M_globosa_Sc_Ch_DE_lipase_plot.pdf" ,
#       plot=M_globosa_Sc_Ch_DE_lipase_plot,
#       height = 9, width = 12)

#####


```

# Look at Malassezia restricta comparisons between Cheeks and less sebaceous sites (Vf + Ac combined)

```{r}

Ch_Ac_libs <- mtx_stats_chosen %>% dplyr::filter(region %in% c("Ch","Ac")) %>% pull(LIBID)

Ch_Vf_libs <- mtx_stats_chosen %>% dplyr::filter(region %in% c("Ch","Vf")) %>% pull(LIBID)


M_restricta_Ch_Ac <- lapply(rna_k2_minimizer[Ch_Ac_libs], function(df){
  
  output <- df %>% dplyr::filter(k2_taxon == "Malassezia_restricta") %>% dplyr::rename(LIBID=mtx_LIBID)
  
  output <- merge(output, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
  return(output)
  
}) %>% do.call("rbind",.) 

M_restricta_Ch_Vf <- lapply(rna_k2_minimizer[Ch_Vf_libs], function(df){
  
  output <- df %>% dplyr::filter(k2_taxon == "Malassezia_restricta") %>% dplyr::rename(LIBID=mtx_LIBID)
  
  output <- merge(output, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
  return(output)
  
}) %>% do.call("rbind",.)


#Rbind the dfs

M_restricta_Ch_AcVf <- rbind(M_restricta_Ch_Ac, M_restricta_Ch_Vf) %>% unique(.)
M_restricta_Ch_AcVf$region_temp <- ifelse(M_restricta_Ch_AcVf$region == "Ch", "Ch", "Ac_Vf")
M_restricta_Ch_AcVf <- M_restricta_Ch_AcVf %>% dplyr::select(-region) %>% dplyr::rename(region = region_temp)


Ch_AcVf_metadata <- mtx_stats_chosen %>% dplyr::filter(LIBID %in% M_restricta_Ch_AcVf$LIBID)
Ch_AcVf_metadata$region_temp <- ifelse(Ch_AcVf_metadata$region == "Ch", "Ch", "Ac_Vf")
Ch_AcVf_metadata <- Ch_AcVf_metadata %>% dplyr::select(-region) %>% dplyr::rename(region = region_temp)

M_restricta_Ch_AcVf_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = Malassezia_count_matrix,
                                                              input_metadata = Ch_AcVf_metadata ,
                                                           lib_vec=M_restricta_Ch_AcVf %>% dplyr::filter(paired_counts >= 100000) %>% pull(LIBID),
                                                           cond="Ch",
                                                           ref_cond="Ac_Vf",
                                                           run_test = FALSE,
                                                           species="Malassezia_restricta")

plotPCA(M_restricta_Ch_AcVf_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))


M_restricta_Ch_AcVf_DESeq <- run_DESeq_with_salmon_matrix(input_matrix = Malassezia_count_matrix,
                                                           input_metadata = Ch_AcVf_metadata,
                                                           lib_vec=M_restricta_Ch_AcVf %>% dplyr::filter(paired_counts >= 100000) %>% pull(LIBID),
                                                           cond="Ch",
                                                           ref_cond="Ac_Vf",
                                                           run_test = TRUE,
                                                           species="Malassezia_restricta")



plotDispEsts(M_restricta_Ch_AcVf_DESeq[["dds"]])

DESeq2::plotMA(M_restricta_Ch_AcVf_DESeq[["DE_results_shrunken"]])


summary(M_restricta_Ch_AcVf_DESeq[["DE_results_shrunken"]])

M_restricta_Ch_AcVf_DE_res <- M_restricta_Ch_AcVf_DESeq[["DE_results_shrunken_df"]]

M_restricta_Ch_AcVf_norm_counts <- M_restricta_Ch_AcVf_DESeq[["normalized_counts"]]

```



# Look at Malassezia globosa comparisons between Scalp and Ac

```{r}
Sc_Ac_libs <- mtx_stats_chosen %>% dplyr::filter(region %in% c("Sc","Ac")) %>% pull(LIBID)

M_globosa_Sc_Ac <- lapply(rna_k2_minimizer[Sc_Ac_libs], function(df){
  
  output <- df %>% dplyr::filter(k2_taxon == "Malassezia_globosa") %>% dplyr::rename(LIBID=mtx_LIBID)
  
  output <- merge(output, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
  return(output)
  
}) %>% do.call("rbind",.)

#select those with minimum threshold of M globosa reads by K2.

M_globosa_Sc_Ac_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = Malassezia_count_matrix,
                                                           lib_vec=M_globosa_Sc_Ac %>% dplyr::filter(paired_counts >= 200000) %>% pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Ac",
                                                           run_test = FALSE,
                                                           species="Malassezia_globosa")

plotPCA(M_globosa_Sc_Ac_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))

#MHS426, MHS432, MHS385 and and MHS362 are outliers

##########################

M_restricta_Sc_Ac <- lapply(rna_k2_minimizer[Sc_Ac_libs], function(df){
  
  output <- df %>% dplyr::filter(k2_taxon == "Malassezia_restricta") %>% dplyr::rename(LIBID=mtx_LIBID)
  
  output <- merge(output, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
  return(output)
  
}) %>% do.call("rbind",.)


```

MHS426, MHS432, MHS385 and and MHS362 are outliersfor scalp and Ac. Remove them from the DESeq analysis for now.

https://pubmed.ncbi.nlm.nih.gov/27130210/
Malassezia globosa, which is associated with skin conditions such as dandruff and seborrhoeic dermatitis, possesses 13 secreted lipases.

The M. globosa family class 3 lipases were shown to be specific for mono- and diacylglycerols = 8
Again, only Lip family lipases (not the class 3 ones) showed activity on triacylglycerides = 5


```{r}

M_globosa_Sc_Ac_filt_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = Malassezia_count_matrix,
                                                           lib_vec=M_globosa_Sc_Ac %>% 
                                                             dplyr::filter(paired_counts >= 200000) %>% 
                                                             dplyr::filter(!LIBID %in% c("MHS362","MHS426", 
                                                                                         "MHS432", "MHS385")) %>%
                                                             pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Ac",
                                                           run_test = FALSE,
                                                           species="Malassezia_globosa")


plotPCA(M_globosa_Sc_Ac_filt_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))


M_globosa_Sc_Ac_filt_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = Malassezia_count_matrix,
                                                           lib_vec=M_globosa_Sc_Ac %>% 
                                                             dplyr::filter(paired_counts >= 200000) %>% 
                                                             dplyr::filter(!LIBID %in% c("MHS362","MHS426", 
                                                                                         "MHS432", "MHS385")) %>%
                                                             pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Ac",
                                                           run_test = TRUE,
                                                           species="Malassezia_globosa")



plotDispEsts(M_globosa_Sc_Ac_filt_PCA_input[["dds"]])

DESeq2::plotMA(M_globosa_Sc_Ac_filt_PCA_input[["DE_results_shrunken"]])


summary(M_globosa_Sc_Ac_filt_PCA_input[["DE_results_shrunken"]])

M_globosa_Sc_Ac_DE_res <- M_globosa_Sc_Ac_filt_PCA_input[["DE_results_shrunken_df"]]


M_globosa_Sc_Ac_DE_KEGG <- run_clusterprofiler(input_df = M_globosa_Sc_Ac_DE_res,
                                                 term2gene = MGL_term2gene)
M_globosa_Sc_Ac_DE_KEGG_df <- as.data.frame(M_globosa_Sc_Ac_DE_KEGG)

clusterProfiler::dotplot(M_globosa_Sc_Ac_DE_KEGG)


M_globosa_Sc_Ac_DE_KEGG_labels<- label_enriched_KEGG(clusterprofiler_df = M_globosa_Sc_Ac_DE_KEGG_df,
                                                       DE_df = M_globosa_Sc_Ac_DE_res,
                                                       comparison="Sc_vs_Ac")

M_globosa_Sc_Ac_DE_chosen_pathways <- lapply(unique(M_globosa_Sc_Ac_DE_KEGG_labels$genes), function(selection){
  
  output <- DE_pathway_input_for_plot(M_globosa_Sc_Ac_DE_res, 
                                      label_df = M_globosa_Sc_Ac_DE_KEGG_labels,
                                      gene_selection = selection)
  
  return(output)
  
}) %>% do.call("rbind",.)

#add eggnog annotations to M_globosa_Sc_Ac_DE_res


M_globosa_Sc_Ac_DE_res <- merge(M_globosa_Sc_Ac_DE_res, MGL_OG_annot %>% dplyr::select(c("gene", "Description", "annot")), 
                                all.x=TRUE, by = "gene")

M_globosa_Sc_Ac_DE_res$increased_in <- ifelse(M_globosa_Sc_Ac_DE_res$log2FoldChange > 0, "Sc", "Ac")

#The function will only plot those genes with padj < 0.05
M_globosa_Sc_Ac_DE_lipase_plot <-plot_custom_gene_facets(input_df = M_globosa_Sc_Ac_DE_res %>%
                                                                dplyr::filter(str_detect(.$Description,
                                                                                        pattern="Secretory lipase|^Lipase"))
                                                              )   

M_globosa_Sc_Ac_DE_lipase_plot


ggsave(filename="../plots/DESeq_Malassezia/M_globosa_Sc_Ac_DE_lipase_plot.pdf" ,
       plot=M_globosa_Sc_Ac_DE_lipase_plot,
       height = 9, width = 12)


```

# Look at Malassezia globosa comparisons between Scalp and Vf

```{r}
Sc_Vf_libs <- mtx_stats_chosen %>% dplyr::filter(region %in% c("Sc","Vf")) %>% pull(LIBID)

M_globosa_Sc_Vf <- lapply(rna_k2_minimizer[Sc_Vf_libs], function(df){
  
  output <- df %>% dplyr::filter(k2_taxon == "Malassezia_globosa") %>% dplyr::rename(LIBID=mtx_LIBID)
  
  output <- merge(output, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
  return(output)
  
}) %>% do.call("rbind",.)


M_globosa_Sc_Vf_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = Malassezia_count_matrix,
                                                           lib_vec=M_globosa_Sc_Vf %>% dplyr::filter(paired_counts >= 200000) %>% pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Vf",
                                                           run_test = FALSE,
                                                           species="Malassezia_globosa")

plotPCA(M_globosa_Sc_Vf_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))


#######
M_restricta_Sc_Vf <- lapply(rna_k2_minimizer[Sc_Vf_libs], function(df){
  
  output <- df %>% dplyr::filter(k2_taxon == "Malassezia_restricta") %>% dplyr::rename(LIBID=mtx_LIBID)
  
  output <- merge(output, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
  return(output)
  
}) %>% do.call("rbind",.)


```



MHS432 is an outlier for Scalp; MHS330, MHS337, MHS342, MHS364 for Vf. Remove them from the DESeq analysis for now.

```{r}

M_globosa_Sc_Vf_filt_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = Malassezia_count_matrix,
                                                           lib_vec=M_globosa_Sc_Vf %>% 
                                                             dplyr::filter(paired_counts >= 200000) %>% 
                                                             dplyr::filter(!LIBID %in% c("MHS330","MHS337", 
                                                                                         "MHS342", "MHS364",
                                                                                         "MHS432", "MHS385",
                                                                                         "MHS426"
                                                                                         )) %>%
                                                             pull(LIBID),
                                                           cond="Sc",
                                                           ref_cond="Vf",
                                                           run_test = FALSE,
                                                           species="Malassezia_globosa")


plotPCA(M_globosa_Sc_Vf_filt_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))

```

      

# Look at Malassezia globosa comparisons between Ac and Vf

```{r}
Ac_Vf_libs <- mtx_stats_chosen %>% dplyr::filter(region %in% c("Ac","Vf")) %>% pull(LIBID)

M_globosa_Ac_Vf <- lapply(rna_k2_minimizer[Ac_Vf_libs], function(df){
  
  output <- df %>% dplyr::filter(k2_taxon == "Malassezia_globosa") %>% dplyr::rename(LIBID=mtx_LIBID)
  
  output <- merge(output, mtx_stats_chosen %>% dplyr::select(c("LIBID","subj_region", "subject","region","low_conc")),
                  by="LIBID")
  
  return(output)
  
}) %>% do.call("rbind",.)

#select those with at least half a million M globosa reads by K2.

M_globosa_Ac_Vf_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = Malassezia_count_matrix,
                                                           lib_vec=M_globosa_Ac_Vf %>% dplyr::filter(paired_counts >= 500000) %>% pull(LIBID),
                                                           cond="Ac",
                                                           ref_cond="Vf",
                                                           run_test = FALSE,
                                                           species="Malassezia_globosa")

plotPCA(M_globosa_Ac_Vf_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE) + geom_text_repel(aes(label = name))
```


MHS432 is an outlier for Scalp  and MHS362 for Ac. Remove them from the DESeq analysis for now.

```{r}

M_globosa_Ac_Vf_filt_PCA_input <- run_DESeq_with_salmon_matrix(input_matrix = Malassezia_count_matrix,
                                                           lib_vec=M_globosa_Ac_Vf %>% 
                                                             dplyr::filter(paired_counts >= 500000) %>% 
                                                             dplyr::filter(!LIBID %in% c("MHS362","MHS342")) %>%
                                                             pull(LIBID),
                                                           cond="Ac",
                                                           ref_cond="Vf",
                                                           run_test = FALSE,
                                                           species="Malassezia_globosa")


plotPCA(M_globosa_Ac_Vf_filt_PCA_input[["vsd"]], intgroup = "region", returnData=FALSE)


```



#############

## Relating transcripts of species A (bait) to mgx abundances of species B (prey)


Get normalized microbial abundances (from bracken raw counts) in order to do an RNAseq vs normalized abundance comparison

Use bracken mgx here because we are interested in simple abundance estimation rather than more complicated minimizer analysis and TPM/CPM calculations

See fmt_bracken_input.Rmd for how bracken_count_mat was built. Contaminants and Homo_sapiens were removed.

Should shift this to another markdown file

```{r}
#https://www.metagenomics.wiki/tools/16s/norm/css
#rows are taxa and columns are samples, accepted by metagenomeSeq::newMRexperiment.
bracken_count_mat <- read.table(file="../data/kraken2/mgx_bracken_readcounts_mat", header = T, comment = '', check = F, sep = ' ')

#convert to dataframe
bracken_count_df <- as.data.frame(bracken_count_mat)

# convert read count df into a metaSeqObject (MO)
bracken_MO<- newMRexperiment(bracken_count_df)
# CSS normalization
bracken_MO_CSS  <- cumNorm(bracken_MO, p = cumNormStatFast(bracken_MO))

# convert CSS normalized data into data.frame-formatted log transformed data)
#Please note that normalized count values are not whole numbers, and they should not be renormalized (i.e. converted to relative abundances)
#Now change the CSS normalized counts to have samples for rows and taxa(variables) for columns

#note that these are normalized and log transformed
bracken_MO_CSS_df = data.frame(t(MRcounts(bracken_MO_CSS, norm=TRUE, log=TRUE)))

#with mgx_LIBIDs
bracken_MO_CSS_df_with_id <- bracken_MO_CSS_df 

bracken_MO_CSS_df_with_id$mgx_LIBID <- rownames(bracken_MO_CSS_df_with_id)

#add matching mtx_LIBID

bracken_MO_CSS_df_with_id <- merge(bracken_MO_CSS_df_with_id, mtx_mgx_stats_chosen %>% dplyr::select(mgx_LIBID,
                                                                                                     mtx_LIBID),
                                   by = "mgx_LIBID")


```

An alternative to CSS normalization is centered log ratio transform in the aldex2 package, with additional MC simulations for technical variation

https://microbiome.github.io/OMA/differential-abundance.html
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8763921/
Regarding prevalence filtering, Nearing et al. (2022) found that applying a 10% threshold for the prevalence of the taxa generally resulted in more robust results. 


"We passed the non-rarefied feature table and the corresponding sample metadata to the aldex function from the ALDEx2 R package (version 1.18.0)15 which generated Monte Carlo samples of Dirichlet distributions for each sample, using a uniform prior, performed CLR transformation of each realization."

Prevalence filtering should be done PER site, resulting in 5 separate clr transformed bracken abundance tables

aldex.clr takes a "reads" data.frame with each row being a different gene/microbe and each column represents the read count from that library

Try mc.samples = 1000 is usually sufficient

We can adopt the propr package method which computes the log-ratio transformed counts as averaged across all Monte Carlo instances. See https://academic.oup.com/gigascience/article/8/9/giz107/5572529 https://www.rdocumentation.org/packages/propr/versions/4.2.6/topics/aldex2propr
https://www.bioconductor.org/packages/devel/bioc/vignettes/ALDEx2/inst/doc/ALDEx2_vignette.html

```{r eval=FALSE}

#helper function to compute aldex clr values, averaged across all monte carlo instances

get_mean_aldex_clr <- function(counts_in,seed=123){
  
  set.seed(seed)
  
  aldex_clr_results <- aldex.clr(counts_in, mc.samples=1000, verbose = FALSE)
  
  aldex_propr_object <- aldex2propr(aldex_clr_results)
  output <- aldex_propr_object@logratio #contains the log-ratio transformed counts as averaged across all Monte Carlo instances
  
  return(output)
}

#Returning just the raw clr values

get_raw_aldex_clr <- function(counts_in,seed=123){
  
  set.seed(seed)
  
  aldex_clr_results <- aldex.clr(counts_in, mc.samples=1000, verbose = FALSE)
  
  return(aldex_clr_results)
}





#default 10% prevalence
compute_aldex_inputs <- function(df=bracken_count_df, target_prevalence=0.1){
  
  Sc_n_libs <- length(mgx_Sc_ids)
  Ch_n_libs <- length(mgx_Ch_ids)
  Ac_n_libs <- length(mgx_Ac_ids)
  Vf_n_libs <- length(mgx_Vf_ids)
  Tw_n_libs <- length(mgx_Tw_ids)
  
  #For Sc
  Sc_counts <- df %>% dplyr::select(all_of(mgx_Sc_ids))
  Sc_counts <- Sc_counts[rowSums(Sc_counts==0) < (target_prevalence*Sc_n_libs),]
  Sc_bracken_clr <- get_mean_aldex_clr(Sc_counts)
  
  #For Ch
  Ch_counts <- df %>% dplyr::select(all_of(mgx_Ch_ids))
  Ch_counts <- Ch_counts[rowSums(Ch_counts==0) < (target_prevalence*Ch_n_libs),]
  Ch_bracken_clr <- get_mean_aldex_clr(Ch_counts)
  
  #For Ac
  Ac_counts <- df %>% dplyr::select(all_of(mgx_Ac_ids))
  Ac_counts <- Ac_counts[rowSums(Ac_counts==0) < (target_prevalence*Ac_n_libs),]
  Ac_bracken_clr <- get_mean_aldex_clr(Ac_counts)
  
  #For Vf
  Vf_counts <- df %>% dplyr::select(all_of(mgx_Vf_ids))
  Vf_counts <- Vf_counts[rowSums(Vf_counts==0) < (target_prevalence*Vf_n_libs),]
  Vf_bracken_clr <- get_mean_aldex_clr(Vf_counts)
  
  #For Tw
  Tw_counts <- df %>% dplyr::select(all_of(mgx_Tw_ids))
  Tw_counts <- Tw_counts[rowSums(Tw_counts==0) < (target_prevalence*Tw_n_libs),]
  Tw_bracken_clr <- get_mean_aldex_clr(Tw_counts)

  #lst of dataframes
  
  output <- tibble::lst(Sc_bracken_clr, Ch_bracken_clr,
                        Ac_bracken_clr, Vf_bracken_clr,
                        Tw_bracken_clr)
  return(output)
   
}


compute_raw_aldex <- function(df=bracken_count_df, target_prevalence=0.1){
  
  Sc_n_libs <- length(mgx_Sc_ids)
  Ch_n_libs <- length(mgx_Ch_ids)
  Ac_n_libs <- length(mgx_Ac_ids)
  Vf_n_libs <- length(mgx_Vf_ids)
  Tw_n_libs <- length(mgx_Tw_ids)
  
  #For Sc
  Sc_counts <- df %>% dplyr::select(all_of(mgx_Sc_ids))
  Sc_counts <- Sc_counts[rowSums(Sc_counts==0) < (target_prevalence*Sc_n_libs),]
  Sc_bracken_clr <- get_raw_aldex_clr(Sc_counts)
  
  #For Ch
  Ch_counts <- df %>% dplyr::select(all_of(mgx_Ch_ids))
  Ch_counts <- Ch_counts[rowSums(Ch_counts==0) < (target_prevalence*Ch_n_libs),]
  Ch_bracken_clr <- get_raw_aldex_clr(Ch_counts)
  
  #For Ac
  Ac_counts <- df %>% dplyr::select(all_of(mgx_Ac_ids))
  Ac_counts <- Ac_counts[rowSums(Ac_counts==0) < (target_prevalence*Ac_n_libs),]
  Ac_bracken_clr <- get_raw_aldex_clr(Ac_counts)
  
  #For Vf
  Vf_counts <- df %>% dplyr::select(all_of(mgx_Vf_ids))
  Vf_counts <- Vf_counts[rowSums(Vf_counts==0) < (target_prevalence*Vf_n_libs),]
  Vf_bracken_clr <- get_raw_aldex_clr(Vf_counts)
  
  #For Tw
  Tw_counts <- df %>% dplyr::select(all_of(mgx_Tw_ids))
  Tw_counts <- Tw_counts[rowSums(Tw_counts==0) < (target_prevalence*Tw_n_libs),]
  Tw_bracken_clr <- get_raw_aldex_clr(Tw_counts)

  #lst of aldex2clr objects
  
  output <- tibble::lst(Sc_bracken_clr, Ch_bracken_clr,
                        Ac_bracken_clr, Vf_bracken_clr,
                        Tw_bracken_clr)
  return(output)
   
}




aldex_clr_values <- compute_aldex_inputs()


aldex_raw_clr_values <- compute_raw_aldex()



saveRDS(aldex_clr_values, file="../processed/aldex_clr_values.RDS")
saveRDS(aldex_raw_clr_values, file="../processed/aldex_raw_clr_values.RDS")
```


```{r eval=FALSE}
#Raw aldex for sebaceous sites (Ch + Sc)



mgx_Sc_Ch_ids <- c(mgx_Sc_ids, mgx_Ch_ids)
    
Sc_Ch_n_libs <- length(mgx_Sc_Ch_ids)

Sc_Ch_counts <- bracken_count_df %>% dplyr::select(all_of(mgx_Sc_Ch_ids))
Sc_Ch_counts <- Sc_Ch_counts[rowSums(Sc_Ch_counts==0) < (0.1*Sc_Ch_n_libs),]
Sc_Ch_bracken_clr <- get_raw_aldex_clr(Sc_Ch_counts)
  
 


```

Load in aldex clr results without running the previous code chunk

```{r}

aldex_clr_values <- readRDS("../processed/aldex_clr_values.RDS")

aldex_raw_clr_values <- readRDS("../processed/aldex_raw_clr_values.RDS") 

#add corresponding library IDs

aldex_clr_values_fmt <- lapply(names(aldex_clr_values), function(x){
  
  df_fmt <- aldex_clr_values[[x]]
  df_fmt$mgx_LIBID <- rownames(df_fmt)
  
  df_fmt <- merge(df_fmt, mtx_mgx_stats_chosen %>% dplyr::select(mgx_LIBID, mtx_LIBID), by="mgx_LIBID")
  
  return(df_fmt)
  
})

names(aldex_clr_values_fmt) <- names(aldex_clr_values)

#plotting category.. Present, absent, absent toe web


```

Load the set of extracellular or secreted proteins in the eight skin microbial pangenome dataset

https://microbiomejournal.biomedcentral.com/articles/10.1186/s40168-020-00899-6
To identify metabolites with a potential effect on Candida, Saccharomyces, Penicillium, and Aspergillus spp., we calculated Spearman’s correlations for total-sum scaling (TSS) ITS abundance and both bile acid and MicroMET profiles. To account for zero-inflation, we considered only samples with nonzero abundance of Candida albicans (5 samples). We then considered all significant correlations (p < 0.05) with an absolute correlation of at least 60%.

To identify direct or indict bacterial producers of the metabolites, total-sum scaled MGS abundances were correlated with log2 transformed metabolites abundances. Correlation was inferred using sparse partial least squared analysis (sPLS) by utilizing relevance vectors (R package mixOmics [30]).

```{r}


#Load  bacterial mtx reads

eight_skin_bact_mtx_counts <- lapply(mtx_to_pull, function(x){
    df <- read_tsv(file=paste0("../processed/mtx_species_mapping/bt2_out/RNA/",
                               x,
                               "_bt2_microbe_pangenome_aligned_filtered_cov.tsv"),
                 show_col_types = FALSE)
	  df$LIBID <- x
	  
	  return(df)
  
	
	})


names(eight_skin_bact_mtx_counts) <- mtx_to_pull

#Convert this list to a matrix, samples as columns. 

eight_skin_bact_mtx_counts_matrix <- do.call("rbind",eight_skin_bact_mtx_counts)

eight_skin_bact_mtx_counts_matrix <- pivot_wider(eight_skin_bact_mtx_counts_matrix %>% 
                        dplyr::select(pangene, unpaired_read_count, LIBID), names_from = LIBID, 
                        values_from = unpaired_read_count) %>%
                        as.data.frame()

rownames(eight_skin_bact_mtx_counts_matrix) <- eight_skin_bact_mtx_counts_matrix$pangene
  
eight_skin_bact_mtx_counts_matrix <- eight_skin_bact_mtx_counts_matrix %>% dplyr::select(-pangene) %>% as.matrix()
  
#This matrix operation is much faster than mutate_all(~replace(.,is.na(.),0)) 
eight_skin_bact_mtx_counts_matrix[is.na(eight_skin_bact_mtx_counts_matrix)] <- 0



#Malassezia mtx reads from Salmon have been loaded as Malassezia_count_matrix



```


Helper functions for gene-microbe association analyses



```{r}

###Helper function to prep inputs for heatmapping of DESeq2 normalized counts
#count_matrix: A matrix of variance stabilized normalized counts like S_epi_Ch_Tw_norm_count_mat
#Lib_vec is a vector of desired libraries like S_epi_Ch_libs
get_norm_count_inputs <- function(count_matrix, lib_vec){
  
 norm_count_df <- count_matrix[,lib_vec] %>% as.data.frame()
 norm_count_df$pangene <- rownames(norm_count_df)
 
 norm_count_df$propan_clusterID <- str_match(string=norm_count_df$pangene, 
                                                               pattern = "cluster_[0-9]*")[,1]
 
 #Collapse counts of the same cluster within libraries
 norm_count_cluster_agg_df <- norm_count_df %>% 
  dplyr::select(-pangene) %>% aggregate(.~propan_clusterID,data=.,FUN=sum)  
 
 return(norm_count_cluster_agg_df)
 
}



##Helper function to melt dataframes and rename variables for heatmapping or other downstream analyses

melt_df <- function(input_df, value_name="vsd"){
  
  df_melt  <- melt(input_df, value.name="vsd")

  df_melt <- df_melt %>% dplyr::rename(LIBID=variable)

  return(df_melt)
  
}



```

Compute spearman correlation between the variance stabilized counts for a set of genes from species A (secreted) and clr transformed abundances (not species A but core taxa). 

As described in https://www.cell.com/cell-reports-methods/pdfExtended/S2667-2375(22)00288-0 for "genome-centric metatranscriptomics", perform count normalisation and variance stabilizing transformation for each taxon.

The eight skin microbes are: S aureus, S epidermidis, S hominis, S capitis, C acnes, C modestum, Corynebacterium_tuberculostearicum and Corynebacterium_ureicelerivorans

```{r}


#species_transcriptome_name is a string that identifies a species of interest for their transcriptomes to be analyzed 
#secretory_prediction_df is the processed output of signalP v 6
#aldex_raw_clr_values[["Sc_bracken_clr"]] etc can be the aldex_clr_input 
#site_libs is a character vector 

get_mtx_vs_mgx_correlation <- function(mtx_count_matrix, aldex_clr_input, secretory_prediction_df, site_libs, 
                                       species_transcriptome_name, species_transcriptome_read_threshold=200000, 
                                       responding_species, 
                                    cor_test_method="spearman",
                                    manual_vst_nsub = FALSE){
  
  ######
  #raw counts, species specific and site specific
  count_matrix <- mtx_count_matrix[str_detect(rownames(mtx_count_matrix), pattern=species_transcriptome_name), site_libs]
  
  #pre-filtering
  #keep if above a minimum threshold of reads
  #try at least 10 samples with at least >= 20 reads
  
  transcript_threshold_check <- apply(count_matrix, MARGIN=1, function(x) sum(x>=20) ) #20 reads minimum
  
  keep_transcript <- transcript_threshold_check >= 10  #10 samples minimum
  keep_sample <- (colSums(count_matrix)>=species_transcriptome_read_threshold)
  
  count_matrix <- count_matrix[keep_transcript, keep_sample]
  

  #vst() can be called on a matrix of counts and it will also call estimateSizeFactors within the function if you have not already supplied size factors: https://www.biostars.org/p/434003/

    if (manual_vst_nsub == FALSE){
    count_matrix_vst <- vst(count_matrix, blind=FALSE)
  } else if (manual_vst_nsub == TRUE){
    count_matrix_vst <- vst(count_matrix, blind=FALSE, nsub=sum( rowMedians(count_matrix) >= 10 ))
    }
  
  #subset for proteins in the secretory pathway
  
  count_matrix_vst_secretory <- count_matrix_vst[rownames(count_matrix_vst) %in% 
                                                   secretory_prediction_df$pangene, ]
  
  pangenes_to_test <- rownames(count_matrix_vst_secretory)
  
  
  
  #prepare the species abundance inputs (clr transformed metagenomic abundances with matching mtx library ID label)
  #load all Monte Carlo instances from aldex2 and do correlation tests in a way similar to the aldexcorr function,
  #where correlation tests are done for each MC instance and an average correlation statistic and p-value are reported
  #See ?propr::aldex.cor
  #https://rdrr.io/github/tpq/propr/src/R/7-aldex2propr.R
  
  aldex_clr_MC <- getMonteCarloInstances(aldex_clr_input)
  
  #extract the species specific clr MC instances
  aldex_clr_MC_species_specific <- lapply(names(aldex_clr_MC), function(LIBID){
    
    mat_out <- aldex_clr_MC[[LIBID]][responding_species,]
    
    })
  
  names(aldex_clr_MC_species_specific) <- names(aldex_clr_MC)
  
  aldex_clr_MC_species_specific_mat <- do.call("rbind", aldex_clr_MC_species_specific)
  
  
  #Make sure that the libraries in the clr input match the filtered libraries from the mtx data
  matching_mtx_ids <- colnames(count_matrix_vst_secretory)
  
  matching_mgx_ids <- mtx_mgx_stats_chosen %>% dplyr::filter(mtx_LIBID %in% matching_mtx_ids)
  matching_mgx_ids <- matching_mgx_ids[match(matching_mtx_ids, matching_mgx_ids$mtx_LIBID), ] %>% pull(mgx_LIBID)
  
  #subset the aldex clr matrix in the order of the matching mgx_ids
  #each column is a monte carlo instance
  aldex_clr_MC_species_specific_mat_filt <- aldex_clr_MC_species_specific_mat[matching_mgx_ids,]
  
  
  if (cor_test_method=="pearson"){
    
    cor_test_coef <- "cor"
    
  } else if (cor_test_method=="spearman"){
    
    cor_test_coef <- "rho"
    
    }
    
  
  #initialize vectors to hold test results
  MC_corr_vec <- vector(mode="numeric", length=1000)
  MC_pval_vec <- vector(mode="numeric", length=1000)
  #Initialize vectors to hold final outputs
  corr_p_vals <- vector(mode="numeric", length=length(pangenes_to_test))
  corr_coeff <- vector(mode="numeric", length=length(pangenes_to_test))
  
  #For each pangene (in the secretory pathway...)
  #perform the correlation tests for each MC instance (1000 of them)
  for (i in 1:length(pangenes_to_test)){
    
    #vector of vst counts for a given pangene
    mtx_vst_vector <- count_matrix_vst_secretory[pangenes_to_test[i], matching_mtx_ids]
    
    for (j in 1:1000){
      MC_corr_results <- cor.test(aldex_clr_MC_species_specific_mat_filt[,j], mtx_vst_vector,  
                                method=cor_test_method, exact=FALSE )
    
      MC_pval_vec[j] <- MC_corr_results$p.value
      MC_corr_vec[j] <- MC_corr_results$estimate[[cor_test_coef]]
    
    }
    
    corr_p_vals[i] <- mean(MC_pval_vec)
    corr_coeff[i] <- mean(MC_corr_vec)
 
  } 
  
  corr_df <- data.frame(pangene=pangenes_to_test,
                        corr_p_vals,
                        corr_coeff,
                        species_tested_for=responding_species)
  
  corr_df$p_adj <-  p.adjust(corr_df$corr_p_vals, method="fdr")
  
  
  output <- tibble::lst(count_matrix_vst, count_matrix_vst_secretory, corr_df)
  
  return(output)
  
}

#
transcript_vs_clr_scatterplot <- function(vst_mat, mean_clr, transcript, species){
  
  
  vst_df <- t(vst_mat) %>% as.data.frame()
  
  vst_df$mtx_LIBID <- rownames(vst_df)
  
  species_mean_clr <- mean_clr %>% dplyr::select(species,"mtx_LIBID")
  
  transcript_and_clr_df <- merge(vst_df,species_mean_clr, by ="mtx_LIBID")
  
  ggscatter(transcript_and_clr_df, x = species, 
          y = transcript, add = "reg.line") + stat_cor(method="spearman") + theme_classic()
  
  
}




```  


Perform bacteria transcript vs bacteria abundance correlation testing


Test between Staph epidermidis and various toe web microbes

```{r}
S_epi_mtx_vs_C_kefir_mgx_Tw <- get_mtx_vs_mgx_correlation(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                   aldex_clr_input = aldex_raw_clr_values[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,species_transcriptome_name = "Staphylococcus_epidermidis",
  responding_species = "Corynebacterium_kefirresidentii", cor_test = "spearman",
  species_transcriptome_read_threshold=200000)

S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df <- S_epi_mtx_vs_C_kefir_mgx_Tw$corr_df

S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df$significant <- ifelse(S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df$p_adj < 0.05, 
                                                               TRUE, FALSE)

S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df$propan_clusterID <- str_match(string=S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df$pangene, 
                                                               pattern = "cluster_[0-9]*")[,1]


S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df <- merge(S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df,
                                             S_epi_anno, by="propan_clusterID")

S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df$Accession <- sapply(str_split(string=S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df$pangene, "_"), "[", 5)

S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df$label_to_use <- ifelse(S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df$`Enzyme Class`== "-",
                                                           S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df$Accession,
                                                           S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df$`Enzyme Class`)


ggplot(data=S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df, aes(y=-log10(p_adj),x=corr_coeff)) + 
  geom_point(aes(colour = factor(significant))) + theme_classic() + scale_color_manual(values=c("black","red")) + geom_hline(yintercept=-log10(0.05), linetype = "dashed") + geom_vline(xintercept=c(-0.7,0.7), linetype="dashed") +
  geom_label_repel(data=S_epi_mtx_vs_C_kefir_mgx_Tw_corr_df %>% filter(p_adj < 0.05), 
                   aes(label=label_to_use),
                   size = 3)

#KEI47701.1 is a cell surface protein
#EPP68308.1 is an iron transporter
#ESR25046.1 is a hypothetical protein, partial
#AAW53617.1 is a uncharacterized membrane protein YgdD (DUF423)


ggsave(filename="../plots/RNA_vs_microbe_abun/S_epi_mtx_vs_C_kefir_mgx_Tw_corr_volcano.pdf",
       plot=last_plot(),
       height = 5, width = 8)



#transcript_vs_clr_scatterplot(vst_mat = S_epi_mtx_vs_C_kefir_mgx_Tw$count_matrix_vst_secretory,
#                              mean_clr = aldex_clr_values_fmt[["Tw_bracken_clr"]],
#                              transcript="Staphylococcus_epidermidis_cluster_1361_AAO03605.1",
#                              species="Corynebacterium_kefirresidentii") + 
#  xlab("Mean clr (Corynebacterium_kefirresidentii)") + ylab("vst (AAO03605.1)")


#ggsave(filename="../plots/RNA_vs_microbe_abun/S_epi_AAO03605_vs_C_keffir_mgx_scatter.pdf",
#       plot=last_plot(),
#       height = 5, width = 8)


###
#Staph epidermidis vs Corynebacterium_tuberculostearicum

S_epi_mtx_vs_C_tuber_mgx_Tw <- get_mtx_vs_mgx_correlation(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                   aldex_clr_input = aldex_raw_clr_values[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,species_transcriptome_name = "Staphylococcus_epidermidis",
  responding_species = "Corynebacterium_tuberculostearicum", cor_test = "spearman",
  species_transcriptome_read_threshold=200000)

S_epi_mtx_vs_C_tuber_mgx_Tw_corr_df <- S_epi_mtx_vs_C_tuber_mgx_Tw$corr_df



###No hits between S epi and C acnes

S_epi_mtx_vs_C_acnes_mgx_Tw <- get_mtx_vs_mgx_correlation(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                   aldex_clr_input = aldex_raw_clr_values[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,species_transcriptome_name = "Staphylococcus_epidermidis",
  responding_species = "Cutibacterium_acnes", cor_test = "spearman",
  species_transcriptome_read_threshold=200000)

S_epi_mtx_vs_C_acnes_mgx_Tw_corr_df <- S_epi_mtx_vs_C_acnes_mgx_Tw$corr_df


#Control

S_epi_mtx_vs_S_epi_mgx_Tw <- get_mtx_vs_mgx_correlation(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                   aldex_clr_input = aldex_raw_clr_values[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,species_transcriptome_name = "Staphylococcus_epidermidis",
  responding_species = "Staphylococcus_epidermidis", cor_test = "spearman",
  species_transcriptome_read_threshold=200000)

S_epi_mtx_vs_S_epi_mgx_Tw_corr_df <- S_epi_mtx_vs_S_epi_mgx_Tw$corr_df


S_epi_mtx_vs_S_epi_mgx_Tw_corr_df$significant <- ifelse(S_epi_mtx_vs_S_epi_mgx_Tw_corr_df$p_adj < 0.05, 
                                                               TRUE, FALSE)

S_epi_mtx_vs_S_epi_mgx_Tw_corr_df$propan_clusterID <- str_match(string=S_epi_mtx_vs_S_epi_mgx_Tw_corr_df$pangene, 
                                                               pattern = "cluster_[0-9]*")[,1]


S_epi_mtx_vs_S_epi_mgx_Tw_corr_df <- merge(S_epi_mtx_vs_S_epi_mgx_Tw_corr_df,
                                             S_epi_anno, by="propan_clusterID")

#very similar hits between S_epi_vs_S_epi and S_epi_vs_C_kefir

#Spearman correlation between S_epi and C_kefir clr abundances
#Strongly associated
ggscatter(aldex_clr_values_fmt$Tw_bracken_clr, x = "Staphylococcus_epidermidis", 
          y = "Corynebacterium_kefirresidentii", add = "reg.line") + stat_cor(method="spearman")


transcript_vs_clr_scatterplot(vst_mat = S_epi_mtx_vs_S_epi_mgx_Tw$count_matrix_vst_secretory,
                              mean_clr = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                              transcript="Staphylococcus_epidermidis_cluster_1361_AAO03605.1",
                              species="Staphylococcus_epidermidis") + 
  xlab("Mean clr (Staphylococcus_epidermidis)") + ylab("vst (Staphylococcus_epidermidis)")

ggsave(filename="../plots/RNA_vs_microbe_abun/S_epi_AAO03605_vs_S_epi_mgx_scatter.pdf",
       plot=last_plot(),
       height = 5, width = 8)





```


Test between Staph capitis and Corynebacterium kefirresidentii on cheeks

Set read threshold to 100000 to have minimum 10 samples for correlation.

Nothing significant

```{r eval=FALSE}

S_cap_mtx_vs_C_kefir_mgx_Ch <- get_mtx_vs_mgx_correlation(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                   aldex_clr_input = aldex_raw_clr_values[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,species_transcriptome_name = "Staphylococcus_capitis",
  responding_species = "Corynebacterium_kefirresidentii", cor_test = "spearman",
  species_transcriptome_read_threshold=100000,
  manual_vst_nsub = TRUE)

S_cap_mtx_vs_C_kefir_mgx_Ch_corr_df <- S_cap_mtx_vs_C_kefir_mgx_Ch$corr_df

#

S_cap_mtx_vs_C_tuber_mgx_Ch <- get_mtx_vs_mgx_correlation(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                   aldex_clr_input = aldex_raw_clr_values[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,species_transcriptome_name = "Staphylococcus_capitis",
  responding_species = "Corynebacterium_tuberculostearicum", cor_test = "spearman",
  species_transcriptome_read_threshold=100000,
  manual_vst_nsub = TRUE)

S_cap_mtx_vs_C_tuber_mgx_Ch_corr_df <- S_cap_mtx_vs_C_tuber_mgx_Ch$corr_df


#S_cap_mtx_vs_C_keffir_mgx_Ch_corr_df <- S_cap_mtx_vs_C_keffir_mgx_Ch_v1$corr_df


#Try sebaceous sites.. (Ch + Sc)

mtx_Sc_Ch_ids <- c(mtx_Sc_ids, mtx_Ch_ids )

#Nothing
S_cap_mtx_vs_C_kefir_mgx_Sc_Ch <- get_mtx_vs_mgx_correlation(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                   aldex_clr_input = Sc_Ch_bracken_clr,
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Sc_Ch_ids,species_transcriptome_name = "Staphylococcus_capitis",
  responding_species = "Corynebacterium_kefirresidentii", cor_test = "spearman",
  species_transcriptome_read_threshold=200000,
  manual_vst_nsub = TRUE)


S_cap_mtx_vs_C_kefir_mgx_Sc_Ch_corr_df <- S_cap_mtx_vs_C_kefir_mgx_Sc_Ch$corr_df


```

Test between C acnes and C granulosum on cheeks


```{r}

##One hit to a lysophospholipase, but another hit in the opposite direction to a triacylglycerol lipase
C_acnes_mtx_vs_C_gran_mgx_Ch <- get_mtx_vs_mgx_correlation(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                   aldex_clr_input = aldex_raw_clr_values[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,species_transcriptome_name = "Cutibacterium_acnes",
  responding_species = "Cutibacterium_granulosum", cor_test = "spearman",
  species_transcriptome_read_threshold=200000,
  manual_vst_nsub = FALSE)
  
  
  
C_acnes_mtx_vs_C_gran_mgx_Ch_corr_df <- C_acnes_mtx_vs_C_gran_mgx_Ch$corr_df

C_acnes_mtx_vs_C_gran_mgx_Ch_corr_df$significant <- ifelse(C_acnes_mtx_vs_C_gran_mgx_Ch_corr_df$p_adj < 0.05, 
                                                               TRUE, FALSE)


ggplot(data=C_acnes_mtx_vs_C_gran_mgx_Ch_corr_df, aes(y=-log10(p_adj),x=corr_coeff)) + 
  geom_point(aes(colour = factor(significant))) + theme_classic() + scale_color_manual(values=c("black","red")) + geom_hline(yintercept=-log10(0.05), linetype = "dashed") + geom_vline(xintercept=c(-0.7,0.7), linetype="dashed") +
  geom_label_repel(data=C_acnes_mtx_vs_C_gran_mgx_Ch_corr_df %>% filter(p_adj < 0.05), 
                   aes(label=pangene),
                   size = 3)


ggsave(filename="../plots/RNA_vs_microbe_abun/C_acnes_mtx_vs_C_gran_mgx_Ch_corr_volcano.pdf",
       plot=last_plot(),
       height = 5, width = 8)


C_acnes_mtx_vs_C_gran_mgx_Ch_corr_df$transcripts_from <- "Cutibacterium_acnes"

write_tsv(C_acnes_mtx_vs_C_gran_mgx_Ch_corr_df, "../processed/C_acnes_mtx_vs_C_gran_mgx_Ch_corr_df.tsv")



transcript_vs_clr_scatterplot(vst_mat = C_acnes_mtx_vs_C_gran_mgx_Ch$count_matrix_vst_secretory,
                              mean_clr = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                              transcript="Cutibacterium_acnes_cluster_2293_AAT83849.1",
                              species="Cutibacterium_acnes") + 
  xlab("Mean clr (Cutibacterium_acnes)") + ylab("vst (Cutibacterium_acnes_AAT83849.1)")



ggsave(filename="../plots/RNA_vs_microbe_abun/C_acnes_AAT83849_vs_C_acnes_mgx_scatter.pdf",
       plot=last_plot(),
       height = 5, width = 8)


transcript_vs_clr_scatterplot(vst_mat = C_acnes_mtx_vs_C_gran_mgx_Ch$count_matrix_vst_secretory,
                              mean_clr = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                              transcript="Cutibacterium_acnes_cluster_2293_AAT83849.1",
                              species="Cutibacterium_granulosum") + 
  xlab("Mean clr (Cutibacterium_granulosum)") + ylab("vst (Cutibacterium_acnes_AAT83849.1)")



ggsave(filename="../plots/RNA_vs_microbe_abun/C_acnes_AAT83849_vs_C_granulosum_mgx_scatter.pdf",
       plot=last_plot(),
       height = 5, width = 8)


```
DNF11_2196 - Barwin domain containing protein, poorly annotated

https://www.uniprot.org/uniprotkb/A0A3G2S5R5/entry
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3697372/


```{r}
#Association between Malassezia restricta ("DNF") transcripts and other organismal abundances

#Why is DNF11_2196 expression negatively associated only with C acnes on scalp?

M_res_mtx_vs_C_acnes_mgx_Sc <- get_mtx_vs_mgx_correlation(mtx_count_matrix = Malassezia_integer_count_matrix,
                                              aldex_clr_input = aldex_raw_clr_values[["Sc_bracken_clr"]],
                                   secretory_prediction_df = malassezia_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "DNF",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_acnes", cor_test_method = "spearman" )


M_res_mtx_vs_C_acnes_mgx_Sc_corr_df <- M_res_mtx_vs_C_acnes_mgx_Sc$corr_df

M_res_mtx_vs_C_acnes_mgx_Sc_corr_df$significant <- ifelse(M_res_mtx_vs_C_acnes_mgx_Sc_corr_df$p_adj < 0.05, 
                                                               TRUE, FALSE)


#volcano plot derived from M_res_mtx_vs_C_acnes_mgx_Sc_corr_df

ggplot(data=M_res_mtx_vs_C_acnes_mgx_Sc_corr_df, aes(y=-log10(p_adj),x=corr_coeff)) + 
  geom_point(aes(colour = factor(significant))) + theme_classic() + scale_color_manual(values=c("black","red")) + geom_hline(yintercept=-log10(0.05), linetype = "dashed") + geom_vline(xintercept=c(-0.7,0.7), linetype="dashed") +
  geom_label_repel(data=M_res_mtx_vs_C_acnes_mgx_Sc_corr_df %>% filter(p_adj < 0.05), 
                   aes(label=pangene),
                   size = 3)


ggsave(filename="../plots/RNA_vs_microbe_abun/M_res_mtx_vs_C_acnes_mgx_Sc_corr_volcano.pdf",
       plot=last_plot(),
       height = 5, width = 8)

M_res_mtx_vs_C_acnes_mgx_Sc_corr_df$transcripts_from <- "Malassezia_restricta"

write_tsv(M_res_mtx_vs_C_acnes_mgx_Sc_corr_df, "../processed/M_res_mtx_vs_C_acnes_mgx_Sc_corr_df.tsv")



#Visualize the relationship between vst of a transcript and mean clr of an organism

transcript_vs_clr_scatterplot(vst_mat = M_res_mtx_vs_C_acnes_mgx_Sc$count_matrix_vst_secretory,
                              mean_clr = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                              transcript="DNF11_2196",
                              species="Cutibacterium_acnes") + xlab("Mean clr (Cutibacterium acnes)") + ylab("vst (DNF11_2196)")


ggsave(filename="../plots/RNA_vs_microbe_abun/M_res_DNF11_2196_vs_C_acnes_mgx_scatter.pdf",
       plot=last_plot(),
       height = 5, width = 8)


#Controls.

M_res_mtx_vs_M_res_mgx_Sc <- get_mtx_vs_mgx_correlation(mtx_count_matrix = Malassezia_integer_count_matrix,
                                              aldex_clr_input = aldex_raw_clr_values[["Sc_bracken_clr"]],
                                   secretory_prediction_df = malassezia_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "DNF",
  species_transcriptome_read_threshold=200000,
  responding_species = "Malassezia_restricta", cor_test_method = "spearman" )


M_res_mtx_vs_M_res_mgx_Sc_corr_df <- M_res_mtx_vs_M_res_mgx_Sc$corr_df


transcript_vs_clr_scatterplot(vst_mat = M_res_mtx_vs_M_res_mgx_Sc$count_matrix_vst_secretory,
                              mean_clr = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                              transcript="DNF11_2196",
                              species="Malassezia_restricta") + xlab("Mean clr (Malassezia_restricta)") + ylab("vst (DNF11_2196)")

ggsave(filename="../plots/RNA_vs_microbe_abun/M_res_DNF11_2196_vs_M_res_mgx_scatter.pdf",
       plot=last_plot(),
       height = 5, width = 8)


M_res_vs_C_acnes_mgx_to_plot <- mtx_mgx_stats_chosen %>% dplyr::filter(mtx_LIBID %in% colnames(M_res_mtx_vs_C_acnes_mgx_Sc$count_matrix_vst_secretory)) %>% pull(mgx_LIBID)

ggscatter(aldex_clr_values_fmt$Sc_bracken_clr %>% dplyr::filter(mtx_LIBID %in% colnames(M_res_mtx_vs_C_acnes_mgx_Sc$count_matrix_vst_secretory)), x = "Cutibacterium_acnes", 
          y = "Malassezia_restricta", add = "reg.line") + stat_cor(method="spearman")



ggsave(filename="../plots/RNA_vs_microbe_abun/M_res_abun_vs_C_acnes_abun_scatter.pdf",
       plot=last_plot(),
       height = 5, width = 8)


```

M restricta versus other species

```{r eval=FALSE}
####

M_res_mtx_vs_S_capitis_mgx_Sc <- get_mtx_vs_mgx_correlation(mtx_count_matrix = Malassezia_integer_count_matrix,
                                              aldex_clr_input = aldex_raw_clr_values[["Sc_bracken_clr"]],
                                   secretory_prediction_df = malassezia_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "DNF",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_capitis", cor_test_method = "spearman" )


M_res_mtx_vs_S_capitis_mgx_Sc_corr_df <- M_res_mtx_vs_S_capitis_mgx_Sc$corr_df

M_res_mtx_vs_S_capitis_mgx_Sc_corr_df$significant <- ifelse(M_res_mtx_vs_S_capitis_mgx_Sc_corr_df$p_adj < 0.05, 
                                                               TRUE, FALSE)


#####

M_res_mtx_vs_S_epidermidis_mgx_Sc <- get_mtx_vs_mgx_correlation(mtx_count_matrix = Malassezia_integer_count_matrix,
                                              aldex_clr_input = aldex_raw_clr_values[["Sc_bracken_clr"]],
                                   secretory_prediction_df = malassezia_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "DNF",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_epidermidis", cor_test_method = "spearman" )


M_res_mtx_vs_S_epidermidis_mgx_Sc_corr_df <- M_res_mtx_vs_S_epidermidis_mgx_Sc$corr_df

M_res_mtx_vs_S_epidermidis_mgx_Sc_corr_df$significant <- ifelse(M_res_mtx_vs_S_epidermidis_mgx_Sc_corr_df$p_adj < 0.05, 
                                                               TRUE, FALSE)

#

Malassezia_mtx_vs_M_glo_mgx_Sc <- get_mtx_vs_mgx_correlation(mtx_count_matrix = Malassezia_integer_count_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                   secretory_prediction_df = malassezia_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "DNF",
  species_transcriptome_read_threshold=200000,
  responding_species = "Malassezia_globosa", cor_test = "spearman" )

Malassezia_mtx_vs_M_glo_mgx_Sc_corr_df <- Malassezia_mtx_vs_M_glo_mgx_Sc$corr_df



ggscatter(Malassezia_mtx_vs_C_acnes_mgx_Sc$transcript_and_mgx_abundance_df, x = "Cutibacterium_acnes", 
          y = "DNF11_2196", add = "reg.line") + stat_cor(method="spearman")



#plot(rowMeans(Malassezia_Ch_test$count_matrix_vst), rowSds(Malassezia_Ch_test$count_matrix_vst), main='VST counts: sd vs #mean')

#boxplot(Malassezia_Ch_test$count_matrix_vst, 
#        xlab="",ylab="VST or rlog counts")


```






One can also do sparse CCA https://genomebiology.biomedcentral.com/articles/10.1186/s13059-022-02635-9#Sec10, which answers a different question than the pairwise spearman approach



Bacteriocin subtilosin A 	
Lantibiotic alpha
Phage tail protein (tailocin?)

phenol-soluble modulin beta

PSMβ from commensal Staphylococcus species (not S. aureus) are known to be non-cytolytic to human cells but possess anti-microbial activity against S. aureus.

Kumar R, Jangir PK, Das J, et al. Genome Analysis of Staphylococcus capitis TE8 Reveals Repertoire of Antimicrobial Peptides and Adaptation Strategies for Growth on Human Skin. Sci Rep 2017; 7: 10447. 2017/09/07. DOI: 10.1038/s41598-017-11020-7.

Peschel A and Otto M. Phenol-soluble modulins and staphylococcal infection. Nat Rev Microbiol 2013; 11: 667-673. 2013/09/11. DOI: 10.1038/nrmicro3110.


PSM beta from Staph can kill C. acnes as well
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7375939/





On what the normalized counts for DESeq actually are: https://support.bioconductor.org/p/76712/#76717
https://bioinformatics.stackexchange.com/questions/193/how-can-i-extract-normalized-read-count-values-from-deseq2-results

"...The normalized = TRUE argument to the count function gives you normalised counts. However, these are “only” library-size normalised (i.e. divided by the sizeFactors(dds)).

However, as the vignette explains, downstream processing generally requires more advanced normalisation, to account for the heteroscedasticity of the counts. This is often done by simply logging the counts but this has obvious drawbacks (most trivially, what do we do with 0 counts? A workaround is to add a pseudocount but that’s problematic too).

DESeq2 offers two different methods to perform a more rigorous analysis:

rlog — a regularised log, and
vst — a variance stabilising transformation.
You’d generally use either of these for downstream analysis, not count(dds, normalized = TRUE)."



See:
https://bioinformatics.stackexchange.com/questions/193/how-can-i-extract-normalized-read-count-values-from-deseq2-results
https://support.bioconductor.org/p/123969/
 https://support.bioconductor.org/p/9141213/

https://www.biostars.org/p/339065/#:~:text=Heatmap%20with%20normalised%20count%20from%20DESEQ2&text=Take%20a%20look%20at%20how,is%20scale%3D%22none%22%20



#How about a more systematic correlation search.. DESeq2 normalized counts vs CLR Staph? (Staph burden?)

https://support.bioconductor.org/p/104097/ -> DESeq2 with continuous variables.

The interpretation of the LFC is the log of the fold change in expression for one unit of the variable. There is no specific reference point, it is folded into the intercept

The author of DESeq2 recommends that we check more examples by eye, by plotting transformed (normalized counts) over the continuous variable.  The test is of linearity of log scale counts with your continuous variable.

Instead of simple log2 transformations, we should use the vst: 
https://compbiocore.github.io/deseq-workshop-1/assets/deseq_workshop_1.html
https://support.bioconductor.org/p/123969/


Meep
```{r}
#The warning message "the design formula contains one or more numeric variables that have mean or standard deviation larger than 5" means it is better  numeric covariates on a similar scale as the other factor variables, not too small and not too large, for improving the model fitting process.
#The warning is to help with model fitting. You may obtain the same fit but faster for example, or it may fail with badly scaled covariates.
#https://support.bioconductor.org/p/129082/

#https://www.seqanswers.com/forum/applications-forums/rna-sequencing/37943-deseq2-continuos-variable-in-the-design
#When you test with a continuous covariate, x, you are supposing the that counts follow the following formula: counts #proportional to 2^(a * x) Where a is the log2FoldChange.
# log2(counts) = a * clr, #where clr on a log2 scale etc

#Try with both CSS and clr

S_epi_Tw_RNA_vs_S_hom<- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_epidermidis",
                                                  responding_species = "Staphylococcus_hominis",
                                                  mgx_abundance = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                                  site="Tw",
                                                  count_threshold = 100000)

#Vast majority (out of 61 for clr, 127 for CSS) have a positive relationship
summary(S_epi_Tw_RNA_vs_S_hom[["species_site_filt_DESeq"]]$DE_results_shrunken)

#significant hits with CSS.
S_epi_Tw_RNA_vs_S_hom_df <- S_epi_Tw_RNA_vs_S_hom[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)




S_hom_Tw_RNA_vs_S_epi <- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_hominis",
                                                  responding_species = "Staphylococcus_epidermidis",
                                                  mgx_abundance = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                                  site="Tw",
                                                  count_threshold = 100000)

summary(S_hom_Tw_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken)


S_hom_Tw_RNA_vs_S_epi_df <- S_hom_Tw_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)



S_hom_Tw_RNA_vs_C_acnes <- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_hominis",
                                                  responding_species = "Cutibacterium_acnes",
                                                  mgx_abundance = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                                  site="Tw",
                                                  count_threshold = 100000)


summary(S_hom_Tw_RNA_vs_C_acnes[["species_site_filt_DESeq"]]$DE_results_shrunken)

S_hom_Tw_RNA_vs_C_acnes_df <- S_hom_Tw_RNA_vs_C_acnes[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)



S_epi_Tw_RNA_vs_C_acnes <- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_epidermidis",
                                                  responding_species = "Cutibacterium_acnes",
                                                  mgx_abundance = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                                  site="Tw",
                                                  count_threshold = 100000)


summary(S_epi_Tw_RNA_vs_C_acnes[["species_site_filt_DESeq"]]$DE_results_shrunken)

S_epi_Tw_RNA_vs_C_acnes_df <- S_epi_Tw_RNA_vs_C_acnes[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)



```







Nothing found for S epi on Ch on C acnes for CSS

```{r eval=FALSE}

S_epi_Ch_RNA_vs_C_acnes<- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_epidermidis",
                                                  responding_species = "Cutibacterium_acnes",
                                                  mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                                  site="Ch",
                                                  count_threshold = 100000)

summary(S_epi_Ch_RNA_vs_C_acnes[["species_site_filt_DESeq"]]$DE_results_shrunken)

S_epi_Ch_RNA_vs_C_acnes_df <- S_epi_Ch_RNA_vs_C_acnes[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05) 

S_epi_Ch_RNA_vs_C_acnes_df <- get_propan_annots(input_df=S_epi_Ch_RNA_vs_C_acnes_df,
                                              annot_df = S_epi_anno)



```



For S epi on Ch on S capitis

```{r eval=FALSE}

S_epi_Ch_RNA_vs_S_cap<- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_epidermidis",
                                                  responding_species = "Staphylococcus_capitis",
                                                  mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                                  site="Ch",
                                                  count_threshold = 100000)

summary(S_epi_Ch_RNA_vs_S_cap[["species_site_filt_DESeq"]]$DE_results_shrunken)

S_epi_Ch_RNA_vs_S_cap_df <- S_epi_Ch_RNA_vs_S_cap[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)

S_epi_Ch_RNA_vs_S_cap_df  <- get_propan_annots(input_df=S_epi_Ch_RNA_vs_S_cap_df ,
                                              annot_df = S_epi_anno)

```



Do the same for S epi on Tw on S capitis

```{r eval=FALSE}
S_epi_Tw_RNA_vs_S_cap<- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_epidermidis",
                                                  responding_species = "Staphylococcus_capitis",
                                                  mgx_abundance = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                                  site="Tw",
                                                  count_threshold = 100000)


summary(S_epi_Tw_RNA_vs_S_cap[["species_site_filt_DESeq"]]$DE_results_shrunken)

S_epi_Tw_RNA_vs_S_cap_df <- S_epi_Tw_RNA_vs_S_cap[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)

S_epi_Tw_RNA_vs_S_cap_df  <- get_propan_annots(input_df=S_epi_Tw_RNA_vs_S_cap_df ,
                                              annot_df = S_epi_anno)

```

How about S capitis on cheek or scalp vs C. acnes

```{r eval=FALSE}
S_cap_Ch_RNA_vs_C_acnes<- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_capitis",
                                                  responding_species = "Cutibacterium_acnes",
                                                  mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                                  site="Ch",
                                                  count_threshold = 100000)

summary(S_cap_Ch_RNA_vs_C_acnes[["species_site_filt_DESeq"]]$DE_results_shrunken)

#many significant hits with CSS, very few for aldex
S_cap_Ch_RNA_vs_C_acnes_df <- S_cap_Ch_RNA_vs_C_acnes[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)


S_cap_Ch_RNA_vs_C_acnes_df <- get_propan_annots(input_df=S_cap_Ch_RNA_vs_C_acnes_df,
                                              annot_df = S_capitis_anno)

#S_cap_term2gene <- make_custom_term2gene_df(input_annot=S_capitis_anno ,pangene_names = S_capitis_pangene_names)


#No significant pathways 
S_cap_Ch_RNA_vs_C_acnes_KEGG <- run_clusterprofiler(input_df = S_cap_Ch_RNA_vs_C_acnes_df %>% dplyr::rename(gene=pangene),
                                                 term2gene = S_cap_term2gene)

S_cap_Ch_RNA_vs_C_acnes_KEGG_df <- as.data.frame(S_cap_Ch_RNA_vs_C_acnes_KEGG)


###Try scalp. Nothing

S_cap_Sc_RNA_vs_C_acnes<- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_capitis",
                                                  responding_species = "Cutibacterium_acnes",
                                                  mgx_abundance = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                                  site="Sc",
                                                  count_threshold = 100000)

summary(S_cap_Sc_RNA_vs_C_acnes[["species_site_filt_DESeq"]]$DE_results_shrunken)

```

How about C acnes on cheek vs S. capitis. Nothing.
How about C acnes on scalp vs S capitis

```{r}

C_acnes_Ch_RNA_vs_S_cap <- compare_bacteria_RNA_to_mgx(
                                                  species="Cutibacterium_acnes",
                                                  responding_species = "Staphylococcus_capitis",
                                                  mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                                  site="Ch",
                                                  count_threshold = 100000)

summary(C_acnes_Ch_RNA_vs_S_cap[["species_site_filt_DESeq"]]$DE_results_shrunken)


C_acnes_Sc_RNA_vs_S_cap <- compare_bacteria_RNA_to_mgx(
                                                  species="Cutibacterium_acnes",
                                                  responding_species = "Staphylococcus_capitis",
                                                  mgx_abundance = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                                  site="Sc",
                                                  count_threshold = 100000)

summary(C_acnes_Sc_RNA_vs_S_cap[["species_site_filt_DESeq"]]$DE_results_shrunken)

#v few hits
C_acnes_Sc_RNA_vs_S_cap_df <- C_acnes_Sc_RNA_vs_S_cap[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)


C_acnes_Sc_RNA_vs_S_cap_df   <- get_propan_annots(input_df=C_acnes_Sc_RNA_vs_S_cap_df  ,
                                              annot_df = C_acnes_anno)




```


 S capitis on S epidermidis (nothing for CSS)
 
 https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8659174/ (Chitosan from fungal cell walls -> SCFA -> inhibit other microbes?)
 https://pubmed.ncbi.nlm.nih.gov/17392099/
 
 https://pubmed.ncbi.nlm.nih.gov/24627479/ Malassezia has abundant chitin and chitosan

```{r}

S_cap_Ch_RNA_vs_S_epi<- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_capitis",
                                                  responding_species = "Staphylococcus_epidermidis",
                                                  mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                                  site="Ch",
                                                  count_threshold = 100000)

summary(S_cap_Ch_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken)

S_cap_Ch_RNA_vs_S_epi_df <- S_cap_Ch_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)

#MBC3050377.1 is some surface protein
#maybe some chitosanase..
S_cap_Ch_RNA_vs_S_epi_df  <- get_propan_annots(input_df=S_cap_Ch_RNA_vs_S_epi_df,
                                              annot_df = S_capitis_anno)

#volcano plotto. Gotta tidy up. 

#labels

S_cap_Ch_RNA_gene_labels <- data.frame(gene=rownames(S_cap_Ch_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken))



EnhancedVolcano(S_cap_Ch_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken,
                lab = S_cap_Ch_RNA_gene_labels$gene,
                title = "S capitis transcripts against transformed S epidermidis abundances",
                x='log2FoldChange', #This is actually a coefficient in the linear model
                y='padj',
                ylim=c(0,4),
                selectLab = c('Staphylococcus_capitis_cluster_3399_JHOKHAPC_02353'),
                #boxedLabels = TRUE,
                #drawConnectors = TRUE,
                labFace = 'bold',
                pCutoff = 0.05,
                FCcutoff=0,
                col=c('black', 'black', 'black', 'red3'))

ggsave(filename="../plots/DESeq_RNA_vs_microbe_abun/S_cap_Ch_RNA_vs_S_epi_volcano.pdf",
       plot=last_plot(),
       height = 8, width = 10)



```

Scalp for S capitis vs S epidermidis does not have this relationship for chitosanase

```{r}
S_cap_Sc_RNA_vs_S_epi<- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_capitis",
                                                  responding_species = "Staphylococcus_epidermidis",
                                                  mgx_abundance = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                                  site="Sc",
                                                  count_threshold = 100000)

summary(S_cap_Sc_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken)

S_cap_Sc_RNA_vs_S_epi_df <- S_cap_Sc_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)

S_cap_Sc_RNA_vs_S_epi_df  <- get_propan_annots(input_df=S_cap_Sc_RNA_vs_S_epi_df ,
                                              annot_df = S_capitis_anno)


#S cap on Malassezia restricta?

S_cap_Ch_RNA_vs_M_res<- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_capitis",
                                                  responding_species = "Malassezia_restricta",
                                                  mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                                  site="Ch",
                                                  count_threshold = 100000)

summary(S_cap_Ch_RNA_vs_M_res[["species_site_filt_DESeq"]]$DE_results_shrunken)

S_cap_Ch_RNA_vs_M_res_df <- S_cap_Ch_RNA_vs_M_res[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)

S_cap_Ch_RNA_vs_M_res_df  <- get_propan_annots(input_df=S_cap_Ch_RNA_vs_M_res_df,
                                              annot_df = S_capitis_anno)

#On M globosa?

S_cap_Ch_RNA_vs_M_glo<- compare_bacteria_RNA_to_mgx(
                                                  species="Staphylococcus_capitis",
                                                  responding_species = "Malassezia_globosa",
                                                  mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                                  site="Ch",
                                                  count_threshold = 100000)

summary(S_cap_Ch_RNA_vs_M_glo[["species_site_filt_DESeq"]]$DE_results_shrunken)

S_cap_Ch_RNA_vs_M_glo_df <- S_cap_Ch_RNA_vs_M_glo[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)


S_cap_Ch_RNA_vs_M_glo_df  <- get_propan_annots(input_df=S_cap_Ch_RNA_vs_M_glo_df,
                                              annot_df = S_capitis_anno)


#####Visualize the relationship between vsd chitosanase counts (from S cap), S epidermidis and S capitis clr abundances on cheek.

S_cap_Ch_RNA_vsd <- S_cap_Ch_RNA_vs_S_epi[["species_site_filt_DESeq"]]$vsd_mat

#Staphylococcus_capitis_cluster_3399_JHOKHAPC_02353 is the chitosanase

test <- S_cap_Ch_RNA_vsd["Staphylococcus_capitis_cluster_3399_JHOKHAPC_02353",] 

##helper function to extract transformed counts from a DESeq2 matrix (vsd)  for a particular gene/cluster name

extract_gene_vsd <- function(vsd_mat, target_gene, 
                             species_vec,
                             mgx_abundance){
  
  vsd_df <- vsd_mat %>% as.data.frame()
  
  #libids in the colnames
  vsd_df <- vsd_df[target_gene,]
  
  vsd_df <-  as.data.frame(t(vsd_df))
  
  vsd_df$mtx_LIBID <- rownames(vsd_df)
  
  #add matching mgx_LIBIDs
  
  vsd_df <- merge(vsd_df, mtx_mgx_stats_chosen %>% dplyr::select(mtx_LIBID,mgx_LIBID), by="mtx_LIBID")
  
  #Add transformed abundance values (like aldex2 clr)
  mgx_abundance_subset <- mgx_abundance %>% dplyr::select(c("mgx_LIBID", species_vec))
  vsd_df <- merge(vsd_df, mgx_abundance_subset, by = "mgx_LIBID")
  
  return(vsd_df)
  
}

test <- extract_gene_vsd(vsd_mat=S_cap_Ch_RNA_vsd,
                         target_gene="Staphylococcus_capitis_cluster_3399_JHOKHAPC_02353",
                         species_vec=c("Staphylococcus_capitis","Staphylococcus_epidermidis", "Cutibacterium_acnes"),
                         mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]])


S_cap_Sc_RNA_libid <- S_cap_Sc_RNA_vs_S_epi[["species_site_filt_DESeq"]]$lib_vec 

test2 <- S_cap_Sc_Ch_RNA_vsd[, S_cap_Sc_RNA_libid]

test3 <- extract_gene_vsd(vsd_mat=test2,
                         target_gene="Staphylococcus_capitis_cluster_3399_JHOKHAPC_02353",
                         species_vec=c("Staphylococcus_capitis","Staphylococcus_epidermidis", "Cutibacterium_acnes"),
                         mgx_abundance = aldex_clr_values_fmt[["Sc_bracken_clr"]])

ggscatter(test3, x = "Staphylococcus_epidermidis", 
          y = "Staphylococcus_capitis_cluster_3399_JHOKHAPC_02353", add = "reg.line") + stat_cor(method="spearman")

#reshape2::melt(S_epi_Ch_norm_count_cluster_agg_vir_AMR_df, value.name="vsd")

#spearman Rho
ggscatter(test, x = "Staphylococcus_epidermidis", 
          y = "Staphylococcus_capitis_cluster_3399_JHOKHAPC_02353", add = "reg.line") + stat_cor(method="spearman")

ggsave(filename="../plots/DESeq_RNA_vs_microbe_abun/S_cap_chitosan_vs_S_epi_scatterplot.pdf" ,
       plot=last_plot())


ggscatter(test, x = "Cutibacterium_acnes", 
          y = "Staphylococcus_capitis_cluster_3399_JHOKHAPC_02353", add = "reg.line") + stat_cor(method="spearman")

ggsave(filename="../plots/DESeq_RNA_vs_microbe_abun/S_cap_chitosan_vs_C_acnes_scatterplot.pdf" ,
       plot=last_plot())



#####Visualize the relationship between vsd chitosanase counts (from S cap), S epidermidis and S capitis clr abundances on Scalp.

S_cap_Sc_RNA_vsd <- S_cap_Sc_RNA_vs_S_epi[["species_site_filt_DESeq"]]$vsd_mat

#Staphylococcus_capitis_cluster_3399_JHOKHAPC_02353 is the chitosanase
#Not even variance stabilized
#test <- S_cap_Sc_RNA_vsd["Staphylococcus_capitis_cluster_3399_JHOKHAPC_02353",]


```

How about C acnes on Sc/Ch on M restricta or M glo? Nothing for CSS.

```{r}

C_acnes_Sc_RNA_vs_S_epi<- compare_bacteria_RNA_to_mgx(
                                                  species="Cutibacterium_acnes",
                                                  responding_species = "Staphylococcus_epidermidis",
                                                  site="Sc",
                                                  count_threshold = 100000)

summary(C_acnes_Sc_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken)

#significant hits
C_acnes_Sc_RNA_vs_S_epi_df <- C_acnes_Sc_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)

#A few unknown clusters that might be negatively associated with S epi on scalp.
C_acnes_Sc_RNA_vs_S_epi_df  <- get_propan_annots(input_df=C_acnes_Sc_RNA_vs_S_epi_df,
                                              annot_df = C_acnes_anno)


##############

C_acnes_Ch_RNA_vs_S_epi<- compare_bacteria_RNA_to_mgx(
                                                  species="Cutibacterium_acnes",
                                                  responding_species = "Staphylococcus_epidermidis",
                                                  site="Ch",
                                                  count_threshold = 100000)

summary(C_acnes_Ch_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken)

#significant hits
C_acnes_Ch_RNA_vs_S_epi_df <- C_acnes_Ch_RNA_vs_S_epi[["species_site_filt_DESeq"]]$DE_results_shrunken_df %>% 
  dplyr::filter(padj < 0.05)

C_acnes_Ch_RNA_vs_S_epi_df  <- get_propan_annots(input_df=C_acnes_Ch_RNA_vs_S_epi_df,
                                              annot_df = C_acnes_anno)

```




Using DEseq2 to find associations between Malassezia species gene expression (within site) and a responding species (probably bacteria, CSS normalized values)

```{r}

#Return all library IDs of each site, with at least 200K Malassezia spp read pairs


get_Malassezia_lib_list <- function(read_pair_threshold=200000){
  
  Sc_libs <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Sc") %>% pull(mtx_LIBID)
  Ch_libs <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Ch") %>% pull(mtx_LIBID)
  Ac_libs <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Ac") %>% pull(mtx_LIBID)
  Vf_libs <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Vf") %>% pull(mtx_LIBID)
  Tw_libs <- mtx_mgx_stats_chosen %>% dplyr::filter(region=="Tw") %>% pull(mtx_LIBID)
  
  
  M_glo_Sc_libs <- rna_k2_minimizer[Sc_libs] %>% do.call("rbind",.) %>% 
    dplyr::filter(k2_taxon == "Malassezia_globosa")  %>% 
    dplyr::filter(paired_counts >= read_pair_threshold) %>% pull(mtx_LIBID)
  
  M_glo_Ch_libs <- rna_k2_minimizer[Ch_libs]  %>% do.call("rbind",.) %>% 
    dplyr::filter(k2_taxon == "Malassezia_globosa")  %>% 
    dplyr::filter(paired_counts >= read_pair_threshold) %>% pull(mtx_LIBID)
  
  M_glo_Ac_libs <- rna_k2_minimizer[Ac_libs]  %>% do.call("rbind",.) %>% 
    dplyr::filter(k2_taxon == "Malassezia_globosa")  %>% 
    dplyr::filter(paired_counts >= read_pair_threshold) %>% pull(mtx_LIBID)
  
  M_glo_Vf_libs <- rna_k2_minimizer[Vf_libs]  %>% do.call("rbind",.) %>% 
    dplyr::filter(k2_taxon == "Malassezia_globosa")  %>% 
    dplyr::filter(paired_counts >= read_pair_threshold) %>% pull(mtx_LIBID)
  
  M_glo_Tw_libs <- rna_k2_minimizer[Tw_libs]  %>% do.call("rbind",.) %>% 
    dplyr::filter(k2_taxon == "Malassezia_globosa")  %>% 
    dplyr::filter(paired_counts >= read_pair_threshold) %>% pull(mtx_LIBID)
  
  M_res_Sc_libs <- rna_k2_minimizer[Sc_libs]  %>% do.call("rbind",.) %>% 
    dplyr::filter(k2_taxon == "Malassezia_restricta")  %>% 
    dplyr::filter(paired_counts >= read_pair_threshold) %>% pull(mtx_LIBID)
  
  M_res_Ch_libs <- rna_k2_minimizer[Ch_libs]  %>% do.call("rbind",.) %>% 
    dplyr::filter(k2_taxon == "Malassezia_restricta")  %>% 
    dplyr::filter(paired_counts >= read_pair_threshold) %>% pull(mtx_LIBID)
  
  M_res_Ac_libs <- rna_k2_minimizer[Ac_libs]  %>% do.call("rbind",.) %>% 
    dplyr::filter(k2_taxon == "Malassezia_restricta")  %>% 
    dplyr::filter(paired_counts >= read_pair_threshold) %>% pull(mtx_LIBID)
  
  M_res_Vf_libs <- rna_k2_minimizer[Vf_libs]  %>% do.call("rbind",.) %>% 
    dplyr::filter(k2_taxon == "Malassezia_restricta")  %>% 
    dplyr::filter(paired_counts >= read_pair_threshold) %>% pull(mtx_LIBID)
  
  M_res_Tw_libs <- rna_k2_minimizer[Tw_libs]   %>% do.call("rbind",.) %>% 
    dplyr::filter(k2_taxon == "Malassezia_restricta")  %>% 
    dplyr::filter(paired_counts >= read_pair_threshold) %>% pull(mtx_LIBID)
  
  
  return(tibble::lst(M_glo_Sc_libs,
                     M_glo_Ch_libs,
                     M_glo_Ac_libs,
                     M_glo_Vf_libs,
                     M_glo_Tw_libs,
                     M_res_Sc_libs,
                     M_res_Ch_libs,
                     M_res_Ac_libs,
                     M_res_Vf_libs,
                     M_res_Tw_libs
                     ))

}

Malassezia_lib_list <- get_Malassezia_lib_list()

#Remember the 200K paired read count threshold
#No significant hits of convincing effect size when CSS norm values were used. 
#Have tried with aldex clr values
#Still few hits
M_glo_Sc_RNA_vs_S_cap <- run_DESeq_with_salmon_matrix_and_MGX(input_matrix=Malassezia_count_matrix, 
                                        input_metadata=mtx_stats_chosen, 
                                        mgx_abundance = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                        lib_vec=Malassezia_lib_list [["M_glo_Sc_libs"]],
                                        run_test=TRUE,
                                  size_factor_function = "poscounts",
                                  species="Malassezia_globosa",
								  responding_species= "Staphylococcus_capitis")

summary(M_glo_Sc_RNA_vs_S_cap[["DE_results_shrunken"]])

M_glo_Sc_RNA_vs_S_cap_res <- M_glo_Sc_RNA_vs_S_cap[["DE_results_shrunken_df"]] %>% dplyr::filter(padj < 0.05)


############

```


```{r}
#No significant hits of convincing effect size with CSS. (Maybe 2 hits of 0.5 l2fc..)
M_res_Sc_RNA_vs_S_cap <- run_DESeq_with_salmon_matrix_and_MGX(input_matrix=Malassezia_count_matrix, 
                                        input_metadata=mtx_stats_chosen,
                                        mgx_abundance = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                        lib_vec=Malassezia_lib_list [["M_res_Sc_libs"]],
                                        run_test=TRUE,
                                  size_factor_function = "poscounts",
                                  species="Malassezia_restricta",
								  responding_species= "Staphylococcus_capitis")

summary(M_res_Sc_RNA_vs_S_cap[["DE_results_shrunken"]])

M_res_Sc_RNA_vs_S_cap_res <- M_res_Sc_RNA_vs_S_cap[["DE_results_shrunken_df"]] %>% dplyr::filter(padj < 0.05)

###########
#No significant hits of convincing effect size. 
M_res_Sc_RNA_vs_M_glo <- run_DESeq_with_salmon_matrix_and_MGX(input_matrix=Malassezia_count_matrix, 
                                        input_metadata=mtx_stats_chosen,
                                        lib_vec=Malassezia_lib_list [["M_res_Sc_libs"]],
                                        mgx_abundance = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                        run_test=TRUE,
                                  size_factor_function = "poscounts",
                                  species="Malassezia_restricta",
								  responding_species= "Malassezia_globosa")

summary(M_res_Sc_RNA_vs_M_glo [["DE_results_shrunken"]])

M_res_Sc_RNA_vs_M_glo_res <- M_res_Sc_RNA_vs_M_glo[["DE_results_shrunken_df"]] %>% dplyr::filter(padj < 0.05)

###########

M_glo_Sc_RNA_vs_M_res <- run_DESeq_with_salmon_matrix_and_MGX(input_matrix=Malassezia_count_matrix, 
                                        input_metadata=mtx_stats_chosen,
                                        lib_vec=Malassezia_lib_list [["M_glo_Sc_libs"]],
                                        mgx_abundance = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                        run_test=TRUE,
                                  size_factor_function = "poscounts",
                                  species="Malassezia_globosa",
								  responding_species= "Malassezia_restricta")

summary(M_glo_Sc_RNA_vs_M_res[["DE_results_shrunken"]])

M_glo_Sc_RNA_vs_M_res_res <- M_glo_Sc_RNA_vs_M_res[["DE_results_shrunken_df"]] %>% dplyr::filter(padj < 0.05)

##any thing for S epi?
```


For cheek..Nothing to see for CSS normalization but maybe something for aldex clr: M_res_Ch_RNA_vs_S_cap

Some results for aldex2 clr, but relatively small "l2fc". How do we interpret these coefficients?

```{r}

M_res_Ch_RNA_vs_S_cap <- run_DESeq_with_salmon_matrix_and_MGX(input_matrix=Malassezia_count_matrix, 
                                        input_metadata=mtx_stats_chosen,
                                        lib_vec=Malassezia_lib_list [["M_res_Ch_libs"]],
                                        mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                        run_test=TRUE,
                                  size_factor_function = "poscounts",
                                  species="Malassezia_restricta",
								  responding_species= "Staphylococcus_capitis")

summary(M_res_Ch_RNA_vs_S_cap[["DE_results_shrunken"]])

M_res_Ch_RNA_vs_S_cap_res <- M_res_Ch_RNA_vs_S_cap[["DE_results_shrunken_df"]] %>% dplyr::filter(padj < 0.05)

M_res_Ch_RNA_vs_S_cap_res <- merge(M_res_Ch_RNA_vs_S_cap_res, 
                                   M_res_gtf_annots,
                                   all.x=TRUE)


M_res_Ch_RNA_vs_S_cap_KEGG <- run_clusterprofiler(input_df = M_res_Ch_RNA_vs_S_cap_res,
                                                 term2gene = M_res_term2gene)
M_res_Ch_RNA_vs_S_cap_KEGG_df <- as.data.frame(M_res_Ch_RNA_vs_S_cap_KEGG)

#clusterProfiler::dotplot(M_res_Ch_RNA_vs_S_cap_KEGG_df)
```


```{r}
#Nothing here. CSS or clr.
M_res_Ch_RNA_vs_S_epi <- run_DESeq_with_salmon_matrix_and_MGX(input_matrix=Malassezia_count_matrix, 
                                        input_metadata=mtx_stats_chosen,
                                        lib_vec=Malassezia_lib_list [["M_res_Ch_libs"]],
                                        mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                        run_test=TRUE,
                                  size_factor_function = "poscounts",
                                  species="Malassezia_restricta",
								  responding_species= "Staphylococcus_epidermidis")



summary(M_res_Ch_RNA_vs_S_epi[["DE_results_shrunken"]])

M_res_Ch_RNA_vs_S_hom <- run_DESeq_with_salmon_matrix_and_MGX(input_matrix=Malassezia_count_matrix, 
                                        input_metadata=mtx_stats_chosen,
                                        lib_vec=Malassezia_lib_list [["M_res_Ch_libs"]],
                                        mgx_abundance = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                        run_test=TRUE,
                                  size_factor_function = "poscounts",
                                  species="Malassezia_restricta",
								  responding_species= "Staphylococcus_hominis")

summary(M_res_Ch_RNA_vs_S_hom[["DE_results_shrunken"]])

```


Outdated
```{r eval=FALSE}
###Amongst discordant taxa, 
#two possible ways to code this...
#1) Outlier method where the read and RPK thresholds are based on. (called "outlier")
#2) Simple thresholding of X* max contaminant read/RPK within each sample (called "max")

#Note: method #2 is very stringent and almost nothing is past this threshold.
#two new columns of boolean - measured vs inferred

infer_presence_fn <- function(df, filtering_mode, fold_change=1.5){
  
  if (filtering_mode=="outlier"){
  #outlier read count and RPK of contaminants
  q3_count <- df %>% dplyr::filter(source=="contaminant" & RNA_detected=="detected" & transcript_gene_discordance == TRUE) %>% 
    pull(mtx_counts) %>% quantile(., 0.75)
  iqr_count <- df %>% dplyr::filter(source=="contaminant" & RNA_detected=="detected" & transcript_gene_discordance == TRUE) %>% 
    pull(mtx_counts) %>% iqr(.)
  
  #fold_change is by default 1.5 which suits the standard definition of outliers
  threshold_count <- q3_count[[1]] + (fold_change*iqr_count)
  
  q3_RPK <- df %>% dplyr::filter(source=="contaminant" & RNA_detected=="detected" & transcript_gene_discordance == TRUE) %>% 
    pull(mtx_RPK) %>% quantile(., 0.75)
  iqr_RPK <- df %>% dplyr::filter(source=="contaminant" & RNA_detected=="detected" & transcript_gene_discordance == TRUE) %>% 
    pull(mtx_RPK) %>% iqr(.)
  
  threshold_RPK <- q3_RPK[[1]] + (fold_change*iqr_RPK)
  } else if (filtering_mode=="max"){
    
    contam_max_count <- df %>% dplyr::filter(source=="contaminant" & RNA_detected=="detected" & transcript_gene_discordance == TRUE) %>% 
      pull(mtx_counts) %>% max(.)
    
    contam_RPK_count <- df %>% dplyr::filter(source=="contaminant" & RNA_detected=="detected" & transcript_gene_discordance == TRUE) %>% 
      pull(mtx_RPK) %>% max(.)
    
    
    threshold_count <- fold_change*contam_max_count
    threshold_RPK <- fold_change*contam_RPK_count
  }

  ##############
  
  #split the non-contaminant df into discordant and non-discordant fractions
  df_non_contam <- df %>% dplyr::filter(source=="non_contaminant")
  
  df_non_contam$activity_measured <- ifelse(df_non_contam$transcript_gene_discordance==FALSE & 
                                              df_non_contam$RNA_detected=="detected",
                                            TRUE, FALSE)
  
  df_non_contam$activity_inferred <- ifelse(df_non_contam$transcript_gene_discordance==TRUE &
                                                     df_non_contam$mtx_counts > threshold_count &
                                                     df_non_contam$mtx_RPK > threshold_RPK,TRUE, FALSE)
  return(df_non_contam)
  
}
```

############# Read this #########################

https://advaitabio.com/ipathwayguide/how-do-i-know-if-a-pathway-is-up-regulated-or-down-regulated/

We often hear the following question: “Is there any way to know if the whole pathway or the whole GO is upregulated or downregulated?
The results table shows p-values and DE numbers, but I want to know if that pathway went up or down.”

The answer is “No, we do not provide an Up- or Down-regulated call at the pathway level.” This is not a limitation of the software but rather a decision based on sound scientific reasons. The simple answer is that we feel it is a gross oversimplification to call a pathway as “upregulated” or “downregulated”. In most cases, a call of this nature would be incorrect. Here is why: 

First, there is no universally accepted definition of a pathway or GO term being up-regulated or down-regulated. Because of this, it is not possible to make a call whether a pathway is up-regulated or down-regulated in a general way that would be true for all pathways.

Let us consider a biological process, let’s say apoptosis. let us consider that there is only one differentially expressed gene associated with this apoptosis in a given experiment. Let’s say that this gene is up-regulated. Can we really say that apoptosis is up-regulated? The answer is no, because it really depends on what the gene does. If the gene triggers apoptosis, the apoptosis as a process will increase (or be up-regulated). However, if the gene inhibits apoptosis, the apoptosis as a process will be reduced (or down-regulated). This is the reason for which there could be no general inference of what happens to a biological process or pathway based on just the number of DE genes included in it. The researcher has to make a judgement in each experiment, based on their knowledge and the specific genes that are up- or down- regulated.



#####Outdated analyses#######


Now do the labelling of presence or absence based on minimizer information

```{r eval=FALSE}
#Merge mtx and mgx data by taxonomic features, taking into account some features present in one dataset but not the other

combined_taxa_count_list <- lapply(mtx_to_pull, function(x){
  
  mtx_id <- x
  mgx_id <- mtx_mgx_stats_chosen %>% dplyr::filter(mtx_LIBID==x) %>% pull(mgx_LIBID)
  
  subject_region <- mtx_mgx_stats_chosen %>% dplyr::filter(mtx_LIBID==x) %>% pull(subj_region)
  body_site <- mtx_mgx_stats_chosen %>% dplyr::filter(mtx_LIBID==x) %>% pull(region)
  
  ###df with minimizers for mgx data
  minimizer_df <- k2_minimizer[[mgx_id]] %>% dplyr::select(k2_taxon, taxa_pass_filter) %>% 
    dplyr::rename(mgx_taxa_pass_filter=taxa_pass_filter)
  
  ###df with minimizers for mtx data
  mtx_minimizer_df <- rna_k2_minimizer[[mtx_id]] %>% dplyr::select(k2_taxon, taxa_pass_filter) %>% 
    dplyr::rename(mtx_taxa_pass_filter=taxa_pass_filter)
  
  
  #Species level analysis: unpaired counts and RPK at mtx level
  mtx_taxa_df <- mtx_taxa_count_summary_subsp_collapse[[mtx_id]] %>% 
    dplyr::rename(mtx_LIBID=LIBID,mtx_counts=read_count_sum,mtx_RPK=RPK_sum) %>% ungroup()
  
  #Species level analysis: unpaired counts and RPK at mgx level
  mgx_taxa_df <- mgx_taxa_count_summary_subsp_collapse[[mgx_id]] %>% 
    dplyr::rename(mgx_LIBID=LIBID,mgx_counts=read_count_sum,mgx_RPK=RPK_sum) %>% ungroup()
  
  combined_df <- merge(mtx_taxa_df,mgx_taxa_df, all=TRUE, by = "k2_taxon")
  
  combined_df$mtx_LIBID <- mtx_id
  combined_df$mgx_LIBID <- mgx_id
  
  combined_df[is.na(combined_df)] <- 0
  
  #Ignore kraken2 unclassified reads
  
  combined_df <- combined_df %>% dplyr::filter(k2_taxon != "unclassified")
  
  #label source as "non-contaminant", "contaminant", "spike". Note that "Listeria, Plesiomonas and Vibrio" are the spikes
  combined_df_bio  <- combined_df %>% dplyr::filter(str_detect(combined_df$k2_taxon, genera_mask, negate=TRUE)) %>% 
    dplyr::filter(! k2_taxon %in% species_to_remove)
  
  combined_df_bio$source <- "non_contaminant"
  
  combined_df_contam <- combined_df %>% 
    dplyr::filter(str_detect(combined_df$k2_taxon, genera_mask) | k2_taxon %in% species_to_remove)
  

  combined_df_contam$source <- ifelse(str_detect(combined_df_contam$k2_taxon, "^Listeria|^Plesiomonas|^Vibrio"), "spike", "contaminant")
  
  
  output <- rbind(combined_df_bio, combined_df_contam)
  
  # What features are "DNA_detected" vs RNA_detected"
  #I have tried only select features with >= 10 unpaired read count and >= 1 RPK is the detection threshold for each feature but this still leads to too many false    positives
  #info from both DNA and RNA minimzers, per library
  all_minimizer_df <- merge(minimizer_df, 
                            mtx_minimizer_df, 
                            by="k2_taxon", all=TRUE)
  
 
  all_minimizer_df$mgx_taxa_pass_filter <- ifelse(is.na(all_minimizer_df$mgx_taxa_pass_filter), FALSE, all_minimizer_df$mgx_taxa_pass_filter)
  all_minimizer_df$mtx_taxa_pass_filter <- ifelse(is.na(all_minimizer_df$mtx_taxa_pass_filter), FALSE, all_minimizer_df$mtx_taxa_pass_filter)
  
  
  #For taxon RNA and DNA measurements, use minimizer information from kraken2 to distinguish true from false positives.
  output <- merge(output, all_minimizer_df, by ="k2_taxon", all.x=TRUE )
  
  output$DNA_detected <- ifelse(output$mgx_taxa_pass_filter == TRUE, "detected", "not_detected")
  output$RNA_detected <- ifelse(output$mtx_taxa_pass_filter == TRUE, "detected", "not_detected")
  
  output$transcript_gene_discordance <- ifelse(output$DNA_detected == "not_detected" & 
                                                 output$RNA_detected == "detected", TRUE, FALSE)
  
  output$subj_region <- subject_region
  output$region <- body_site
  
  return(output)
    
  
})

names(combined_taxa_count_list) <- mtx_to_pull


#####
#What proportion of taxa have a discordance between detected DNA vs RNA?
#We only consider detection of RNA but not detection of DNA as "discordant"

taxa_discordance_df <- lapply(combined_taxa_count_list, function(df){
  
  #Number of taxa for which RNA was "detected" regardless of DNA
  RNA_detected_number_all <- df %>% dplyr::filter(RNA_detected=="detected") %>% nrow()
  
  #Number of taxa for which there is transcript gene discordance
  discordance_number_all <- sum(df$transcript_gene_discordance)
  
  
  #Number of NON-CONTAMINANT taxa for which RNA was "detected" regardless of DNA
  df_non_contam <- df %>% dplyr::filter(source=="non_contaminant")
  
  RNA_detected_number_bio <- df_non_contam %>% dplyr::filter(RNA_detected=="detected") %>% nrow()
  
  #Number of NON-CONTAMINANT taxa for which there is transcript gene discordance
  discordance_number_bio <- sum(df_non_contam$transcript_gene_discordance)
  
  
  #other meta info
  output <- df %>% dplyr::select(mtx_LIBID, mgx_LIBID,subj_region,region) %>% unique()
  
  output$all_taxa_w_transcripts <- RNA_detected_number_all
  output$all_discordant_taxa <- discordance_number_all
  output$all_prop_discordant <- output$all_discordant_taxa/output$all_taxa_w_transcripts
  
  output$non_contam_taxa_w_transcripts <- RNA_detected_number_bio
  output$non_contam_discordant_taxa <- discordance_number_bio
  output$non_contam_prop_discordant <- output$non_contam_discordant_taxa/output$non_contam_taxa_w_transcripts
  
  return(output)
  
}) %>% do.call("rbind", .)

#No filtering for rare taxa. This is regardless of whether DNA was detected or not
taxa_with_transcripts_boxplot <- taxa_discordance_df %>% mutate(region= fct_relevel(region, "Sc", "Ch", "Ac", "Vf", "Tw")) %>% 
  ggplot(aes(x=region, y=non_contam_taxa_w_transcripts, fill=region)) + geom_boxplot() + theme_classic() + 
  ggtitle("Number of non-contaminant taxa with detected RNA")

ggsave(filename="../plots/taxa_transcription/non_contam_taxa_with_transcripts_boxplot.pdf", 
       plot=taxa_with_transcripts_boxplot, width = 14, height = 7)

taxa_with_transcripts_boxplot



taxa_discordance_boxplot <- taxa_discordance_df %>% mutate(region= fct_relevel(region, "Sc", "Ch", "Ac", "Vf", "Tw")) %>% 
  ggplot(aes(x=region, y=non_contam_prop_discordant, fill=region)) + geom_boxplot() + theme_classic() + 
  ggtitle("Proportion of non-contaminant taxa with RNA but undetected DNA")

ggsave(filename="../plots/taxa_transcription/taxa_discordance_boxplot.pdf", plot=taxa_discordance_boxplot, width = 14, height = 7)

taxa_discordance_boxplot


```


##Segue: Mimic a refflat file for the eight_skin_bact_pangenome_rep.fa 

```{r eval=FALSE}

eight_skin_pangenome_lengths <- read_tsv("../processed/mtx_species_mapping/eight_skin_bact_pangenome_rep_gene_lengths.tsv", col_names=c("chrom", "cdsEnd"))

eight_skin_pangenome_lengths$geneName <- seq_along(1:nrow(eight_skin_pangenome_lengths))

eight_skin_pangenome_lengths$geneName <- paste0("PAN_",eight_skin_pangenome_lengths$geneName)

eight_skin_pangenome_lengths$name <- seq_along(1:nrow(eight_skin_pangenome_lengths))

eight_skin_pangenome_lengths$name <- paste0("gene_",eight_skin_pangenome_lengths$name)

eight_skin_pangenome_lengths$strand <- "+"

eight_skin_pangenome_lengths$txStart <- 0

eight_skin_pangenome_lengths$txEnd <- eight_skin_pangenome_lengths$cdsEnd

eight_skin_pangenome_lengths$cdsStart <- 0

eight_skin_pangenome_lengths$exonCount <- 1

eight_skin_pangenome_lengths$exonStarts <- "0,"

eight_skin_pangenome_lengths$exonEnds <- paste0(eight_skin_pangenome_lengths$cdsEnd,",")

#Reorder the columns
eight_skin_pangenome_lengths <- eight_skin_pangenome_lengths[, c("geneName",
                                                                 "name",
                                                                 "chrom",
                                                                 "strand",
                                                                 "txStart",
                                                                 "txEnd",
                                                                 "cdsStart",
                                                                 "cdsEnd",
                                                                 "exonCount",
                                                                 "exonStarts",
                                                                 "exonEnds")]

write_tsv(eight_skin_pangenome_lengths,"../processed/mtx_species_mapping/eight_skin_bact_pangenome_rep_refFlat.tsv", col_names = FALSE)

```




###Segue: What are the raw relative abundances of S capitis and S caprae in scalp, cheek and forearm, at DNA level

```{r eval=FALSE}

DNA_Sc_Ch_Vf_libs <- mtx_mgx_stats_chosen %>% dplyr::filter(region %in% c("Sc","Ch", "Vf")) %>% pull(mgx_LIBID) 




#Extract S capitis and S caprae

DNA_Sc_Ch_Vf_k2 <- lapply(DNA_Sc_Ch_Vf_libs, function(x){
  
  df <- k2_minimizer[[x]] %>% dplyr::filter(k2_taxon %in% c("Staphylococcus_capitis",
                                                            "Staphylococcus_caprae"))
  
  
  return(df)
  
}) %>% do.call("rbind",.)

DNA_Sc_Ch_Vf_k2 <- merge(DNA_Sc_Ch_Vf_k2, mtx_mgx_stats_chosen%>%dplyr::select(mgx_LIBID,region), by ="mgx_LIBID")

ggplot(DNA_Sc_Ch_Vf_k2 %>% dplyr::filter(k2_taxon=="Staphylococcus_capitis"), aes(x=region,y=rel_abun)) + geom_boxplot() +
  ggtitle("S capitis")

ggplot(DNA_Sc_Ch_Vf_k2 %>% dplyr::filter(k2_taxon=="Staphylococcus_caprae"), aes(x=region,y=rel_abun)) + geom_boxplot() +
  ggtitle("S caprae")


###
Tw_libs <- mtx_mgx_stats_chosen %>% dplyr::filter(region %in% c("Tw")) %>% pull(mgx_LIBID) 

test <- lapply(Tw_libs, function(x){
  
  df <- k2_minimizer[[x]] %>% dplyr::filter(k2_taxon %in% c("Chroococcidiopsis_thermalis"))
  
  
  return(df)
  
}) %>% do.call("rbind",.)
  

```


###Outdated

Outdated attempts to perform Spearman correlation between S epidermidis "AMPs" with S capitis CSS abundances

This approach is too slow and feels like a fool's errand.

```{r}

S_epi_AMP <- S_epi_anno %>% dplyr::filter(str_detect(string = S_epi_anno$Description,
                                                             pattern="Bacteriocin subtilosin A|Lantibiotic alpha|Phage tail protein")|str_detect(string = S_epi_anno$`KEGG Orthology`, pattern="phenol-soluble modulin beta"))

S_epi_Tw_Ch_norm_count_mat <- S_epi_Tw_Ch_DE_analysis[["species_site_filt_DESeq"]][["vsd_mat"]]

S_epi_Ch_libs <- intersect(mtx_stats_chosen %>% dplyr::filter(region=="Ch")%>%pull(LIBID), colnames(S_epi_Tw_Ch_norm_count_mat)) 

S_epi_Tw_libs <- intersect(mtx_stats_chosen %>% dplyr::filter(region=="Tw")%>%pull(LIBID), colnames(S_epi_Tw_Ch_norm_count_mat)) 

S_epi_Tw_Ch_norm_count_cluster_agg_df <- get_norm_count_inputs(count_matrix = S_epi_Tw_Ch_norm_count_mat,
                                                            lib_vec = c(S_epi_Ch_libs,
                                                                        S_epi_Tw_libs))



#For AMPs on cheeks and Toewebs
#Only S_epi PSMs are expressed
S_epi_Tw_Ch_norm_count_cluster_agg_AMP_df <- merge(S_epi_Tw_Ch_norm_count_cluster_agg_df, 
                                                   S_epi_AMP , by ="propan_clusterID")


#Melt the df for heatmapping and other analyses

S_epi_Tw_Ch_norm_count_cluster_agg_AMP_df_melt  <- melt_df(S_epi_Tw_Ch_norm_count_cluster_agg_AMP_df)

#Correlate with CSS norm counts of specific Staph species
#mtx_df is a melted dataframe like S_epi_Ch_Tw_norm_count_cluster_agg_AMP_df_melt
#CSS_df can be bracken_MO_CSS_df_with_id
#Lib vec is a vector of mtx library IDs that have been analyzed with DESeq2
get_mtx_CSS_correlation <- function(mtx_df, CSS_df, mtx_lib_vec, species_to_test, 
                                    cor_test="pearson"){
  
  #species specific pangene clusters to test
  clusters_to_test <- mtx_df %>% pull(propan_clusterID) %>% unique()
  
  CSS_species_df <- CSS_df %>% dplyr::filter(mtx_LIBID %in% mtx_lib_vec) %>% dplyr::select(c(all_of(species_to_test),
                                                                                             "mtx_LIBID",
                                                                                             "mgx_LIBID"))
  
  #combined dataframe with CSS normalized metagenomic abundance for a particular species, and selected DESeq2 normalized count   data
  
  mtx_with_CSS_df <- mtx_df %>% dplyr::filter(LIBID %in% mtx_lib_vec) %>% dplyr::rename(mtx_LIBID=LIBID)
  mtx_with_CSS_df <- merge(mtx_with_CSS_df, CSS_species_df, by = "mtx_LIBID")
  
  #Initialize vectors to store data
  corr_p_vals <- vector(mode="numeric", length=length(clusters_to_test))
  
  corr_coeff <- vector(mode="numeric", length=length(clusters_to_test))
  
  for (i in 1:length(clusters_to_test)){
    
    current_cluster <- clusters_to_test[i]
      
    df_to_test <- mtx_with_CSS_df %>% dplyr::filter(propan_clusterID== current_cluster)
    
    # spearman looks at monotonic relationships
      if (cor_test=="pearson"){
      
        corr_results <- cor.test(df_to_test$vsd, df_to_test %>% pull(species_to_test), method="pearson")
    
        corr_p_vals[i] <- corr_results$p.value
    
        corr_coeff[i] <- corr_results$estimate[["cor"]]
        
      } else if (cor_test=="spearman"){
        
        corr_results <- cor.test(df_to_test$vsd, df_to_test %>% pull(species_to_test), method="spearman")
    
        corr_p_vals[i] <- corr_results$p.value
    
        corr_coeff[i] <- corr_results$estimate[["rho"]]
        
      }
    
  }
  
  corr_df <- data.frame(propan_clusterID=clusters_to_test,
                        corr_p_vals,
                        corr_coeff,
                        species_tested_for=species_to_test)
  
  output <- tibble::lst(mtx_with_CSS_df, corr_df)
  
  return(output)
}

S_epi_Ch_AMP_corr_S_capitis <- get_mtx_CSS_correlation(mtx_df = S_epi_Tw_Ch_norm_count_cluster_agg_AMP_df_melt,
                                                      CSS_df=bracken_MO_CSS_df_with_id, 
                                                      mtx_lib_vec=S_epi_Ch_libs, 
                                                      species_to_test="Staphylococcus_capitis",
                                                      cor_test = "spearman")
test <- S_epi_Ch_AMP_corr_S_capitis[[2]]



```


Heatmap, normalized counts of virulence factors and ARGs for cheek samples

```{r}

#Find the virulence factors and ARGS based on annotations
#This needs to be more refined in the future

S_epi_vir_factors <- S_epi_anno %>% dplyr::filter(str_detect(string = S_epi_anno$Description,
                                                             pattern="Virulence-associated|Virulence factor|bacterial virulence|autoinducing peptide")|str_detect(string = S_epi_anno$`KEGG Orthology`,
                                                             pattern="virulence"))



#Can consider condensing by drug resistance type later?
S_epi_AMRs <- S_epi_anno %>% dplyr::filter(str_detect(string = S_epi_anno$Resistance,
                                                             pattern="Drug"))



S_epi_Ch_norm_count_cluster_agg_df <- get_norm_count_inputs(count_matrix = S_epi_Ch_Tw_norm_count_mat,
                                                            lib_vec = S_epi_Ch_libs )

#For virulence factors
S_epi_Ch_norm_count_cluster_agg_vir_df <- merge(S_epi_Ch_norm_count_cluster_agg_df, S_epi_vir_factors, by ="propan_clusterID")



#For AMR genes
S_epi_Ch_norm_count_cluster_agg_AMR_df <- merge(S_epi_Ch_norm_count_cluster_agg_df, S_epi_AMRs, by ="propan_clusterID")

##Placeholder column to define factor levels for consistency

S_epi_Ch_norm_count_cluster_agg_vir_df$overall_desc <- S_epi_Ch_norm_count_cluster_agg_vir_df$Description

S_epi_Ch_norm_count_cluster_agg_AMR_df$overall_desc <- S_epi_Ch_norm_count_cluster_agg_AMR_df$Resistance


#For virulence factors on cheeks
S_epi_Ch_norm_count_cluster_agg_vir_df <- merge(S_epi_Ch_norm_count_cluster_agg_df, S_epi_vir_factors, by ="propan_clusterID")



#For AMR genes on cheeks
S_epi_Ch_norm_count_cluster_agg_AMR_df <- merge(S_epi_Ch_norm_count_cluster_agg_df, S_epi_AMRs, by ="propan_clusterID")

##Placeholder column to define factor levels for consistency

S_epi_Ch_norm_count_cluster_agg_vir_df$overall_desc <- S_epi_Ch_norm_count_cluster_agg_vir_df$Description

S_epi_Ch_norm_count_cluster_agg_AMR_df$overall_desc <- S_epi_Ch_norm_count_cluster_agg_AMR_df$Resistance

#combine the two dfs for heatmapping

S_epi_Ch_norm_count_cluster_agg_vir_AMR_df <- rbind(S_epi_Ch_norm_count_cluster_agg_vir_df,S_epi_Ch_norm_count_cluster_agg_AMR_df)

#Define factor levels?

vir_AMR_factor_order <- unique(S_epi_Ch_norm_count_cluster_agg_vir_AMR_df$overall_desc)

S_epi_Ch_norm_count_cluster_agg_vir_AMR_df$overall_desc <- factor(S_epi_Ch_norm_count_cluster_agg_vir_AMR_df$overall_desc , levels= vir_AMR_factor_order)

#https://stackoverflow.com/questions/44693041/reorder-factor-levels-based-on-another-factor

S_epi_Ch_norm_count_cluster_agg_vir_AMR_df$propan_clusterID <- factor(S_epi_Ch_norm_count_cluster_agg_vir_AMR_df$propan_clusterID, 
      levels = S_epi_Ch_norm_count_cluster_agg_vir_AMR_df[order(S_epi_Ch_norm_count_cluster_agg_vir_AMR_df$overall_desc), "propan_clusterID"] )

#test <- S_epi_Ch_norm_count_cluster_agg_vir_AMR_df[order(S_epi_Ch_norm_count_cluster_agg_vir_AMR_df$overall_desc),]

S_epi_Ch_vir_AMR_cluster_order <- levels(S_epi_Ch_norm_count_cluster_agg_vir_AMR_df$propan_clusterID)

#Melt the df for heatmapping

S_epi_Ch_norm_count_cluster_agg_vir_AMR_df_melt  <- reshape2::melt(S_epi_Ch_norm_count_cluster_agg_vir_AMR_df, value.name="vsd")

S_epi_Ch_norm_count_cluster_agg_vir_AMR_df_melt <- S_epi_Ch_norm_count_cluster_agg_vir_AMR_df_melt %>% dplyr::rename(LIBID=variable)

#Reorder factor levels again since they are reset after melt? May not be necessary..

S_epi_Ch_norm_count_cluster_agg_vir_AMR_df_melt$propan_clusterID <- factor(S_epi_Ch_norm_count_cluster_agg_vir_AMR_df_melt$propan_clusterID, 
                                                 levels=S_epi_Ch_vir_AMR_cluster_order)

levels(S_epi_Ch_norm_count_cluster_agg_vir_AMR_df_melt$propan_clusterID)

S_epi_Ch_norm_count_cluster_agg_vir_AMR_heatmap <- ggplot(data=S_epi_Ch_norm_count_cluster_agg_vir_AMR_df_melt, 
                             aes(x= LIBID,  
                                 y = propan_clusterID, 
                                 fill=vsd)) + geom_tile(colour ="white") + 
  scale_fill_gradient(low="white", high="red") + 
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.2, hjust=1)) +
  theme(axis.title = element_blank()) +
  theme(legend.position="right")


ggsave(plot=S_epi_Ch_norm_count_cluster_agg_vir_AMR_heatmap,
       filename = "../plots/DESeq_S_epi/S_epi_Ch_norm_count_cluster_agg_vir_AMR_heatmap.pdf",
       height = 7, width =10)


S_epi_Ch_norm_count_cluster_agg_vir_AMR_heatmap

```

Older correlation helper function where the correlations were computed on average clrs. This provides a quick and dirty approximation for the actual aldex.cor steps

```{r eval=FALSE}


#species_transcriptome_name is a string that identifies a species of interest for their transcriptomes to be analyzed 
#secretory_prediction_df is the processed output of signalP v 6
# aldex_clr_values_fmt[["Tw_bracken_clr"]]
#site_libs is a character vector 

get_mtx_vs_mgx_correlation_v1 <- function(mtx_count_matrix, abundance_df, secretory_prediction_df, site_libs, 
                                       species_transcriptome_name, species_transcriptome_read_threshold=200000, 
                                       responding_species, 
                                    cor_test="spearman",
                                    manual_vst_nsub = FALSE){
  
  ######
  #raw counts, species specific and site specific
  count_matrix <- mtx_count_matrix[str_detect(rownames(mtx_count_matrix), pattern=species_transcriptome_name), site_libs]
  
  #pre-filtering
  #keep if at least 10 reads in 10 samples across the metatranscriptomes?
  # rowSums(count_matrix >= 10) >= 10
  
  keep_transcript <- (rowMedians(count_matrix) >= 10)
  keep_sample <- (colSums(count_matrix)>=species_transcriptome_read_threshold)
  
  count_matrix <- count_matrix[keep_transcript, keep_sample]
  

  #vst() can be called on a matrix of counts and it will also call estimateSizeFactors within the function if you have not already supplied size factors: https://www.biostars.org/p/434003/
  
  if (manual_vst_nsub == FALSE){
    count_matrix_vst <- vst(count_matrix, blind=FALSE)
  } else if (manual_vst_nsub == TRUE){
    count_matrix_vst <- vst(count_matrix, blind=FALSE, nsub=sum( rowMedians(count_matrix) >= 10 ))
    
    }
  
  #subset for proteins in the secretory pathway
  
  count_matrix_vst_secretory <- count_matrix_vst[rownames(count_matrix_vst) %in% 
                                                   secretory_prediction_df$pangene, ]
  
  pangenes_to_test <- rownames(count_matrix_vst_secretory)
  
  
  #transpose the variance stabilized count_matrix. Now genes are columns and each row is a sample
  count_df_vst_secretory <- t(count_matrix_vst_secretory) %>% as.data.frame()
  count_df_vst_secretory$mtx_LIBID <- rownames(count_df_vst_secretory)
  
  #prepare the species abundance df (clr transformed metagenomic abundances with matching mtx library ID label)
  abundance_df_fmt <- abundance_df %>% dplyr::select(responding_species,"mtx_LIBID")
  #merge the dataframes
  
  transcript_and_mgx_abundance_df <- merge(count_df_vst_secretory,abundance_df_fmt, by ="mtx_LIBID")
  
  #Initialize vectors to store data
  corr_p_vals <- vector(mode="numeric", length=length(pangenes_to_test))
  
  corr_coeff <- vector(mode="numeric", length=length(pangenes_to_test))
                                                     
  
  for (i in 1:length(pangenes_to_test)){
    
    current_pangene <- pangenes_to_test[i]
      
    df_to_test <-transcript_and_mgx_abundance_df %>% dplyr::select(current_pangene,responding_species)
    

      if (cor_test=="pearson"){
      
        corr_results <- cor.test((df_to_test %>% pull(current_pangene)), 
                                 (df_to_test %>% pull(responding_species)), method="pearson",
                                 exact=FALSE)
    
        corr_p_vals[i] <- corr_results$p.value
    
        corr_coeff[i] <- corr_results$estimate[["cor"]]
        
      } else if (cor_test=="spearman"){
        
        corr_results <- cor.test((df_to_test %>% pull(current_pangene)), 
                                 (df_to_test %>% pull(responding_species)), method="spearman",
                                 exact=FALSE)
    
        corr_p_vals[i] <- corr_results$p.value
    
        corr_coeff[i] <- corr_results$estimate[["rho"]]
      }
  }
  
  #still need to adjust for multiple tests
  corr_df <- data.frame(pangene=pangenes_to_test,
                        corr_p_vals,
                        corr_coeff,
                        species_tested_for=responding_species)
  
  corr_df$p_adj <-  p.adjust(corr_df$corr_p_vals, method="fdr")
  
  output <- tibble::lst(count_matrix_vst, transcript_and_mgx_abundance_df, corr_df)
  
  return(output)
  
}


Malassezia_mtx_vs_C_acnes_mgx_Sc_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = Malassezia_integer_count_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                   secretory_prediction_df = malassezia_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "DNF",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_acnes", cor_test = "spearman" )


#Malassezia_mtx_vs_C_acnes_mgx_Sc_corr_df <- Malassezia_mtx_vs_C_acnes_mgx_Sc$corr_df



ggscatter(Malassezia_mtx_vs_C_acnes_mgx_Sc_v1$transcript_and_mgx_abundance_df, x = "Cutibacterium_acnes", 
          y = "DNF11_2196", add = "reg.line") + stat_cor(method="spearman")

###########





####Nothing
S_cap_mtx_vs_S_epi_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Staphylococcus_epidermidis", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_S_epi_mgx_Ch_corr_df <- S_cap_mtx_vs_S_epi_mgx_Ch_v1$corr_df

###Nothing

S_cap_mtx_vs_S_epi_mgx_Sc_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_epidermidis", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_S_epi_mgx_Sc_corr_df <- S_cap_mtx_vs_S_epi_mgx_Sc_v1$corr_df


###
#Corynebacterium kefirresidentii and Staph
#See: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3265625/ 
#reduced read threshold required for number of samples to >= 10

S_cap_mtx_vs_C_keffir_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Corynebacterium_kefirresidentii", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_C_keffir_mgx_Ch_corr_df <- S_cap_mtx_vs_C_keffir_mgx_Ch_v1$corr_df


#

ggscatter(S_cap_mtx_vs_C_keffir_mgx_Ch_v1$transcript_and_mgx_abundance_df, x = "Corynebacterium_kefirresidentii", 
          y = "Staphylococcus_capitis_cluster_1007_EEE49997.1", add = "reg.line") + stat_cor(method="spearman")

ggscatter(S_cap_mtx_vs_C_keffir_mgx_Ch_v1$transcript_and_mgx_abundance_df, x = "Corynebacterium_kefirresidentii", 
          y = "Staphylococcus_capitis_cluster_50_EEE48544.1", add = "reg.line") + stat_cor(method="spearman")


#control


ggscatter(aldex_clr_values_fmt$Ch_bracken_clr, x = "Staphylococcus_capitis", 
          y = "Corynebacterium_kefirresidentii", add = "reg.line") + stat_cor(method="spearman")

#S cap to itself
S_cap_mtx_vs_S_cap_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Staphylococcus_capitis", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_S_cap_mgx_Ch_corr_df <- S_cap_mtx_vs_S_cap_mgx_Ch_v1$corr_df


```


S_cap to other non Staph bacteria or fungi on cheeks

Whole load of nothing.

```{r eval=FALSE}
####S_cap to other non Staph bacteria or fungi on cheeks

#Nothing
S_cap_mtx_vs_C_acnes_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Cutibacterium_acnes", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_C_acnes_mgx_Ch_corr_df <- S_cap_mtx_vs_C_acnes_mgx_Ch_v1$corr_df

##Nothing
S_cap_mtx_vs_C_gran_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Cutibacterium_granulosum", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_C_gran_mgx_Ch_corr_df <- S_cap_mtx_vs_C_gran_mgx_Ch_v1$corr_df


##
S_cap_mtx_vs_C_modestum_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Cutibacterium_modestum", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_C_modestum_mgx_Ch_corr_df <- S_cap_mtx_vs_C_modestum_mgx_Ch_v1$corr_df


#Just one hit to a cell surface protein that has little biological sense
S_cap_mtx_vs_M_res_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Malassezia_restricta", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_M_res_mgx_Ch_corr_df <- S_cap_mtx_vs_M_res_mgx_Ch_v1$corr_df

##Nothing
S_cap_mtx_vs_M_glo_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Malassezia_globosa", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_M_glo_mgx_Ch_corr_df <- S_cap_mtx_vs_M_glo_mgx_Ch_v1$corr_df


```

Also whole load of nothing.

```{r}

####S_cap to other non Staph bacteria or fungi on scalp

#nothing
S_cap_mtx_vs_C_keffir_mgx_Sc_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Corynebacterium_kefirresidentii", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_C_keffir_mgx_Sc_corr_df <- S_cap_mtx_vs_C_keffir_mgx_Sc_v1$corr_df




#Nothing
S_cap_mtx_vs_C_acnes_mgx_Sc_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Cutibacterium_acnes", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_C_acnes_mgx_Sc_corr_df <- S_cap_mtx_vs_C_acnes_mgx_Sc_v1$corr_df

##Nothing
S_cap_mtx_vs_C_gran_mgx_Sc_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Cutibacterium_granulosum", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_C_gran_mgx_Sc_corr_df <- S_cap_mtx_vs_C_gran_mgx_Sc_v1$corr_df


##
S_cap_mtx_vs_C_modestum_mgx_Sc_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Cutibacterium_modestum", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_C_modestum_mgx_Sc_corr_df <- S_cap_mtx_vs_C_modestum_mgx_Sc_v1$corr_df


#nothing
S_cap_mtx_vs_M_res_mgx_Sc_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Malassezia_restricta", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_M_res_mgx_Sc_corr_df <- S_cap_mtx_vs_M_res_mgx_Sc_v1$corr_df

##Nothing
S_cap_mtx_vs_M_glo_mgx_Sc_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Sc_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Sc_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Malassezia_globosa", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_M_glo_mgx_Sc_corr_df <- S_cap_mtx_vs_M_glo_mgx_Sc_v1$corr_df


```

S_epi to other non Staph bacteria or fungi on cheeks

```{r}
S_epi_mtx_vs_C_keffir_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Corynebacterium_kefirresidentii", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_epi_mtx_vs_C_keffir_mgx_Ch_corr_df <- S_epi_mtx_vs_C_keffir_mgx_Ch_v1$corr_df



##
S_epi_mtx_vs_C_acnes_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_acnes", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_epi_mtx_vs_C_acnes_mgx_Ch_corr_df <- S_epi_mtx_vs_C_acnes_mgx_Ch_v1$corr_df

##Nothing
S_epi_mtx_vs_C_gran_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_granulosum", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_epi_mtx_vs_C_gran_mgx_Ch_corr_df <- S_epi_mtx_vs_C_gran_mgx_Ch_v1$corr_df


##Nothing
S_epi_mtx_vs_C_modestum_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_modestum", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_epi_mtx_vs_C_modestum_mgx_Ch_corr_df <- S_epi_mtx_vs_C_modestum_mgx_Ch_v1$corr_df


#nothing
S_epi_mtx_vs_M_res_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Malassezia_restricta", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_epi_mtx_vs_M_res_mgx_Ch_corr_df <- S_epi_mtx_vs_M_res_mgx_Ch_v1$corr_df

##Nothing
S_epi_mtx_vs_M_glo_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Malassezia_globosa", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_epi_mtx_vs_M_glo_mgx_Ch_corr_df <- S_epi_mtx_vs_M_glo_mgx_Ch_v1$corr_df


```


Cannot do S_epi to other bacteria or fungi on scalp due to low reads


S_cap to other bacteria on Toe webs

```{r}

####S_cap to other non Staph bacteria on Toe webs

#nothing
S_cap_mtx_vs_C_keffir_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Corynebacterium_kefirresidentii", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_C_keffir_mgx_Tw_corr_df <- S_cap_mtx_vs_C_keffir_mgx_Tw_v1$corr_df


#nothing
S_cap_mtx_vs_C_tuber_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Corynebacterium_tuberculostearicum", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_C_tuber_mgx_Tw_corr_df <- S_cap_mtx_vs_C_tuber_mgx_Tw_v1$corr_df



#Nothing
S_cap_mtx_vs_C_acnes_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Cutibacterium_acnes", cor_test = "spearman",
  manual_vst_nsub=TRUE)


S_cap_mtx_vs_C_acnes_mgx_Tw_corr_df <- S_cap_mtx_vs_C_acnes_mgx_Tw_v1$corr_df

##Nothing
S_cap_mtx_vs_C_gran_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Cutibacterium_granulosum", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_C_gran_mgx_Tw_corr_df <- S_cap_mtx_vs_C_gran_mgx_Tw_v1$corr_df


##
S_cap_mtx_vs_M_osloensis_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Moraxella_osloensis", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_M_osloensis_mgx_Tw_corr_df <- S_cap_mtx_vs_M_osloensis_mgx_Tw_v1$corr_df


####S_cap to other Staph bacteria on Toe webs

S_cap_mtx_vs_S_epi_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Staphylococcus_epidermidis", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_S_epi_mgx_Tw_corr_df <- S_cap_mtx_vs_S_epi_mgx_Tw_v1$corr_df

#
S_cap_mtx_vs_S_hom_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Staphylococcus_hominis", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_S_hom_mgx_Tw_corr_df <- S_cap_mtx_vs_S_hom_mgx_Tw_v1$corr_df

#

S_cap_mtx_vs_S_haem_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Staphylococcus_haemolyticus", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_S_haem_mgx_Tw_corr_df <- S_cap_mtx_vs_S_haem_mgx_Tw_v1$corr_df

#
S_cap_mtx_vs_S_warneri_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_capitis",
  species_transcriptome_read_threshold=100000,
  responding_species = "Staphylococcus_warneri", cor_test = "spearman",
  manual_vst_nsub=TRUE)

S_cap_mtx_vs_S_warneri_mgx_Tw_corr_df <- S_cap_mtx_vs_S_warneri_mgx_Tw_v1$corr_df



```

S_epi to other bacteria on Toe webs


```{r}

#Hits, but S_epi, C_keffir and some S_epi transcripts are collinear in the positive direction
S_epi_mtx_vs_C_keffir_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Corynebacterium_kefirresidentii", cor_test = "spearman",
  manual_vst_nsub=FALSE)


S_epi_mtx_vs_C_keffir_mgx_Tw_corr_df <- S_epi_mtx_vs_C_keffir_mgx_Tw_v1$corr_df


#Hits, but co-linearity is always a problem
S_epi_mtx_vs_C_tuber_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Corynebacterium_tuberculostearicum", cor_test = "spearman",
  manual_vst_nsub=FALSE)


S_epi_mtx_vs_C_tuber_mgx_Tw_corr_df <- S_epi_mtx_vs_C_tuber_mgx_Tw_v1$corr_df




#Nothing
S_epi_mtx_vs_C_acnes_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_acnes", cor_test = "spearman",
  manual_vst_nsub=FALSE)


S_epi_mtx_vs_C_acnes_mgx_Tw_corr_df <- S_epi_mtx_vs_C_acnes_mgx_Tw_v1$corr_df

##Nothing
S_epi_mtx_vs_C_gran_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_granulosum", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_epi_mtx_vs_C_gran_mgx_Tw_corr_df <- S_epi_mtx_vs_C_gran_mgx_Tw_v1$corr_df


##
S_epi_mtx_vs_M_osloensis_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Moraxella_osloensis", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_epi_mtx_vs_M_osloensis_mgx_Tw_corr_df <- S_epi_mtx_vs_M_osloensis_mgx_Tw_v1$corr_df

####S_epi to other Staph bacteria on Toe webs

S_epi_mtx_vs_S_cap_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_capitis", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_epi_mtx_vs_S_cap_mgx_Tw_corr_df <- S_epi_mtx_vs_S_cap_mgx_Tw_v1$corr_df

#
S_epi_mtx_vs_S_hom_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_hominis", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_epi_mtx_vs_S_hom_mgx_Tw_corr_df <- S_epi_mtx_vs_S_hom_mgx_Tw_v1$corr_df

#

S_epi_mtx_vs_S_haem_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_haemolyticus", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_epi_mtx_vs_S_haem_mgx_Tw_corr_df <- S_epi_mtx_vs_S_haem_mgx_Tw_v1$corr_df

#
S_epi_mtx_vs_S_warneri_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_epidermidis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_warneri", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_epi_mtx_vs_S_warneri_mgx_Tw_corr_df <- S_epi_mtx_vs_S_warneri_mgx_Tw_v1$corr_df




```

S_hom to other non Staph bacteria on Toe webs


```{r}

#Nothing
S_hom_mtx_vs_C_keffir_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_hominis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Corynebacterium_kefirresidentii", cor_test = "spearman",
  manual_vst_nsub=FALSE)


S_hom_mtx_vs_C_keffir_mgx_Tw_corr_df <- S_hom_mtx_vs_C_keffir_mgx_Tw_v1$corr_df


#Nothing
S_hom_mtx_vs_C_tuber_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_hominis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Corynebacterium_tuberculostearicum", cor_test = "spearman",
  manual_vst_nsub=FALSE)


S_hom_mtx_vs_C_tuber_mgx_Tw_corr_df <- S_hom_mtx_vs_C_tuber_mgx_Tw_v1$corr_df




#Nothing
S_hom_mtx_vs_C_acnes_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_hominis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_acnes", cor_test = "spearman",
  manual_vst_nsub=FALSE)


S_hom_mtx_vs_C_acnes_mgx_Tw_corr_df <- S_hom_mtx_vs_C_acnes_mgx_Tw_v1$corr_df

##Nothing
S_hom_mtx_vs_C_gran_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_hominis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_granulosum", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_hom_mtx_vs_C_gran_mgx_Tw_corr_df <- S_hom_mtx_vs_C_gran_mgx_Tw_v1$corr_df


##
S_hom_mtx_vs_M_osloensis_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_hominis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Moraxella_osloensis", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_hom_mtx_vs_M_osloensis_mgx_Tw_corr_df <- S_hom_mtx_vs_M_osloensis_mgx_Tw_v1$corr_df

####S_hom to other Staph bacteria on Toe webs

S_hom_mtx_vs_S_cap_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_hominis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_capitis", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_hom_mtx_vs_S_cap_mgx_Tw_corr_df <- S_hom_mtx_vs_S_cap_mgx_Tw_v1$corr_df

#
S_hom_mtx_vs_S_epi_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_hominis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_epidermidis", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_hom_mtx_vs_S_epi_mgx_Tw_corr_df <- S_hom_mtx_vs_S_epi_mgx_Tw_v1$corr_df

#

S_hom_mtx_vs_S_haem_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_hominis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_haemolyticus", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_hom_mtx_vs_S_haem_mgx_Tw_corr_df <- S_hom_mtx_vs_S_haem_mgx_Tw_v1$corr_df

#
S_hom_mtx_vs_S_warneri_mgx_Tw_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Tw_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Tw_ids,
  species_transcriptome_name = "Staphylococcus_hominis",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_warneri", cor_test = "spearman",
  manual_vst_nsub=FALSE)

S_hom_mtx_vs_S_warneri_mgx_Tw_corr_df <- S_hom_mtx_vs_S_warneri_mgx_Tw_v1$corr_df




```

C_acnes vs other bacteria/fungi in cheeks

```{r}

C_acnes_mtx_vs_C_keffir_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Cutibacterium_acnes",
  species_transcriptome_read_threshold=200000,
  responding_species = "Corynebacterium_kefirresidentii", cor_test = "spearman",
  manual_vst_nsub=FALSE)


C_acnes_mtx_vs_C_keffir_mgx_Ch_corr_df <- C_acnes_mtx_vs_C_keffir_mgx_Ch_v1$corr_df



##
C_acnes_mtx_vs_S_epi_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Cutibacterium_acnes",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_epidermidis", cor_test = "spearman",
  manual_vst_nsub=FALSE)


C_acnes_mtx_vs_S_epi_mgx_Ch_corr_df <- C_acnes_mtx_vs_S_epi_mgx_Ch_v1$corr_df

##One hit to a lysophospholipase, but another hit in the opposite direction to a triacylglycerol lipase
C_acnes_mtx_vs_C_gran_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Cutibacterium_acnes",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_granulosum", cor_test = "spearman",
  manual_vst_nsub=FALSE)

C_acnes_mtx_vs_C_gran_mgx_Ch_corr_df <- C_acnes_mtx_vs_C_gran_mgx_Ch_v1$corr_df

ggscatter(aldex_clr_values_fmt$Ch_bracken_clr %>% dplyr::filter(mtx_LIBID %in% C_acnes_mtx_vs_C_gran_mgx_Ch_v1$transcript_and_mgx_abundance_df$mtx_LIBID), x = "Cutibacterium_acnes", 
          y = "Cutibacterium_granulosum", add = "reg.line") + stat_cor(method="spearman")


#Nothing
C_acnes_mtx_vs_S_cap_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Cutibacterium_acnes",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_capitis", cor_test = "spearman",
  manual_vst_nsub=FALSE)


C_acnes_mtx_vs_S_cap_mgx_Ch_corr_df <- C_acnes_mtx_vs_S_cap_mgx_Ch_v1$corr_df



#To self
##Nothing
C_acnes_mtx_vs_C_acnes_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Cutibacterium_acnes",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_acnes", cor_test = "spearman",
  manual_vst_nsub=FALSE)

C_acnes_mtx_vs_C_acnes_mgx_Ch_corr_df <- C_acnes_mtx_vs_C_acnes_mgx_Ch_v1$corr_df



##Nothing
C_acnes_mtx_vs_C_modestum_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Cutibacterium_acnes",
  species_transcriptome_read_threshold=200000,
  responding_species = "Cutibacterium_modestum", cor_test = "spearman",
  manual_vst_nsub=FALSE)

C_acnes_mtx_vs_C_modestum_mgx_Ch_corr_df <- C_acnes_mtx_vs_C_modestum_mgx_Ch_v1$corr_df

#
C_acnes_mtx_vs_M_res_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Cutibacterium_acnes",
  species_transcriptome_read_threshold=200000,
  responding_species = "Malassezia_restricta", cor_test = "spearman",
  manual_vst_nsub=FALSE)

C_acnes_mtx_vs_M_res_mgx_Ch_corr_df <- C_acnes_mtx_vs_M_res_mgx_Ch_v1$corr_df


C_acnes_mtx_vs_M_glo_mgx_Ch_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Ch_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Ch_ids,
  species_transcriptome_name = "Cutibacterium_acnes",
  species_transcriptome_read_threshold=200000,
  responding_species = "Malassezia_globosa", cor_test = "spearman",
  manual_vst_nsub=FALSE)

C_acnes_mtx_vs_M_glo_mgx_Ch_corr_df <- C_acnes_mtx_vs_M_glo_mgx_Ch_v1$corr_df




#Nothing
C_acnes_mtx_vs_S_hom_mgx_Vf_v1 <- get_mtx_vs_mgx_correlation_v1(mtx_count_matrix = eight_skin_bact_mtx_counts_matrix,
                                              abundance_df = aldex_clr_values_fmt[["Vf_bracken_clr"]],
                                   secretory_prediction_df = eight_skin_microbial_secretory,
  site_libs=mtx_Vf_ids,
  species_transcriptome_name = "Cutibacterium_acnes",
  species_transcriptome_read_threshold=200000,
  responding_species = "Staphylococcus_hominis", cor_test = "spearman",
  manual_vst_nsub=TRUE)


C_acnes_mtx_vs_S_hom_mgx_Vf_corr_df <- C_acnes_mtx_vs_S_hom_mgx_Vf_v1$corr_df

#Too few samples for the opposite correlation of S hom mtx vs C acnes mgx on Vf



```

## Outdated definition of "core" and "variable" taxa for each skin site. 

Refer to transcription abundance as TPM(RNA)/CPM(DNA)

Strategy to define them:

1) Core, higher expression: detected in >= 80% of site specific samples with median normalized transcription activity  > 1 IN DETECTED SAMPLES
2) Core, lower expression: detected in >= 80% of site specific samples with median normalized transcription activity =< 1 IN DETECTED SAMPLES

3) Variable, higher expression: detected in < 80% of site specific samples with median RNA/DNA transcription activity > 1 IN DETECTED SAMPLES. Detected in at least two samples.
4) Variable, lower expression: detected in < 80% of site specific samples with median RNA/DNA transcription activity  =< 1 IN DETECTED SAMPLES. Detected in at least two samples.


Define WITH AND WITHOUT "Malassezia" fungi affecting the TPM and transcription activity calculations? Maybe.


```{r}
#With malassezia
find_mtx_taxa_categories <- function(site, input_list=combined_taxa_count_list){
  
  site_vector <- mtx_stats_chosen %>% dplyr::filter(region==site) %>% pull(LIBID)
  
  no_of_samples <- length(input_list[site_vector])
  
  site_df <- do.call("rbind", input_list[site_vector])
  
  ######################
  #For measured features
  #####################
  #dataframe summarizing the frequency of detection across sites
  #https://stackoverflow.com/questions/55645082/dplyr-row-count-by-group-excluding-zeros
  
  freq_measured_df <- site_df %>% dplyr::filter(transcriptional_activity != 0) %>% group_by(k2_taxon) %>% 
    summarise_at(vars(transcriptional_activity), ~sum(. != 0)) %>% dplyr::rename(n_detected=transcriptional_activity)
  
  freq_measured_df$percent_detected_at_site <- (freq_measured_df$n_detected/no_of_samples)*100
   
  #dataframe summarizing median transcriptional_activity (TPM/CPM) for features in samples with measured activity ONLY, per feature
 
  median_measured_df <- site_df %>% dplyr::filter(transcriptional_activity != 0) %>% group_by(k2_taxon) %>% 
    summarise(median_detect_transcriptional_activity = median(transcriptional_activity),
              mean_detect_transcriptional_activity = mean(transcriptional_activity))
  
  combined_df <- merge(freq_measured_df, median_measured_df, by = "k2_taxon", all.x=TRUE)
  
  #all features must be measured in at least two independent samples of the same site.
  combined_df <- combined_df %>% dplyr::filter(n_detected >= 2)
  
  combined_df$transcript_cat <- ifelse(combined_df$percent_detected_at_site >= 80 & 
                                         combined_df$median_detect_transcriptional_activity > 1, "Core_high",
                                         "temp_placeholder")
  
  combined_df$transcript_cat <- ifelse(combined_df$percent_detected_at_site >= 80 & 
                                         combined_df$median_detect_transcriptional_activity <= 1, "Core_low",
                                       combined_df$transcript_cat)
  
  combined_df$transcript_cat <- ifelse(combined_df$percent_detected_at_site < 80 & 
                                         combined_df$median_detect_transcriptional_activity > 1, "Variable_high",
                                       combined_df$transcript_cat)
  
  combined_df$transcript_cat <- ifelse(combined_df$percent_detected_at_site < 80 & 
                                         combined_df$median_detect_transcriptional_activity <= 1,
                                         "Variable_low",
                                       combined_df$transcript_cat)

  combined_df$region <- site
  return(combined_df)
 
}

```

What proportion of taxa (excluding "unclassified) fall into each category per site? 

```{r eval=FALSE}

TSS_abun_fn <- function(df, site){
  
  output <- plyr::count(df, "transcript_cat")
  output$region <- site
  output$cat_abun <- (output$freq/sum(output$freq))*100
  return(output)
}


Ac_species_ratio_summary <- TSS_abun_fn(Ac_species_ratio, 
                                   site="Ac")
    
Vf_species_ratio_summary <- TSS_abun_fn(Vf_species_ratio, 
                                   site="Vf")
    
Tw_species_ratio_summary <- TSS_abun_fn(Tw_species_ratio, 
                                   site="Tw")
    
Ch_species_ratio_summary <- TSS_abun_fn(Ch_species_ratio, 
                                   site="Ch")
    
Sc_species_ratio_summary <- TSS_abun_fn(Sc_species_ratio, 
                                   site="Sc")

species_ratio_summary_df <- do.call("rbind", list(Ac_species_ratio_summary,
                                                  Vf_species_ratio_summary,
                                                  Tw_species_ratio_summary,
                                                  Ch_species_ratio_summary,
                                                  Sc_species_ratio_summary))

plot_feature_cat <- function(df, title){
  
  totals <- df %>% group_by(region) %>% summarize(n_total=sum(freq))
  
  ggplot(df, aes(x=region, y=cat_abun, fill=transcript_cat)) + geom_col() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.title.x=element_blank()) + 
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle(title) + 
  scale_fill_manual(values=c24)+ 
  geom_text(inherit.aes=FALSE, data=totals, aes(x=region, y= 90, label = n_total))
  
} 


###For taxa analysis

taxa_transcription_summary_cat<- plot_feature_cat(species_ratio_summary_df %>% 
                   mutate(region= fct_relevel(region, "Sc", "Ch", "Ac", "Vf", "Tw"),
                          transcript_cat=fct_relevel(transcript_cat,
                                                     "Core_high",
                                                     "Core_low",
                                                     "Variable_high",
                                                     "Variable_low")), 
                 title="Species with transcriptional activity across skin sites")

ggsave(filename="../plots/taxa_transcription/taxa_transcription_summary_cat.pdf", plot=taxa_transcription_summary_cat)

taxa_transcription_summary_cat


```
## Balloon plot for core and variable taxa across sites

A balloon plot (not dot plot) is preferred over a heatmap because we can show two dimensions of information: median transcriptional activity with color and % prevalence with dot size. Skin sites on x axis, species names on y axis.
```{r eval=FALSE}


all_sites_species_ratio <- do.call("rbind", tibble::lst(Sc_species_ratio,
                                                   Ch_species_ratio,
                                                   Ac_species_ratio,
                                                   Vf_species_ratio,
                                                   Tw_species_ratio)) 


all_sites_species_ratio <- all_sites_species_ratio %>%  mutate(region= fct_relevel(region, "Sc", "Ch", "Ac", "Vf", "Tw"))

all_sites_species_ratio$log2_median_detect_transcriptional_activity <- log2(all_sites_species_ratio$median_detect_transcriptional_activity)

all_sites_species_ratio$k2_taxon <- as.factor(all_sites_species_ratio$k2_taxon)

#https://stackoverflow.com/questions/58718527/setting-midpoint-for-continuous-diverging-color-scale-on-a-heatmap
#A notable downside is that you'd have to provide the values argument in rescaled space, so between 0-1. Consider if your fill values range from 0-10 instead and want the midpoint on 0.7, you'd have to provide values = c(0, 0.07, 1). The solution is to use  rescale() for to map an arbitrary range to between 0 and 1

#rescale(c(-5,0,1,5,15), to = c(0,1)) #this vector goes to the values argument in scale_fill_gradientn()

taxa_trans_activity_balloon <- ggballoonplot(data=all_sites_species_ratio,
                                        x="region", y ="k2_taxon", 
                                        fill="log2_median_detect_transcriptional_activity",
                                        size="percent_detected_at_site",
                                        size.range=c(1,10)) + 
                                        scale_fill_gradientn(colors = c("#2c7bb6","#abd9e9", "#ffffbf","#fdae61","#d7191c"),
                                                             values = c(0.00,0.25, 0.30, 0.5, 1.00))



#taxa_trans_activity_balloon

#Landscape format for slides
#https://stackoverflow.com/questions/37488075/align-axis-label-on-the-right-with-ggplot2
taxa_trans_activity_balloon_landscape <- ggballoonplot(data=all_sites_species_ratio,
                                        x="k2_taxon", y ="region", 
                                        fill="log2_median_detect_transcriptional_activity",
                                        size="percent_detected_at_site",
                                        size.range=c(1,10)) + 
                                        scale_fill_gradientn(colors = c("#2c7bb6","#abd9e9", "#ffffbf","#fdae61","#d7191c"),
                                                             values = c(0.00,0.25, 0.30, 0.5, 1.00)) +
                                        rotate_x_text(angle = 90, hjust = 0.95, vjust=0.2)



ggsave(filename="../plots/taxa_transcription/taxa_trans_activity_balloon.pdf" ,
       plot=taxa_trans_activity_balloon_landscape,
       height = 11, width = 14.5)

taxa_trans_activity_balloon_landscape
```



## Heatmap no longer used because a dotplot is beter
```{r eval=FALSE}
#Inferred taxa in separate heat map
##Color intensity should be based on median transcriptional activity
#Unused function for heatmapping. Still quite useful in general
prepare_taxa_heatmap_input <- function(input_list=list(Tw_species_ratio,
                                                       Ch_species_ratio,
                                                       Vf_species_ratio,
                                                       Ac_species_ratio,
                                                       Sc_species_ratio), mode){
  
  if (mode=="core_measured"){
	input_fmt <- lapply(input_list, function(df){
  
    df_fmt <- df %>% dplyr::filter(transcript_cat == "Core_high" | transcript_cat == "Core_low") %>% 
      dplyr::select(c("k2_taxon","region","median_detect_transcriptional_activity","transcript_cat"))
     
    return(df_fmt) 
	})
  } else if (mode=="variable_measured"){
	
	input_fmt <- lapply(input_list, function(df){
  
    df_fmt <- df %>% dplyr::filter(transcript_cat == "Variable_high" | transcript_cat == "Variable_low") %>% 
      dplyr::select(c("k2_taxon","region","median_detect_transcriptional_activity","transcript_cat")) 
    return(df_fmt)
  })
  } else if (mode=="variable_high"){
	
	input_fmt <- lapply(input_list, function(df){
  
    df_fmt <- df %>% dplyr::filter(transcript_cat == "Variable_high") %>% 
      dplyr::select(c("k2_taxon","region","median_detect_transcriptional_activity","transcript_cat"))
    return(df_fmt)
  })
  } else if (mode=="variable_low"){
	
	input_fmt <- lapply(input_list, function(df){
  
    df_fmt <- df %>% dplyr::filter(transcript_cat == "Variable_low") %>% 
      dplyr::select(c("k2_taxon","region","median_detect_transcriptional_activity","transcript_cat"))
    return(df_fmt)
  })
  }
 
  
  input_fmt <- do.call("rbind",input_fmt)
  
  input_fmt$tx_exp_pattern <- paste0(input_fmt$region,"_",input_fmt$transcript_cat)
  return(input_fmt)
}


taxa_core_measured_heatmap_input <- prepare_taxa_heatmap_input(mode="core_measured")

taxa_variable_measured_heatmap_input <- prepare_taxa_heatmap_input(mode="variable_measured")

taxa_variable_high_heatmap_input <- prepare_taxa_heatmap_input(mode="variable_high")


## 
#Default color code from https://loading.io/color/feature/RdYlBu-5/
make_taxa_cheatmap <- function(save= FALSE, cluster=FALSE,
                                 plot_name="taxa_heatmap.pdf", 
                                 scale_vec=c(-2,-1, 0,1, 2),
                               color_codes=c("#2c7bb6","#abd9e9",
                                              "#ffffbf","#fdae61",
                                                "#d7191c"),
                                 plot_height=15, plot_width=15,
                                 font_size = 4, input_df){
  
  input_df <- input_df %>% mutate(region= fct_relevel(region, "Sc", "Ch", "Ac", "Vf", "Tw")) %>% 
    dplyr::filter(k2_taxon != "unclassified")
  
  input_df$log2_transcriptional_activity <- log2(input_df$median_detect_transcriptional_activity)
  
  #Construct the feature matrix. Samples/skin sites in columns, taxa in rows
  #
  feature_matrix <- pivot_wider(input_df %>% 
                        dplyr::select(k2_taxon, log2_transcriptional_activity , region), 
                        names_from = region, values_from = log2_transcriptional_activity) %>%
                        as.data.frame()
  
  
  rownames(feature_matrix) <- feature_matrix$k2_taxon
  
  feature_matrix <- feature_matrix %>% dplyr::select(-k2_taxon) %>% as.matrix()
  ##Caution: It is not appropriate to replace NA values in this feature matrix to 0 if you are using the log2 transform.
  
  #Order species (row names) in alphabetical order
  feature_matrix <- feature_matrix[order(rownames(feature_matrix)),]
  

if(cluster==FALSE){  
 hmap <- Heatmap(feature_matrix,
                  name="log2 median normalized transcription abundance",
                  
                  #Row annotation configurations
                  cluster_rows=FALSE,
                  show_row_dend=FALSE,
                  show_row_names = TRUE,
                  row_names_side = "left",
                  
                  
                  #No clustering of columns since this is manual definition
                  cluster_columns=FALSE,
                  column_order=c("Sc", "Ch", "Ac", "Vf", "Tw"),
                  
        
                  col=circlize::colorRamp2(scale_vec, color_codes),
      
                  #Color NA values as black if any
                  na_col = "black",
                  
                  #Annotations (row annotation must be added with 'draw' function, below)
                  #top_annotation=ColAnn,
                  
                  #Do not rasterize
                  use_raster=FALSE,
                  
                  #font and dimensions
                  row_names_gp = gpar(fontsize = font_size),
                  width = unit(plot_width, "cm"),
                  height = unit(plot_height, "cm")
                  )
} else if (cluster==TRUE){
  #Replace the NA values in the scaled matrix with an arbitrarily small negative number for the clustering to work...
  feature_matrix[is.na(feature_matrix)] <- -20
  
   hmap <- Heatmap(feature_matrix,
                  name="log2 median normalized transcription abundance",
                  
                  #Row annotation configurations
                  cluster_rows=TRUE,
                  show_row_dend=FALSE,
                  show_row_names = TRUE,
                  row_names_side = "left",
                  
                  
                  #No clustering of columns since this is manual definition
                  cluster_columns=FALSE,
                  column_order=c("Sc", "Ch", "Ac", "Vf", "Tw"),
                  
                  #Dendrogram configurations: rows
                  clustering_method_rows="complete",
                  
                  #get hexacodes from https://loading.io/color/feature/RdYlBu-5/
                 
                  col=circlize::colorRamp2(scale_vec, color_codes),
      
                  #Color NA values as black if any
                  na_col = "black",
                  
                  #Annotations (row annotation must be added with 'draw' function, below)
                  #top_annotation=ColAnn,
                  
                  #Do not rasterize
                  use_raster=FALSE,
                  
                  #font and dimensions
                  row_names_gp = gpar(fontsize = font_size),
                  width = unit(plot_width, "cm"),
                  height = unit(plot_height, "cm")
                  )
  
}
 
  if(save==TRUE){
  pdf(file= paste0("../plots/feature_heatmap/",plot_name))
    
  draw(hmap, heatmap_legend_side="right", annotation_legend_side="right")
  
  dev.off()
    
  } else {
    
  draw(hmap, heatmap_legend_side="right", annotation_legend_side="right") 
  
  } 
 
 
}

make_taxa_cheatmap(input_df=taxa_core_measured_heatmap_input)

make_taxa_cheatmap(input_df=taxa_core_measured_heatmap_input, save=TRUE, plot_name = "taxa_core_measured_heatmap.pdf")


##HEAT maps are not ideal for variable features because core features would look "black". I should do a dot plot where size of dot is proportional to prevalence and color change according to median transcriptional activitiy
###Repeat for variable features


make_taxa_cheatmap(input_df=taxa_variable_measured_heatmap_input,
                   cluster = TRUE, scale_vec = c(-20,-5,-1,0,1,5),
                   color_codes = c(color_codes=c("black","#2c7bb6","#abd9e9",
                                              "#ffffbf","#fdae61",
                                                "#d7191c")))

make_taxa_cheatmap(input_df=taxa_variable_measured_heatmap_input,
                   save=TRUE,
                   plot_name = "taxa_variable_measured_heatmap.pdf",
                   cluster = TRUE, scale_vec = c(-20,-5,-1,0,1,5),
                   color_codes = c(color_codes=c("black","#2c7bb6","#abd9e9",
                                              "#ffffbf","#fdae61",
                                                "#d7191c")))

```

