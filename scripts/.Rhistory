slice_max(rel_abun, n=number_of_hits) %>% dplyr::select(rel_abun, k2_taxon, all_of(sample_identifier))
other_rel_abun <- 100 - sum(top_df$rel_abun)
identifier_vec <- top_df %>% pull(get(sample_identifier)) %>% unique()
other_df <- data.frame(k2_taxon="others",
rel_abun=other_rel_abun,
PLACEHOLDER=identifier_vec)
colnames(other_df)[3] <- sample_identifier
output <- rbind(top_df, other_df)
taxa_to_add <- top_df$k2_taxon
output$k2_taxon <- factor(output$k2_taxon)
output$k2_taxon <- relevel(output$k2_taxon, "others")
return(output)
}
#subset_key, identifier and merging_key can be a string like "Library_ID"
get_simple_profile_filtered <- function(input_list, input_metadata, subset_key, n, identifier, merging_key) {
subset_vector <- input_metadata %>% pull(get(subset_key))
input_list_subset <- input_list[subset_vector]
profile <- lapply(input_list_subset, function(x){get_top_filtered(x,n, sample_identifier = identifier)})
profile <- do.call("rbind", profile)
taxa_to_add <- profile %>% pull(k2_taxon) %>% unique() %>% sort()
taxa_to_add <- taxa_to_add[!taxa_to_add %in% c("others" )] %>% as.character()
#Now this ENTIRE VECTOR of taxa_to_add will be used to re-separate the species of EACH library into "others" vs the species to   be plotted on a bar chart
final_profile <- lapply(input_list_subset, function(df){
taxa_df <- df %>% dplyr::filter(taxa_pass_filter==TRUE) %>% dplyr::filter(k2_taxon %in% taxa_to_add) %>%
dplyr::select(rel_abun, k2_taxon, all_of(identifier))
#This works because we are not removing any features from "taxa_df" = not changing the denominator for rel abundance
other_rel_abun <- 100 - sum(taxa_df$rel_abun)
id <- taxa_df %>% pull(get(identifier)) %>% unique()
other_df <- data.frame(k2_taxon="others",
rel_abun=other_rel_abun,
PLACEHOLDER=id)
colnames(other_df)[3] <- identifier
df_out <- rbind(taxa_df, other_df)
return(df_out)
})
final_profile <- do.call("rbind", final_profile)
output <- merge (final_profile, input_metadata, by = merging_key, all.x=TRUE)
#re-arrange factor levels so that "others" always come first :)
#Unclassified read fraction should have been removed prior to this.
output$k2_taxon <- factor(output$k2_taxon)
output$k2_taxon <- relevel(output$k2_taxon, "others")
return(output)
}
#colorblind friendly palette
c24 <- c(
"dodgerblue2", "#E31A1C", # red
"green4",
"#6A3D9A", # purple
"#FF7F00", # orange
"black", "gold1",
"skyblue2",
"palegreen2",
"#CAB2D6", # lt purple
"#FDBF6F", # lt orange
"gray70", "khaki2",
"maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
"darkturquoise", "green1", "yellow4", "yellow3",
"darkorange4", "brown"
)
#an expanded color palette from the Polychrome package
Glasbey_26 <- glasbey.colors(26) %>% unname()
rel_abun_plot_fn <- function(df, x_var, title){
x_var_to_plot <- enquo(x_var)
df %>%
ggplot(aes(fill=k2_taxon, y=rel_abun, x=!!x_var_to_plot)) +   #change x to SAMPLE_ID for larger datasets
geom_col()+
theme_classic() +
scale_fill_manual(values = c24 ) +
scale_y_continuous(expand = c(0, 0)) +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(legend.text=element_text(size=8), axis.title.x=element_blank()) +
ggtitle(title) +
ylab("relative abundance") +guides(fill=guide_legend(ncol=2))}
rel_abun_filt_plot_fn <- function(df, x_var, title){
x_var_to_plot <- enquo(x_var)
df %>%
ggplot(aes(fill=k2_taxon, y=rel_abun, x=!!x_var_to_plot)) +
geom_col()+
theme_classic() +
scale_fill_manual(values = c24 ) +
scale_y_continuous(expand = c(0, 0)) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
theme(legend.text=element_text(size=8), axis.title.x=element_blank()) +
ggtitle(title) +
ylab("relative abundance") +guides(fill=guide_legend(ncol=2))}
rel_abun_plot_fn2 <- function(df, x_var, title){
x_var_to_plot <- enquo(x_var)
df %>%
ggplot(aes(fill=k2_taxon, y=rel_abun, x=!!x_var_to_plot)) +
geom_col()+
theme_classic() +
scale_fill_manual(values = Glasbey26 ) +  #Use Glasbey26 to expand the color palette if necessary
scale_y_continuous(expand = c(0, 0)) +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
theme(legend.text=element_text(size=8), axis.title.x=element_blank()) +
ggtitle(title) +
ylab("relative abundance") }
##Aux functions for get_fastspar_inputs
#"Name" refers to species/OTU name
get_counts_fn <- function(sample_name, df){
df_filtered <- df  %>% dplyr::select(c(name, paired_reads))
colnames(df_filtered)[2] <- sample_name
#Replace spaces in species names with "_"
df_filtered$name <- gsub(pattern=" ", replacement="_", df_filtered$name)
return(df_filtered)
}
get_abun_fn <- function(sample_name, df){
df_filtered <- df  %>% dplyr::select(c(name, rel_abun))
#rescale abundances
df_filtered$rel_abun <-  (df_filtered$rel_abun /100)
colnames(df_filtered)[2] <- sample_name
#Replace spaces in species names with "_"
df_filtered$name <- gsub(pattern=" ", replacement="_", df_filtered$name)
return(df_filtered)
}
#function to obtain fastspar inputs from Kraken2 data
#input_list can be MTX_species_k2[mtx_to_pull] or MGX_species_k2[mgx_to_pull]
#The elements of the input_list must be named according to their LIBID
#anno_taxon is name, sample is LIBID
get_fastspar_inputs <- function(input_list){
list_subset_counts <- lapply(names(input_list),
function(x){get_counts_fn(sample_name=x, df=input_list[[x]])})
#Reduce is like a sequential merges to get a "wide" dataframe where each row is an OTU/species "name" and each column after the first, is a LIBID
count_df <- Reduce(function(x,y,...) merge(x,y, by ="name",all=TRUE), list_subset_counts)
list_subset_abun <- lapply(names(input_list),
function(x){get_abun_fn(sample_name=x, df=input_list[[x]])})
abun_df <- Reduce(function(x,y,...) merge(x,y, by ="name",all=TRUE), list_subset_abun)
#change NA to 0
count_df[is.na(count_df)] <- 0
abun_df[is.na(abun_df)] <- 0
colnames(count_df)[1] <- "#OTU ID"
colnames(abun_df)[1] <- "#OTU ID"
#Only retain species with average paired read count > = 10
# https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002687
# This is similar to the criteria in the original sparCC paper:
#the data was further filtered by removing samples for which less than 500 reads were collected and OTUs that were, on average, represented by less   than 2 reads per sample.
#It may not be practical to perform sparCC for each body site due to small sample size. However,  contaminant signals should be well-correlated       regardless of body site
#A threshold of mean 2 reads per sample still leave over 5000+ species. That's unnecessary.
mean_count <- apply(count_df[,-1],1, mean)
mean_mask <- ifelse(mean_count >= 10, TRUE, FALSE)
filtered_count_df <- count_df[mean_mask,]
return(tibble::lst(count_df, abun_df, filtered_count_df))
}
#############################################################
#functions to load and process fastspar correlation matrices#
#############################################################
load_mat <- function(path_string){
result_df <- read_tsv(path_string, col_names = TRUE, show_col_types = FALSE) %>% as.data.frame() #setting rownames on tibble is depreciated
row.names(result_df) <- result_df$`#OTU ID`
result_df <- result_df[,-1]
output <- data.matrix(result_df)
return(output)
}
#Removes duplicates by taking lower triangle of corr and p value matrix from fastspar results, get corr coeff and p vals. Inputs are two matrices
get_edges_fn <- function(corr_mat, corr_pval){
df_corr <- melt(replace(corr_mat, lower.tri(corr_mat, TRUE), NA), na.rm = TRUE) %>% dplyr::rename(corr_coeff=value)
df_pval <- melt(replace(corr_pval, lower.tri(corr_pval, TRUE), NA), na.rm = TRUE)%>% dplyr::rename(pval=value)
output <- merge(df_corr, df_pval, by = c("Var1", "Var2") )
return(output)
}
save_pheatmap_pdf <- function(x, filename, width=30, height=30) {
pdf(filename, width = width, height = height)
grid::grid.newpage()
grid::grid.draw(x$gtable)
dev.off()
}
#add the mtx pos control triplicates to load.
#library IDs of positive and negative controls for mtx data
mtx_control_LIBIDs <- mtx_passed %>% dplyr::filter(region=="neg-ctrl" | region == "pos-ctrl") %>% pull(LIBID)
mtx_neg_control_LIBIDs <- mtx_passed %>% dplyr::filter(region=="neg-ctrl") %>% pull(LIBID)
mgx_neg_control_LIBIDs <- mgx_stats %>% dplyr::filter(region=="neg-ctrl") %>% pull(LIBID)
mtx_selected_libs_with_ctrl <- c(mtx_selected_libs, mtx_control_LIBIDs) %>% unique(.)
MTX_species_k2 <- lapply(mtx_selected_libs_with_ctrl, function(x){
read_tsv(paste0("../data/kraken2/RNA/",x,"_merged_k2.s.tsv"),
col_names = c("rel_abun", "paired_reads", "k2_taxon"),
show_col_types = FALSE)
})
names(MTX_species_k2) <- mtx_selected_libs_with_ctrl
MTX_species_k2 <- lapply(names(MTX_species_k2), function(x){
MTX_species_k2[[x]]$LIBID <- x
return(MTX_species_k2[[x]])
})
full_MTX_species <- do.call("rbind", MTX_species_k2)
names(MTX_species_k2) <- mtx_selected_libs_with_ctrl
####
mtx_neg_ctrl_libs <- c("MHS340", "MHS348", "MHS431", "MHS602")
MTX_neg_ctrl_genus_k2 <- lapply(mtx_neg_ctrl_libs, function(x){
read_tsv(paste0("../data/kraken2/RNA/",x,"_merged_k2.g.tsv"),
col_names = c("rel_abun", "paired_reads", "name"),
show_col_types = FALSE)
})
names(MTX_neg_ctrl_genus_k2) <- mtx_neg_ctrl_libs
MTX_neg_ctrl_genus_k2 <- lapply(names(MTX_neg_ctrl_genus_k2), function(x){
MTX_neg_ctrl_genus_k2[[x]]$LIBID <- x
return(MTX_neg_ctrl_genus_k2[[x]])
})
names(MTX_neg_ctrl_genus_k2) <- mtx_neg_ctrl_libs
#Exclude any taxa with reads of below 0.1% relative abundance
#Then remove human component and renormalize to 100% for non-human reads. Still includes "unclassified"
MTX_neg_ctrl_genus_k2_renorm <- lapply(MTX_neg_ctrl_genus_k2, function(x){
df_no_human <- x %>% dplyr::filter(name != "Homo") %>% dplyr::filter(rel_abun >= 0.1) %>%
mutate(renorm = rel_abun/sum(rel_abun)*100) %>% dplyr::select(-rel_abun) %>% dplyr::rename(rel_abun=renorm)
return(df_no_human)
})
#Get vector of contaminant genera across the three negative controls. Look for genera not associated with healthy humans (likely environmental)
#There are 49 genera in total. Label the human associated ones
mtx_contam_genera <- do.call("rbind", MTX_neg_ctrl_genus_k2_renorm) %>% dplyr::select(name) %>% unique() %>% dplyr::filter(name != "unclassified")
#Do the same for mgx contaminant genera. MHS580 is also a negative control, but was not sequenced due to library failure.
mgx_neg_ctrl_libs <- c("MHS470", "MHS524", "MHS552", "MHS566", "MHS581")
MGX_neg_ctrl_genus_k2 <- lapply(mgx_neg_ctrl_libs, function(x){
read_tsv(paste0("../data/kraken2/DNA/",x,"_merged_k2.g.tsv"),
col_names = c("rel_abun", "paired_reads", "name"),
show_col_types = FALSE)
})
names(MGX_neg_ctrl_genus_k2) <- mgx_neg_ctrl_libs
MGX_neg_ctrl_genus_k2 <- lapply(names(MGX_neg_ctrl_genus_k2), function(x){
MGX_neg_ctrl_genus_k2[[x]]$LIBID <- x
return(MGX_neg_ctrl_genus_k2[[x]])
})
names(MGX_neg_ctrl_genus_k2) <- mgx_neg_ctrl_libs
#Exclude any taxa with reads of below 0.1% relative abundance
#Then remove human component and renormalize to 100% for non-human reads. Still includes "unclassified"
#Also remove genera corresponding to spike-ins: Vibrio, Plesiomonas and Listeria
MGX_neg_ctrl_genus_k2_renorm <- lapply(MGX_neg_ctrl_genus_k2, function(x){
df_no_human <- x %>% dplyr::filter(!name %in% c("Homo", "Listeria", "Plesiomonas", "Vibrio")) %>% dplyr::filter(rel_abun >= 0.1) %>%
mutate(renorm = rel_abun/sum(rel_abun)*100) %>% dplyr::select(-rel_abun) %>% dplyr::rename(rel_abun=renorm)
return(df_no_human)
})
mgx_contam_genera <- do.call("rbind", MGX_neg_ctrl_genus_k2_renorm) %>% dplyr::select(name) %>% unique() %>% dplyr::filter(name != "unclassified")
#Other host-microbe databases: https://academic.oup.com/nar/article/50/D1/D808/6413603
#MicroPhenoDB https://pubmed.ncbi.nlm.nih.gov/33418085/ (Last checked on 27th Sep 2022)
#Annotate contaminants, remove any species belonging to those genera which were not described on skin for disbiome and microphenoDB and manual NCBI search e.g. ("ACIDOVORAX" AND "Skin" AND "microbiome" AND "human" -> manually survey reports for this genera on healthy human skin). Also remove reads belong to human + the 3 bact spike in.
#Last pubmed search date: 24th Nov 2022
#load disbiome and microphenoDB results for genera reported on skin, both for mgx and mtx data
disbiome_skin_res <- read_tsv("../metadata/mtx_contam_genera.tsv")
initial_contam <- c(disbiome_skin_res %>%
filter(reported_for_skin_disease_in_disbiome == FALSE &
reported_on_skin_in_microphenoDB ==FALSE &
pubmed_skin_microbiome == FALSE) %>%
pull(name))
genera_to_remove <- c(disbiome_skin_res %>%
filter(reported_for_skin_disease_in_disbiome == FALSE &
reported_on_skin_in_microphenoDB ==FALSE &
pubmed_skin_microbiome == FALSE) %>%
pull(name), "Homo", "Listeria", "Plesiomonas", "Vibrio") #34 candidates to remove
#Use correlation analysis to remove more species. Use sparCC/fastspar.
#How many MGX libraries from subjects are suitable for analysis? There is only one failure in MHS512
#MGX resequencing rescued SMT007_Ac. Use MHS592 instead of MHS512.
#While MGX resequencing was done for SMT007_Sc, this did not improve it. Use MHS513 instead of MHS601
#130 here
subjects_MGX <- mgx_stats %>% dplyr::filter(MICROBE_COUNT != 0 & !is.na(subj_region)) %>%
dplyr::filter(!region %in% c("neg-ctrl", "pos-ctrl")) %>%
dplyr::select(LIBID,subj_region, subject,region) %>% dplyr::rename(mgx_LIBID=LIBID)
#Resequencing for MTX rescued SMT027_Ac, SMT026_Ch and SMT005_Sc. Manually removed the failed ones from skin_mtx_metadata_fmt
#102 metatranscriptomes corresponding to subjects
subjects_MTX <- data.frame(LIBID=mtx_selected_libs) %>% merge(.,metadata%>%
dplyr::select(LIBID,subj_region),by="LIBID", all.x=TRUE) %>%
dplyr::filter(str_detect(subj_region, pattern="SMT")) %>% dplyr::rename(mtx_LIBID=LIBID)
# 102 Libraries with paired and usable MTX and MGX data:
paired_libraries <- merge(subjects_MGX, subjects_MTX, by = "subj_region")
mtx_to_pull <- paired_libraries %>% pull(mtx_LIBID)
mgx_to_pull <- paired_libraries %>% pull(mgx_LIBID)
mtx_stats_chosen <- mtx_stats %>% dplyr::filter(LIBID %in% mtx_to_pull)
plyr::count(mtx_stats_chosen, "region")
mgx_stats_chosen <- mgx_stats %>% dplyr::filter(LIBID %in% mgx_to_pull)
#write_tsv(data.frame(LIBID=mtx_to_pull), file = "../metadata/mtx_to_pull", col_names = FALSE)
#write_tsv(data.frame(LIBID=mgx_to_pull), file = "../metadata/mgx_to_pull", col_names = FALSE)
#Read count for mtx before de-duplication
median(mtx_stats_chosen$AFT_RIBO_RM)
median(mtx_stats_chosen$MICROBE_COUNT)
#read counts for mgx microbial reads
median(mgx_stats_chosen$MICROBE_COUNT)
View(subjects_MGX)
130/135
View(subjects_MTX)
102/135
View(mtx_passed)
View(mtx_stats)
test <- mtx_passed %>% dplyr::filter(comments != "technical replicate analysis")
mtx_non_human_proportion <- mtx_stats_chosen %>%
dplyr::select(subj_region, AFTER_FASTP, AFT_HUMAN_RM)
mtx_non_human_proportion$assay <- "metatranscriptome"
mtx_non_human_proportion$percent_non_human <- (mtx_non_human_proportion$AFT_HUMAN_RM / mtx_non_human_proportion$AFTER_FASTP)*100
mgx_non_human_proportion <- mtx_stats_chosen %>%
dplyr::select(subj_region, AFTER_FASTP, BT2_READS_START)
mgx_non_human_proportion$assay <- "metagenome"
mgx_non_human_proportion$percent_non_human <- (mgx_non_human_proportion$BT2_READS_START / mgx_non_human_proportion$AFTER_FASTP)*100
mtx_mgx_non_human_percent <- rbind(mtx_non_human_proportion %>%
dplyr::select(subj_region, percent_non_human, assay),
mgx_non_human_proportion %>%
dplyr::select(subj_region, percent_non_human, assay))
View(mtx_mgx_non_human_percent)
#
# Interestingly, the proportion of non-human reads was found to be significantly higher in metatranscriptomes versus metagenomes (XX% vs YY%, Wilcoxon signed rank p-value <0.05; Supplementary Figure 1D), underscoring the feasibility of skin metatranscriptomic sequencing."
median(mtx_non_human_proportion$percent_non_human)
ggpaired(mtx_mgx_non_human_percent, x = "assay", y = "percent_non_human",
line.color = "gray", line.size = 0.4,
palette = "jco")+ ylab("% of reads not mapped to hg38") +
stat_compare_means(paired = TRUE, method="wilcox.test")
#
median(mgx_non_human_proportion$percent_non_human) #97.9
0.23*10^9
2.3e+08/300
766666.7
?rarecurve
library(vegan)
?rarecurve
knitr::opts_chunk$set(echo = TRUE)
library(limma)
?removeBatchEffect
2475618 + 406505
1305256 + 317278
devtools::install_github("FrederickHuangLin/ANCOMBC"
)
?ancombc
?ancombc2
?ANCOMBC
?ancombc::
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(reshape2)
#############################################################
#functions to load and process fastspar correlation matrices#
#############################################################
load_mat <- function(path_string){
result_df <- read_tsv(path_string, col_names = TRUE, show_col_types = FALSE) %>% as.data.frame() #setting rownames on tibble is depreciated
row.names(result_df) <- result_df$`#OTU ID`
result_df <- result_df[,-1]
output <- data.matrix(result_df)
return(output)
}
#Removes duplicates by taking lower triangle of corr and p value matrix from fastspar results, get corr coeff and p vals. Inputs are two matrices
get_edges_fn <- function(corr_mat, corr_pval){
df_corr <- melt(replace(corr_mat, lower.tri(corr_mat, TRUE), NA), na.rm = TRUE) %>% dplyr::rename(corr_coeff=value)
df_pval <- melt(replace(corr_pval, lower.tri(corr_pval, TRUE), NA), na.rm = TRUE)%>% dplyr::rename(pval=value)
output <- merge(df_corr, df_pval, by = c("Var1", "Var2") )
return(output)
}
find_contam_corr <- function(df, contam_genera=initial_contam_mask){
df_filtered <- df %>% dplyr::filter(str_detect(df$Var1, contam_genera) | str_detect(df$Var2, contam_genera) )
return(df_filtered)
}
setwd("../Desktop/local_project/manuscript/skin_metatranscriptome/scripts/")
disbiome_skin_res <- read_tsv("../metadata/mtx_contam_genera.tsv", show_col_types = FALSE)
initial_contam <- c(disbiome_skin_res %>%
filter(reported_for_skin_disease_in_disbiome == FALSE &
reported_on_skin_in_microphenoDB ==FALSE &
pubmed_skin_microbiome == FALSE) %>%
pull(name))
genera_to_remove <- c(disbiome_skin_res %>%
filter(reported_for_skin_disease_in_disbiome == FALSE &
reported_on_skin_in_microphenoDB ==FALSE &
pubmed_skin_microbiome == FALSE) %>%
pull(name), "Homo", "Listeria", "Plesiomonas", "Vibrio") #34 candidates to remove
mgx_to_pull <- read_tsv("../metadata/mgx_to_pull", show_col_types = FALSE, col_names = "LIBID") %>% pull(LIBID)
neg_ctrl_MTX_LIBID <- c("MHS340",
"MHS348",
"MHS420",
"MHS431",
"MHS602")
neg_ctrl_MGX_LIBID <- c("MHS470",
"MHS524",
"MHS552",
"MHS566",
"MHS581")
# MGX full cohort
MGX_species_k2_filtered_df <- lapply(mgx_to_pull, function(x){
output <- read_tsv(file=paste0("../data/k2_species_renorm/DNA/",x,"_k2_renorm.s.tsv"),show_col_types = FALSE)
output$LIBID <- x
return(output)
}) %>% do.call("rbind",.)
# MTX full cohort
mtx_to_pull <- read_tsv("../metadata/mtx_to_pull", col_names = FALSE, show_col_types = FALSE) %>% pull(X1)
MTX_species_k2_filtered_df <- lapply(mtx_to_pull, function(x){
output <- read_tsv(file=paste0("../data/k2_species_renorm/RNA/",x,"_k2_renorm.s.tsv"),show_col_types = FALSE)
output$LIBID <- x
return(output)
}) %>% do.call("rbind",.)
MGX_neg_ctrl_species_k2_df <- lapply(neg_ctrl_MGX_LIBID, function(x){
output <- read_tsv(file=paste0("../data/kraken2/DNA/",x,"merged_decont_k2.s.tsv"),show_col_types = FALSE)
output$LIBID <- x
return(output)
}) %>% do.call("rbind",.)
MGX_neg_ctrl_species_k2_df <- lapply(neg_ctrl_MGX_LIBID, function(x){
output <- read_tsv(file=paste0("../data/kraken2/DNA/",x,"_merged_decont_k2.s.tsv"),show_col_types = FALSE)
output$LIBID <- x
return(output)
}) %>% do.call("rbind",.)
MGX_neg_ctrl_species_k2_df <- lapply(neg_ctrl_MGX_LIBID, function(x){
output <- read_tsv(file=paste0("../data/kraken2/DNA/",x,"_merged_decont_k2.s.tsv"),show_col_types = FALSE)
output$LIBID <- x
return(output)
})
library(tidyverse)
library(reshape2)
MGX_neg_ctrl_species_k2_df <- lapply(neg_ctrl_MGX_LIBID, function(x){
output <- read_tsv(file=paste0("../data/kraken2/DNA/",x,"_merged_decont_k2.s.tsv"),show_col_types = FALSE)
output$LIBID <- x
return(output)
})
View(MGX_neg_ctrl_species_k2_df)
MGX_neg_ctrl_species_k2_df <- lapply(neg_ctrl_MGX_LIBID, function(x){
output <- read_tsv(file=paste0("../data/kraken2/DNA/",x,"_merged_decont_k2.s.tsv"),
show_col_types = FALSE, col_names = c("rel_abun","paired_counts",
"minimizers","distinct_minimzers",
"k2_taxon"))
output$LIBID <- x
return(output)
}) %>% do.call("rbind",.)
MTX_neg_ctrl_species_k2_df <- lapply(neg_ctrl_MTX_LIBID, function(x){
output <- read_tsv(file=paste0("../data/kraken2/RNA/",x,"_merged_decont_k2.s.tsv"),
show_col_types = FALSE, col_names = c("rel_abun","paired_counts",
"minimizers","distinct_minimzers",
"k2_taxon"))
output$LIBID <- x
return(output)
}) %>% do.call("rbind",.)
df_to_matrix <- function(input_df){
output_matrix <- pivot_wider(input_df %>%
dplyr::select(k2_taxon, paired_counts, LIBID),
names_from = LIBID, values_from = paired_counts) %>%
as.data.frame()
output_matrix$species <- rownames(output_matrix)
output_matrix <- output_matrix %>% as.matrix()
#This matrix operation is much faster than mutate_all(~replace(.,is.na(.),0)) for tibbles/df
output_matrix[is.na(output_matrix)] <- 0
return(output_matrix)
}
MTX_neg_ctrl_species_k2_mat <- df_to_matrix(MTX_neg_ctrl_species_k2_df)
View(MTX_neg_ctrl_species_k2_mat)
df_to_matrix <- function(input_df){
output_matrix <- pivot_wider(input_df %>%
dplyr::select(k2_taxon, paired_counts, LIBID),
names_from = LIBID, values_from = paired_counts) %>%
dplyr::rename(species=k2_taxon) %>% as.matrix()
output_matrix <- output_matrix %>% as.matrix()
#This matrix operation is much faster than mutate_all(~replace(.,is.na(.),0)) for tibbles/df
output_matrix[is.na(output_matrix)] <- 0
return(output_matrix)
}
MTX_neg_ctrl_species_k2_mat <- df_to_matrix(MTX_neg_ctrl_species_k2_df)
View(MTX_neg_ctrl_species_k2_mat)
View(MTX_neg_ctrl_species_k2_mat)
MGX_neg_ctrl_species_k2_mat <- df_to_matrix(MGX_neg_ctrl_species_k2_df)
View(MGX_neg_ctrl_species_k2_mat)
MGX_species_k2_filtered_mat <- df_to_matrix(MGX_species_k2_filtered_df)
View(MGX_species_k2_filtered_df)
View(MGX_species_k2_filtered_mat)
MTX_species_k2_filtered_mat <- df_to_matrix(MTX_species_k2_filtered_df)
write_tsv(MTX_neg_ctrl_species_k2_mat, "../data/MTX_neg_ctrl_species_k2_mat.tsv")
write.table(MTX_neg_ctrl_species_k2_mat, "../data/MTX_neg_ctrl_species_k2_mat.tsv", sep = "\t", quote = FALSE)
write.table(MGX_neg_ctrl_species_k2_mat, "../data/MGX_neg_ctrl_species_k2_mat.tsv", sep = "\t", quote = FALSE)
write.table(MTX_species_k2_filtered_mat, "../data/MTX_species_k2_filtered_mat.tsv", sep = "\t", quote = FALSE)
write.table(MGX_species_k2_filtered_mat, "../data/MGX_species_k2_filtered_mat.tsv", sep = "\t", quote = FALSE)
MTX_neg_ctrl_species_k2_mat <- df_to_matrix(MTX_neg_ctrl_species_k2_df) %>% as.data.frame()
MGX_neg_ctrl_species_k2_mat <- df_to_matrix(MGX_neg_ctrl_species_k2_df) %>% as.data.frame()
MGX_species_k2_filtered_mat <- df_to_matrix(MGX_species_k2_filtered_df) %>% as.data.frame()
MTX_species_k2_filtered_mat <- df_to_matrix(MTX_species_k2_filtered_df) %>% as.data.frame()
write_tsv(MTX_neg_ctrl_species_k2_mat, "../data/MTX_neg_ctrl_species_k2_mat.tsv")
write_tsv(MGX_neg_ctrl_species_k2_mat, "../data/MGX_neg_ctrl_species_k2_mat.tsv")
write_tsv(MTX_species_k2_filtered_mat, "../data/MTX_species_k2_filtered_mat.tsv")
write_tsv(MGX_species_k2_filtered_mat, "../data/MGX_species_k2_filtered_mat.tsv")
View(MGX_neg_ctrl_species_k2_mat)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(reshape2)
library(ggpubr)
library(vegan)
library(gtools)
#functions
source("custom_functions.R")
metadata <- read_tsv("../metadata/skin_mtx_metadata_fmt.txt", show_col_types = FALSE)
mgx_stats <- read_tsv("../metadata/MGX_QC_stats.txt", show_col_types = FALSE)
mtx_stats <- read_tsv("../metadata/MTX_QC_stats.txt", show_col_types = FALSE)
mgx_stats <- merge(mgx_stats, metadata, by = "LIBID", all.x=TRUE)
mtx_stats <- merge(mtx_stats, metadata, by ="LIBID", all.x=TRUE)
#mtx_to_pull and mgx_to_pull refer to the 102 Libraries with paired MTX and MGX data:
mtx_to_pull <- read_tsv("../metadata/mtx_to_pull", col_names = FALSE, show_col_types = FALSE) %>% pull(X1)
mgx_to_pull <- read_tsv("../metadata/mgx_to_pull", col_names = FALSE, show_col_types = FALSE) %>% pull(X1)
mtx_stats_chosen <- mtx_stats %>% dplyr::filter(LIBID %in% mtx_to_pull)
mgx_stats_chosen <- mgx_stats %>% dplyr::filter(LIBID %in% mgx_to_pull)
mtx_mgx_stats_chosen <- read_tsv(file="../metadata/mtx_mgx_stats_chosen.tsv", show_col_types = FALSE)
#
mtx_to_M_globosa_QC <- read_csv("../metadata/mtx_for_M_globosa_mapping.csv")
mtx_to_M_globosa_QC$mapped_to_species <- "Malassezia_globosa"
mtx_to_M_restricta_QC <- read_csv("../metadata/mtx_for_M_restricta_mapping.csv")
mtx_to_M_restricta_QC$mapped_to_species <- "Malassezia_restricta"
########################################################
##metadata and read count information for pilot cohort##
########################################################
non_ribodepleted_mtx <- read_tsv("../metadata/no_ribodepletion_MTX_QC_stats.txt", show_col_types = FALSE)
pilot_cohort_read_count_QC <- read_tsv("../metadata/pilot_MTX_QC_stats.txt", show_col_types = FALSE)
#excluding pilot negative controls
pilot_cohort_samples_read_count_QC <- pilot_cohort_read_count_QC %>% dplyr::filter(!LIBID %in% c("Neg012",
"Neg013", "Neg014"))
pilot_QC_wetlab_metadata <- read_tsv("../metadata/pilot_cohort_RNA_wetlab_QC.txt", show_col_types = FALSE)
tech_reps_a <- metadata %>% dplyr::filter(subj_region %in% c("SMT001_Tw","SMT023_Ch","SMT023_Ac") & mol_type=="RNA")
tech_reps_b <- metadata %>% dplyr::filter(comments == "technical replicate analysis" & subj_region != "3 Bac (VV:LM:PS)")
tech_reps <- c(tech_reps_a$LIBID, tech_reps_b$LIBID)
tech_reps_metadata <- metadata %>% dplyr::filter(LIBID %in% tech_reps)
#metadata for the longitudinal cohort
longitudinal_metadata <- read_tsv("../metadata/skin_mtx_longitudinal_metadata.txt", show_col_types = FALSE) %>%
dplyr::filter(!subject %in% c("Neg012","Neg013","Neg014"))
longitudinal_metadata$LIBID <- longitudinal_metadata$subj_region
longitudinal_metadata$sequenced <- ifelse(longitudinal_metadata$low_conc == "fail", FALSE, TRUE)
longitudinal_metadata <- longitudinal_metadata %>% mutate_at('sequenced', ~replace_na(.,TRUE))
#Only "passed" samples were sent for sequencing
longitudinal_metadata_passed <- longitudinal_metadata %>% dplyr::filter(sequenced == TRUE)
View(metadata)
View(mgx_stats)
63/69
63/70
